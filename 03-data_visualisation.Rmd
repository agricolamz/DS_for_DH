---
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE)
ggplot2::theme_set(ggplot2::theme_bw())
```

# Визуализация данных {#viz_1}

```{r, message = FALSE}
library("tidyverse")
```

## Зачем визуализировать данные?
### Квартет Анскомба
В работе Anscombe, F. J. (1973). "Graphs in Statistical Analysis" представлен следующий датасет:

```{r, message= FALSE}
quartet <- read_csv("https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/anscombe.csv")
quartet
quartet %>% 
  group_by(dataset) %>% 
  summarise(mean_X = mean(x),
            mean_Y = mean(y),
            sd_X = sd(x),
            sd_Y = sd(y),
            cor = cor(x, y),
            n_obs = n()) %>% 
  select(-dataset) %>% 
  round(2)
```

```{r, echo = FALSE, message=FALSE}
library(ggplot2)
quartet %>% 
  ggplot(aes(x, y))+
  geom_point()+
  geom_smooth(method = "lm", se = F)+
  facet_wrap(~dataset)+
  theme_bw()
```

### Датазаурус
В работе [Matejka and Fitzmaurice (2017) "Same Stats, Different Graphs"](https://www.autodeskresearch.com/sites/default/files/SameStats-DifferentGraphs.pdf) были представлены следующие датасеты:

```{r, message= FALSE}
datasaurus <- read_csv("https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/datasaurus.csv")
datasaurus
```

```{r, echo=FALSE, message= FALSE}
datasaurus %>% 
  ggplot(aes(x, y))+
  geom_point()+
  facet_wrap(~dataset)+
  theme_bw()
```

```{r}
datasaurus %>% 
  group_by(dataset) %>% 
  summarise(mean_X = mean(x),
            mean_Y = mean(y),
            sd_X = sd(x),
            sd_Y = sd(y),
            cor = cor(x, y),
            n_obs = n()) %>% 
  select(-dataset) %>% 
  round(1)
```

## Основы `ggplot2`
Пакет `ggplot2` -- современный стандарт для создания графиков в R. Для этого пакета пишут [массу расширений](http://www.ggplot2-exts.org/gallery/). В сжатом виде информация про ggplot2 [содержиться здесь](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf).

### Диаграмма рассеяния (Scaterplot)

* ggplot2
```{r}
ggplot(data = diamonds, aes(carat, price)) +
  geom_point()
```

* dplyr, ggplot2
```{r}
diamonds %>%
  ggplot(aes(carat, price))+
  geom_point()
```

### Слои

```{r}
diamonds %>%
  ggplot(aes(carat, price))+
  geom_point()+
  geom_smooth()
```

```{r}
diamonds %>%
  ggplot(aes(carat, price))+
  geom_smooth()+
  geom_point()
```


### `aes()`

```{r}
diamonds %>%
  ggplot(aes(carat, price, color = cut))+
  geom_point()
```

```{r}
diamonds %>%
  ggplot(aes(carat, price))+
  geom_point(color = "green")
```

```{r}
diamonds %>%
  ggplot(aes(carat, price))+
  geom_point(aes(color = cut))
```

```{r}
diamonds %>%
  ggplot(aes(carat, price, shape = cut))+
  geom_point()
```

```{r}
diamonds %>%
  ggplot(aes(carat, price, label = color))+
  geom_text()
```

```{r}
diamonds %>%
  slice(1:100) %>% 
  ggplot(aes(carat, price, label = color))+
  geom_label()
```

Иногда аннотации налезают друг на друга:

```{r}
library(ggrepel)
diamonds %>%
  slice(1:100) %>% 
  ggplot(aes(carat, price, label = color))+
  geom_text_repel()
```

```{r}
diamonds %>%
  slice(1:100) %>% 
  ggplot(aes(carat, price, label = color))+
  geom_text_repel()+
  geom_point()
```

```{r}
diamonds %>%
  slice(1:100) %>% 
  ggplot(aes(carat, price, label = color, fill = cut))+ # fill отвечает за закрашивание
  geom_label_repel(alpha = 0.5)+ # alpha отвечает за прозрачность
  geom_point()
```

### Оформление

```{r}
diamonds %>%
  ggplot(aes(carat, price, color = cut))+
  geom_point() + 
  labs(x = "вес (в каратах)",
       y = "цена (в долларах)",
       title = "Связь цены и веса бриллиантов",
       subtitle = "Данные взяты из датасеты diamonds",
       caption = "график сделан при помощи пакета ggplot2")+
  theme(legend.position = "bottom") # у функции theme() огромный функционал
```

### Логарифмические шкалы
![](images/log_scales.png)

Рассмотрим словарь [Ляшевской, Шарова 2011]

```{r freqdict_download, cache=TRUE}
freqdict <- read_tsv("https://github.com/agricolamz/DS_for_DH/raw/master/data/freq_dict_2011.csv")
freqdict %>% 
  arrange(desc(freq_ipm)) %>% 
  mutate(id = 1:n()) %>% 
  slice(1:150) %>% 
  ggplot(aes(id, freq_ipm))+
  geom_point()
```

```{r freqdict_visualise, cache=TRUE}
freqdict %>% 
  arrange(desc(freq_ipm)) %>% 
  mutate(id = 1:n()) %>% 
  slice(1:150) %>% 
  ggplot(aes(id, freq_ipm, label = lemma))+
  geom_point()+
  geom_text_repel()+
  scale_y_log10()
```

### `annotate()`
Функция `annotate` добавляет `geom` к графику.
```{r}
diamonds %>%
  ggplot(aes(carat, price, color = cut))+
  geom_point()+
  annotate(geom = "rect", xmin = 4.8, xmax = 5.2,
           ymin = 17500, ymax = 18500, fill = "red", alpha = 0.2) + 
  annotate(geom = "text", x = 4.7, y = 16600,
           label = "помогите...\n я в розовом\nквадратике")
```

## Столбчатые диаграммы (barplots)

Одна и та же информация может быть представлена в агрегированном и не агрегированном варианте:

```{r}
misspelling <- read_csv("https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/misspelling_dataset.csv")
misspelling 
```

* переменные spelling **аггрегирована**: для каждого значения представлено значение в столбце count, которое обозначает количество каждого из написаний
* переменные correct **неаггрегированы**: в этом столбце она повторяется, для того, чтобы сделать вывод, нужно отдельно посчитать количество вариантов


Для аггрегированных данных используется `geom_col()`
```{r}
misspelling %>% 
  slice(1:20) %>% 
  ggplot(aes(spelling, count))+
  geom_col()
```

Перевернем оси:
```{r}
misspelling %>% 
  slice(1:20) %>% 
  ggplot(aes(spelling, count))+
  geom_col()+
  coord_flip()
```

Для аггрегированных данных используется `geom_bar()`

```{r}
misspelling %>% 
  ggplot(aes(correct))+
  geom_bar()
```

Перевернем оси:
```{r}
misspelling %>% 
  ggplot(aes(correct))+
  geom_bar()+
  coord_flip()
```

## Факторы
Как можно заметить по предыдущему разделу, переменные на графике упорядочены по алфавиту. Чтобы это исправить нужно обсудить факторы:

```{r}
my_factor <- factor(misspelling$correct)
head(my_factor)
levels(my_factor)
levels(my_factor) <- rev(levels(my_factor))
head(my_factor)

misspelling %>% 
  mutate(correct = factor(correct, levels = c("deschanel",
                                              "galifianakis",
                                              "johansson",
                                              "kaepernick",
                                              "labeouf",
                                              "macaulay",
                                              "mcgwire",
                                              "mclachlan",
                                              "minaj",
                                              "morissette",
                                              "palahniuk",
                                              "picabo",
                                              "poehler",
                                              "shyamalan",
                                              "mcconaughey"))) %>% 
  ggplot(aes(correct))+
  geom_bar()+
  coord_flip()
```

Для работы с факторами удобно использовать пакет `forcats` (входит в `tidyverse`, вот [ссылка на cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/factors.pdf)).

Иногда полезной бывает функция `fct_reorder()`:

```{r}
misspelling %>% 
  count(correct)

misspelling %>% 
  count(correct) %>% 
  ggplot(aes(fct_reorder(correct, n), n))+
  geom_col()+
  coord_flip()
```

Можно совмещать разные `geom_...`:

```{r}
misspelling %>% 
  count(correct) %>% 
  ggplot(aes(fct_reorder(correct, n), n, label = n))+
  geom_col()+
  geom_text(nudge_y = 150)+
  coord_flip()
```


```{block, type = "rmdtask"}
На новостном портале meduza.io недавно вышла [новость о применения закона "о неуважении к власти в интернете"](https://meduza.io/short/2019/09/30/pervye-polgoda-primeneniya-zakona-o-neuvazhenii-k-vlasti-v-internete-doklad-agory). Постройте графики из этой новости. Для того, чтобы создать объединяющую линию по всем месяцам, нужно использовать `geom_line()`, заведя перед этим общую для всех наблюдений переменную с одним значением, например, `type = 1`, а потом в `aes(..., group = type)`. При построении графиков я использовал цвет `"tan3"`.
```
![](images/visualisation_task.png)

```{r, echo=FALSE}
months <- c("апрель", "май", "июнь", "июль", "август", "сентябрь")
tibble(month = factor(months, levels = months),
       value = c(2, 12, 14, 8, 5, 4),
       type = 1) %>% 
  ggplot(aes(month, value, label = value, group = type))+
  geom_point(color = "tan3")+
  geom_text(nudge_y = 1)+
  geom_line(color = "tan3")+
  theme_bw()+
  labs(title = "Сколько дел возбудили по новому закону", x = "", y = "") ->
  p1

tibble(words = c("Путин", "общество", "губернаторы", "силовики", '"Единая Россия"', "местные чиновники", "судьи", "депутаты", "конституция", "Росатом"),
       values = c(26, 4, 3, 3, 2, 2, 2, 1, 1, 1)) %>%
  ggplot(aes(fct_reorder(words, values), values, label = values))+
  geom_col(fill = "tan3")+
  geom_text(nudge_y = 0.6)+
  coord_flip()+
  labs(title = "Кто был объектом неуважения", x = "", y = "", caption = "данные meduza.io") ->
  p2

plot(gridExtra::arrangeGrob(p1, p2, nrow = 2))
```


## Точки, джиттер (jitter), ящики с усами (boxplot), (violinplot)

```{r, cache=TRUE}
diamonds %>% 
  ggplot(aes(cut, price))+
  geom_point()

diamonds %>% 
  ggplot(aes(cut, price))+
  geom_jitter()

diamonds %>% 
  ggplot(aes(cut, price))+
  geom_boxplot()

diamonds %>% 
  ggplot(aes(cut, price))+
  geom_violin()
```

## Гистограммы
## Функции плотности
## Фасетизация

## Визуализация комбинаций признаков
### Потоковая Диаграмма (Sankey diagram)

Один из способов визуализации отношений между признаками называется [потоковая диаграмма](https://en.wikipedia.org/wiki/Sankey_diagram).

```{r, warning=FALSE}
library("ggforce")
zhadina <- read_csv("https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/zhadina.csv")
zhadina %>% 
  gather_set_data(1:3) %>% 
  ggplot(aes(x, id = id, split = y, value = n))+
  geom_parallel_sets(aes(fill = type), alpha = 0.6, axis.width = 0.5) +
  geom_parallel_sets_axes(axis.width = 0.5, color = "lightgrey", fill = "white") +
  geom_parallel_sets_labels(angle = 0) +
  theme_no_axes()+
  theme(legend.position = "bottom")
```

А как поменять порядок? Снова факторы.

```{r, warning=FALSE}
zhadina %>% 
  gather_set_data(1:3) %>% 
  mutate(y = reorder(y, n)) %>% 
  ggplot(aes(x, id = id, split = y, value = n))+
  geom_parallel_sets(aes(fill = type), alpha = 0.6, axis.width = 0.5) +
  geom_parallel_sets_axes(axis.width = 0.5, color = "lightgrey", fill = "white") +
  geom_parallel_sets_labels(angle = 0) +
  theme_no_axes()+
  theme(legend.position = "bottom")
```

Можно донастроить, задав собственный порядок в аргументе `levels` функции `factor()`.

### UpSet Plot

Если диаграмма Sankey визуализирует попарные отношения между переменными, то график UpSet потенциально может визуализировать все возможные комбинации и является хорошей альтернативой диаграмме Вена, с большим количеством переменных (см. [эту статью Лауры Эллис](https://www.littlemissdata.com/blog/set-analysis)).

```{r, fig.height=9}
library(UpSetR)
movies <- read.csv( system.file("extdata", "movies.csv", package = "UpSetR"), header=TRUE, sep=";" )
str(movies)
upset(movies[,3:19], nsets = 16, order.by = "freq")
```

