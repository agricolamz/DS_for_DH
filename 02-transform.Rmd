# `tidyverse`: Загрузка и трансформация данных {#tidy_dplyr}

[_tidyverse_](https://www.tidyverse.org) --- это набор пакетов:

* _ggplot2_, для визуализации
* _tibble_, для работы с тибблами, современный вариант датафрейма
* _tidyr_, для формата tidy data
* _readr_, для чтения файлов в R
* _purrr_, для функционального программирования
* _dplyr_, для преобразованиия данных
* _stringr_, для работы со строковыми переменными
* _forcats_, для работы с переменными-факторами

Полезно также знать о следующих:

* _readxl_, для чтения .xls и .xlsx
* _jsonlite_, для работы с JSON
* _rvest_, для веб-скреппинга
* _lubridate_, для работы с временем
* _tidytext_, для работы с текстами и корпусами
* _broom_, для перевода в tidy формат статистические модели

```{r, message = TRUE}
library("tidyverse")
```

## Загрузка данных
### Рабочая директория

Все в R происходит где-то. Нужно загружать файлы с данными, нужно их куда-то сохранять. Желательно иметь для каждого проекта некоторую отдельную папку на компьютере, куда складывать все, отнсящееся к этому проекту. Две команды позволят опредить текущую рабочую дерикторию (`getwd()`) и (`setwd(.../path/to/your/directory)`).

### Форматы данных: `.csv`

Существет много форматов данных, которые придумали люди. Большинство из них можно загрузить в R. Так как центральный объект в R -- таблица $n \times k$, то и работать мы большую часть времени будем с таблицами. Наиболее распространенные способы хранить данные сейчас это `.csv` (разберем в данном разделе) и `.json` (разберем в разделе @ref{dplyr_purr}).

`.csv` (comma separated values) -- является обычным текстовым файлом, в котором перечислены значения с некоторым фиксированным разделителем: запятой, табуляцией, точка с запятой, пробел и др. Такие файлы обычно легко открывает LibreOffice, а в [Microsoft Excel нужны некоторые трюки](https://superuser.com/questions/291445/how-do-you-change-default-delimiter-in-the-text-import-in-excel).

### Загрузка данных: readr, readxl
Стандартной функцией для чтения `.csv` файлов в R является функция `read.csv()`, но мы будем использовать функцию `read_csv()` из пакета `readr`.

```{r, eval = FALSE}
read_csv("...")
```

Вместо многоточия может стоять:

* название файла  (если он, есть в текущей рабочей дериктории)
```{r, eval = FALSE}
read_csv("my_file.csv")
```

* относительный путь к файлу (если он, верен для текущей рабочей дериктории)
```{r, eval = FALSE}
read_csv("data/my_file.csv")
```

* полный путь к файлу (если он, верен для текущей рабочей дериктории)
```{r, eval = FALSE}
read_csv("/home/user_name/work/data/my_file.csv")
```

* интернет ссылка (тогда, компьютер должен быть подключен к интернету)
```{r, eval = FALSE}
read_csv("https://my_host/my_file.csv")
```

Для чтения других форматов `.csv` файлов используются другие функции:

* `read_tsv()` -- для файлов с табуляцией в качестве разделителя
* `read_csv2()` -- для файлов с точкой с запятой в качестве разделителя 
* `read_delim(file = "...", delim = "...")` -- для файлов с любым разделителем, задаваемым аргументом `delim`

Стандартной практикой является создавать первой строкой `.csv` файлов названия столбцов, поэтому по умолчанию функции `read_...()`  будут создавать таблицу, считая первую строку названием столбцов. Чтобы изменить это поведение следует использовать аргумент `col_names = FALSE`.

Другая проблема при чтении файлов -- кодировка и локаль. На разных компьютерах разные локали и дефолтные кодировки, так что имеет смысл знать про аргумент `locale("en_US", encoding = "UTF-8")`.

> Попробуйте корректно считать в R файл [по этой ссылке](https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/scary_letters.csv).

```{r, echo=FALSE, message=FALSE, warning=FALSE}
read_csv2("https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/scary_letters.csv")
```

Благодаря `readxl` пакету Также данные можно скачать напрямую из файлов `.xls` (функция `read_xls`) и `.xlsx` (функция `read_xlsx`), однако эти функции не умеют читать из интернета.

```{r, eval = FALSE}
library("readxl")
xlsx_example <- read_xlsx("...")
```

Существует еще один экстравагантный способ хранить данные: это формат файлов R `.RData`. Создадим data.frame:

```{r}
df <- data.frame(letters = c("a", "b"),
                 numbers = 1:2)
df
```

Теперь можно сохранить файл...

```{r}
save(df, file = "data/my_df.RData")
```

удалить переменную...

```{r error = TRUE}
rm(df)
df
```

и загрузить все снова:

```{r}
load("data/my_df.RData")
```

#### Misspelling dataset
Этот датасет я переработал из данных, собранных для статьи [The Gyllenhaal Experiment](https://pudding.cool/2019/02/gyllenhaal/), написанной Расселом Гольденбергом и Мэттом Дэниэлсом для издания [pudding](https://pudding.cool). Они анализировали ошибки в правописании при поиске имен и фамилий звезд.

```{r}
misspellings <- read_csv("https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/misspelling_dataset.csv")
```
  

```{r}
misspellings
```

В датасете следующие переменные:

* `correct` -- корректное написание фамилии
* `spelling` -- написание, которое сделали пользователи
* `count` -- количество случаев такого написания

#### `diamonds`

```{r}
diamonds
?diamonds
```


## `tibble`

Пакет `tibble` -- является альтернативой штатного датафрейма в R. Существует встроенная переменная `month.name`:

```{r}
month.name
```

Можно создать датафрейм таким образом:

```{r error=TRUE}
data.frame(id = 1:12,
           months = month.name,
           n_letters = nchar(months))
```

Однако переменная `months` не создана пользователем, так что данный код выдает ошибку. Корректный способ сделать это базовыми средствами:

```{r}
data.frame(id = 1:12,
           months = month.name,
           n_letters = nchar(month.name))
```

Одно из отличий `tibble` от базового датафрейма -- возможность использовать создаваемые "по ходу пьесы переменные"

```{r}
tibble(id = 1:12,
       months = month.name,
       n_letters = nchar(months))
```

Если в окружении пользователя уже есть переменная с датафреймом, его легко можно переделать в `tibble` при помощи функции `as_tibble()`:

```{r}
df <- data.frame(id = 1:12,
                 months = month.name)

df
as_tibble(df)
```

Функицонально `tibble` от `data.frame` ничем не отличается, однако существует ряд несущественных отличий. Кроме того стоит помнить, что многие функции из `tidyverse` возвращают именно `tibble`, а не `data.frame`.

## `dplyr`
### `dplyr::filter()`
Сколько неправильных произношений, которые написали меньше 10 юзеров?

```{r}
misspellings %>%
  filter(count < 10)
```

`%>%` --- конвеер (pipe) отправляет результат работы одной функции в другую.

```{r}
sort(sqrt(abs(sin(1:22))), decreasing = TRUE)
1:22 %>% 
  sin() %>% 
  abs() %>% 
  sqrt() %>% 
  sort(., decreasing = TRUE) # зачем здесь точка?
```

Конвееры в _tidyverse_ пришли из пакета _magrittr_. Иногда они работают не корректно с функциями не из _tidyverse_.

![](https://magrittr.tidyverse.org/logo.png)

### `dplyr::slice()`

```{r}
misspellings %>%
  slice(3:7)
```



### `dplyr::select()`

```{r}
diamonds %>%
  select(8:10)

diamonds %>%
  select(color:price)

diamonds %>%
  select(-carat)

diamonds %>%
  select(-c(carat, cut, x, y, z))

diamonds %>%
  select(cut, depth, price)
```

### `dplyr::arrange()`

```{r}
misspellings %>%
  arrange(count)

diamonds %>%
  arrange(desc(carat), price)
```

### `dplyr::distinct()`

```{r}
misspellings %>%
  distinct(correct)

misspellings %>%
  distinct(spelling)

diamonds %>%
  distinct(color, cut)
```

### `dplyr::mutate()`

```{r}
misspellings %>%
  mutate(misspelling_length = nchar(spelling))
```

### `dplyr::group_by(...) %>% summarise(...)`

```{r}
misspellings %>%
  summarise(min(count), mean(count))

misspellings %>%
  group_by(correct) %>% 
  summarise(mean(count))

misspellings %>%
  group_by(correct) %>% 
  summarise(my_mean = mean(count))
```

Если нужно посчитать количество вхождений, то можно использовать функцию `n()` в `summarise()` или же функцию `count()`:

```{r}
misspellings %>%
  group_by(correct) %>% 
  summarise(n = n())


misspellings %>%
  count(correct)
```

Можно даже отсортировать результат:

```{r}
misspellings %>%
  count(correct, sort = TRUE)
```

Если вы хотите создать не какое-то саммари, а целый дополнительный столбец с этим саммари вместо функции `summarise()` нужно использовать функцию `mutate()`:

```{r}
misspellings %>%
  group_by(correct) %>% 
  mutate(my_mean = mean(count))
```


### `dplyr::.._join()`

```{r}
languages <- data_frame(
  languages = c("Selkup", "French", "Chukchi", "Polish"),
  countries = c("Russia", "France", "Russia", "Poland"),
  iso = c("sel", "fra", "ckt", "pol")
  )
languages
country_population <- data_frame(
  countries = c("Russia", "Poland", "Finland"),
  population_mln = c(143, 38, 5))
country_population
inner_join(languages, country_population)
left_join(languages, country_population)
right_join(languages, country_population)
anti_join(languages, country_population)
anti_join(country_population, languages)
full_join(country_population, languages)
```

## `tidyr` package

* Short format

```{r}
df.short <- data.frame(
                   consonant = c("stops", "fricatives", "affricates", "nasals"),
                   initial = c(123, 87, 73, 7),
                   intervocal = c(57, 77, 82, 78),
                   final = c(30, 69, 12, 104))
df.short
```

* Long format

```{r, echo = FALSE}
df.short %>% 
  gather(position, number, initial:final) ->
  df.long
df.long
```

* Short format → Long format: `tidyr::gather()`

```{r}
df.short <- data.frame(
                   consonant = c("stops", "fricatives", "affricates", "nasals"),
                   initial = c(123, 87, 73, 7),
                   intervocal = c(57, 77, 82, 78),
                   final = c(30, 69, 12, 104))
df.short

df.short %>% 
  gather(position, number, initial:final) ->
  df.long
df.long
```

* Long format → Short format: `tidyr::spread()`

```{r}
df.long %>% 
  spread(position, number) ->
  df.short
df.short
```
