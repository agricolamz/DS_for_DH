[
["работа-со-временем-lubridate.html", "11 Работа со временем: lubridate 11.1 Создание даты 11.2 Извлечение компонентов даты 11.3 Операции с датами 11.4 Визуализация времени: данные Левада-центра", " 11 Работа со временем: lubridate library(tidyverse) Мы обсуждали, что переменные бывают разные. О них, возможно, следует думать как о шкале: Кажется, что время – просто обычная числовая переменная, на которой определены все обычные операции сложения вычитания и т. п. Однако стоит держать в голове несколько фактов: Не каждый год содержит 365 дней. Существуют высокосные года. Не каждый день содержит 24 часа. Во многих странах используют переход на летнее и зимнее время. Не в каждой минуте 60 секунд. Существуют дополнительная секунда, которую добавляют чтобы компенсировать замедление во вращении земли (тогда после секунды 23:59:59 идет секунда 23:59:60). Все это мелочи учтены в пакете lubridate, созданном для работы со временем в R (https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf, туториал доступен здесь и по команде vignette(\"lubridate\")). Первые команды, которые нужно изучить: library(lubridate) ## ## Attaching package: &#39;lubridate&#39; ## The following object is masked from &#39;package:base&#39;: ## ## date today() ## [1] &quot;2020-01-04&quot; now() ## [1] &quot;2020-01-04 13:39:05 MSK&quot; Как видно, из этих функций в R можно работать как с датами, так и с временем. В качестве иллюстрации мы будем использовать датасет flights из пакета nycflights13, в котором содержатся данные по полетам из Нью Йорка в 2013 года. library(nycflights13) flights 11.1 Создание даты Самый простой способ получить дату — это преобразовать строку в формат даты, для этого надо просто упорядочить y (year), m (month) и d (day) в команде: ymd(&quot;2020-01-21&quot;) ## [1] &quot;2020-01-21&quot; ymd(&quot;20-01-21&quot;) ## [1] &quot;2020-01-21&quot; ymd(&quot;20.01.21&quot;) ## [1] &quot;2020-01-21&quot; ymd(&quot;20/01/21&quot;) ## [1] &quot;2020-01-21&quot; ymd(&quot;200121&quot;) ## [1] &quot;2020-01-21&quot; mdy(&quot;January 21st, 2020&quot;) ## [1] &quot;2020-01-21&quot; dmy(&quot;21-Jan-2020&quot;) ## [1] &quot;2020-01-21&quot; Команды понимают не только английский (хоть и с трудом): dmy(&quot;21 янв 2020&quot;, locale = &quot;ru_RU.UTF-8&quot;) ## [1] &quot;2020-01-21&quot; dmy(&quot;21 янв. 2020&quot;, locale = &quot;ru_RU.UTF-8&quot;) ## [1] &quot;2020-01-21&quot; dmy(&quot;21 ян 2020&quot;, locale = &quot;ru_RU.UTF-8&quot;) ## Warning: All formats failed to parse. No formats found. ## [1] NA dmy(&quot;21 янва 2020&quot;, locale = &quot;ru_RU.UTF-8&quot;) ## [1] &quot;2020-01-21&quot; dmy(&quot;21 января 2020&quot;, locale = &quot;ru_RU.UTF-8&quot;) ## Warning: 1 failed to parse. ## [1] NA dmy(&quot;21 январь 2020&quot;, locale = &quot;ru_RU.UTF-8&quot;) ## [1] &quot;2020-01-21&quot; dmy(&quot;21 Январь 2020&quot;, locale = &quot;ru_RU.UTF-8&quot;) ## [1] &quot;2020-01-21&quot; Аналогично сделаны команды состоящие из h, m, s: hms(&quot;20:01:02&quot;) ## [1] &quot;20H 1M 2S&quot; hm(&quot;20.01&quot;) ## [1] &quot;20H 1M 0S&quot; ms(&quot;23:59&quot;) ## [1] &quot;23M 59S&quot; Также существует команда make_datetime(), которая позволяет сделать дату из нескольких переменных: flights %&gt;% mutate(departure = make_datetime(year, month, day, hour, minute)) %&gt;% select(departure) 11.2 Извлечение компонентов даты Для извлечения компонентов даты используются функции year(), month(), week() (номер недели в году), mday() (day of the month), wday() (номер дня в неделе), yday() (номер дня в году), hour(), minute() и second(): date_example &lt;- flights$time_hour[1] date_example ## [1] &quot;2013-01-01 05:00:00 EST&quot; year(date_example) ## [1] 2013 month(date_example) ## [1] 1 month(date_example, label = TRUE) ## [1] Jan ## 12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; ... &lt; Dec month(date_example, label = TRUE, abbr = FALSE) ## [1] January ## 12 Levels: January &lt; February &lt; March &lt; April &lt; May &lt; June &lt; ... &lt; December month(date_example, label = TRUE, locale = &quot;ru_RU.UTF-8&quot;) ## [1] янв ## 12 Levels: янв &lt; фев &lt; мар &lt; апр &lt; мая &lt; июн &lt; июл &lt; авг &lt; сен &lt; ... &lt; дек week(date_example) ## [1] 1 mday(date_example) ## [1] 1 wday(date_example) ## [1] 3 wday(date_example, label = TRUE) ## [1] Tue ## Levels: Sun &lt; Mon &lt; Tue &lt; Wed &lt; Thu &lt; Fri &lt; Sat wday(date_example, label = TRUE, abbr = FALSE) ## [1] Tuesday ## 7 Levels: Sunday &lt; Monday &lt; Tuesday &lt; Wednesday &lt; Thursday &lt; ... &lt; Saturday wday(date_example, label = TRUE, locale = &quot;ru_RU.UTF-8&quot;) ## [1] Вт ## Levels: Вс &lt; Пн &lt; Вт &lt; Ср &lt; Чт &lt; Пт &lt; Сб yday(date_example) ## [1] 1 hour(date_example) ## [1] 5 minute(date_example) ## [1] 0 second(date_example) ## [1] 0 Так же есть функция leap_year(), которая сообщает информацию, является ли выбранный год високосным: leap_year(2019) ## [1] FALSE leap_year(2020) ## [1] TRUE Постройте график распределения полетов по дням недели из датасета flights пакета nycflights13: 11.3 Операции с датами Если взять две даты, то можно узнать разницу между ними и т. п.: ymd(&quot;2020-01-21&quot;) - ymd(&quot;2020-01-19&quot;) ## Time difference of 2 days ymd(&quot;2020-01-19&quot;) - ymd(&quot;2020-01-21&quot;) ## Time difference of -2 days Обратите внимание на результат работы этого выражения: hm(&quot;21:00&quot;) - hm(&quot;18:10&quot;) ## [1] &quot;3H -10M 0S&quot; Видимо, почему-то в таком использовании происходит поэлементная операция с часами, минутами, и секундами, так что в результате получаются отрицательные минуты. Однако, если использовать полные даты, то этого эффекта нет: ymd_hm(&quot;2020-01-21, 21:00&quot;) - ymd_hm(&quot;2020-01-21, 18:10&quot;) ## Time difference of 2.833333 hours ymd_hm(&quot;2020-01-21, 21:00&quot;) - hm(&quot;18:10&quot;) ## [1] &quot;2020-01-21 02:50:00 UTC&quot; Также существует функция difftime(), которая позволяет настраивать единицы, в которых выдается результат: difftime(ymd_hm(&quot;2020-01-21, 21:00&quot;), ymd_hm(&quot;2020-01-21, 18:10&quot;), units = &quot;mins&quot;) ## Time difference of 170 mins difftime(ymd_hm(&quot;2020-01-21, 21:00&quot;), ymd_hm(&quot;2020-01-21, 18:10&quot;), units = &quot;hours&quot;) ## Time difference of 2.833333 hours У меня есть шенгенская мультивиза на 90 дней. Я совершил несколько поездок в Европу и записал их в этот датасет. Определите, сколько дней я еще могу находиться в Евросоюзе? Однако простые даты, не являются временными отрезками, так что их нельзя складывать, вычитать, умножать и т. д. Для удобства операций в lubridate вводится несколько сущностей: periods — промежутки времени, которые игнорируют нерегулярности во времени, сразу прибавляя 1 к соответствующему разряду, вводятся функциями years(), months(), weeks(), days(), hours(), minutes(), seconds(), period() duration — промежутки времени, которые учитывают нерегулярности во времени, добавляя стандартную длительность единицы, вводятся функциями dyears(), dweeks(), ddays(), dhours(), dminutes(), dseconds(), duration() Рассмотрим несколько сложных случаев: високосный год ymd(&quot;2019-03-01&quot;)+years(1) ## [1] &quot;2020-03-01&quot; ymd(&quot;2019-03-01&quot;)+dyears(1) ## [1] &quot;2020-02-29&quot; переход на летнее время ymd_hms(&quot;2020-03-07 13:00:00&quot;, tz = &quot;America/New_York&quot;) + days(1) ## [1] &quot;2020-03-08 13:00:00 EDT&quot; ymd_hms(&quot;2020-03-07 13:00:00&quot;, tz = &quot;America/New_York&quot;) + ddays(1) ## [1] &quot;2020-03-08 14:00:00 EDT&quot; переход на зимнее время ymd_hms(&quot;2020-10-31 13:00:00&quot;, tz = &quot;America/New_York&quot;) + days(1) ## [1] &quot;2020-11-01 13:00:00 EST&quot; ymd_hms(&quot;2020-10-31 13:00:00&quot;, tz = &quot;America/New_York&quot;) + ddays(1) ## [1] &quot;2020-11-01 12:00:00 EST&quot; 11.4 Визуализация времени: данные Левада-центра Пакет tidyverse понимает переменные типа дата, и позволяет их фильтровать и визуализировать: flights %&gt;% mutate(end = time_hour + dminutes(air_time)) %&gt;% filter(end &lt; ymd(&quot;2013-01-02&quot;)) %&gt;% ggplot(aes(time_hour, end))+ geom_point(alpha = 0.2) Однако ко переменным со врменем не всегда относятся аккуратно. Рассмотрим график с сайта Левада-центра — российской негосударственной исследовательской организации, которая проводит социологические и маркетинговые исследования (график взят отсюда): На первый взгляд, в этом графике нет ничего странного, однако если присмотреться к динамической версии на сайте Левада-центра, можно обнаружить, что на идущие подряд измерения расположены на одинаковом расстоянии друг от друга, например, 05.2014, 07.2014, 11.2014. Вот здесь можно скачать данные, по которым строился этот график. Вот как он выглядит, если считать временную переменную как время levada &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/2019.01_levada_countries.csv&quot;) levada %&gt;% mutate(date = str_c(&quot;1-&quot;, date), date = dmy(date)) %&gt;% filter(towards == &quot;USA&quot;) %&gt;% pivot_longer(names_to = &quot;answer&quot;, values_to = &quot;number&quot;, good:bad) %&gt;% ggplot(aes(date, number, color = answer))+ geom_line()+ labs(x = &quot;&quot;, y = &quot;&quot;, caption = &quot;данные Левада-центра&quot;)+ scale_y_continuous(limits = c(0, 100))+ theme(legend.position = c(0.1, 0.9), legend.title = element_blank()) На графике теперь видно, насколько регулярно проводились опросы: в начале 90-ых опросы проводились реже, потом часто, потом в районе 2010 года был перерыв. График Левада-центра можно оправдать тем, что они представляют данные от замера к замеру, так что по оси x находится как бы категориальная переменная со значениями замер 05.2014, замер 07.2014, замер 11.2014 и т. д. Однако это совсем неочевидно из графика. Используя весь датасет Левада-центра постройте следующий график. "]
]
