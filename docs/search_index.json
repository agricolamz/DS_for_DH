[
["index.html", "Наука о данных в R для программы Цифровых гуманитарных исследований 1 О курсе", " Наука о данных в R для программы Цифровых гуманитарных исследований Г. А. Мороз, И. С. Поздняков 1 О курсе Материалы для курса Наука о данных для магистерской программы Цифровых гуманитарные исследования НИУ ВШЭ. "],
["intro.html", "2 Введение в R 2.1 Наука о данных 2.2 Установка R и RStudio 2.3 Полезные ссылки 2.4 Rstudio 2.5 Введение в R 2.6 Типы данных 2.7 Вектор 2.8 Матрицы (matrix) 2.9 Списки (list) 2.10 Data.frame 2.11 Начинаем работу с реальными данными 2.12 Препроцессинг данных в R", " 2 Введение в R 2.1 Наука о данных Наука о данных — это новая область знаний, которая активно развивается в последнее время. Она находиться на пересечении компьютерных наук, статистики и математики и трудно сказать, действительно ли это наука. При этом это движение развивается в самых разных научных направлениях, иногда даже оформляясь в отдельную отрасль: биоинформатика вычислительная криминалистика цифровые гуманитарные исследования датажурналистика … Все больше книг “Data Scince for …”: psychologists (Hansjörg 2019) immunologists (Thomas and Pallett 2019) buisness (Provost and Fawcett 2013) public policy (Brooks and Cooper 2013) fraud detection (Baesens, Van Vlasselaer, and Verbeke 2015) … Среди умений датасаентистов можно перечислить следующие: сбор и обработка данных трансформация данных визуализация данных статистическое моделирование данных представление полученных результатов организация всей работы воспроизводимым способом Большинство этих тем в той или иной мере будет представлено в нашем курсе. 2.2 Установка R и RStudio В данной книге используется исключительно R (R Core Team 2019), так что для занятий понадобятся: R на Windows на Mac на Linux, также можно добавить зеркало и установить из командной строки: sudo apt-get install r-cran-base RStudio — IDE для R (можно скачать здесь) и некоторые пакеты на R Часто можно увидеть или услышать, что R — язык программирования для “статистической обработки данных”. Изначально это, конечно, было правдой, но уже давно R — это полноценный язык программирования, который при помощи своих пакетом позволяет решать огромный спектр задач. В данной книге используются следующая версия R: sessionInfo()$R.version$version.string ## [1] &quot;R version 3.6.1 (2019-07-05)&quot; Некоторые люди не любят устанавливать лишние программы себе на компьютер, несколько вариантов есть и для них: RStudio cloud — полная функциональность RStudio, пока бесплатная, но скоро это исправят; RStudio on rollApp — облачная среда, позволяющая разворачивать программы. Первый и вполне закономерный вопрос: зачем мы ставили R и отдельно еще какой-то RStudio? Если опустить незначительные детали, то R — это сам язык программирования, а RStudio — это среда (IDE), которая позволяет в этом языке очень удобно работать. 2.3 Полезные ссылки В интернете легко найти документацию и туториалы по самым разным вопросам в R, так что главный залог успеха — грамматно пользоваться поисковиком, и лучше на английском языке. книга (Wickham and Grolemund 2016) является достаточно сильной альтернативой всему курсу stackoverflow — сервис, где достаточно быстро отвечают на любые вопросы (не обязательно по R) RStudio community — быстро отвечают на вопросы, связанные с R русский stackoverflow R-bloggers — сайт, где собираются новинки, связанные с R чат, где можно спрашивать про R на русском (но почитайте правила чата, перед тем как спрашивать) чат по визуализации данных, чат датажурналистов канал про визуализацию, дата-блог “Новой газеты”, … 2.4 Rstudio Когда вы откроете RStudio первый раз, вы увидите три панели: консоль, окружение и историю, а также панель для всего остального. Если ткнуть в консоли на значок уменьшения, то можно открыть дополнительную панель, где можно писать скрипт. Существуют разные типы пользователей: одни любят работать в консоли (на картинке это 2 — R Console), другие предпочитают скрипты (1 — Code Editor). Консоль позволяет иметь интерактивный режим команда-ответ, а скрипт является по сути текстовым документом, фрагменты которого можно для отладки запускать в консоли. 3 — Workspace and History: Здесь можно увидеть переменные. Это поле будет автоматически обновляться по мере того, как Вы будете запускать строчки кода и создавать новые переменные. Еще там есть вкладка с историей последних команд, которые были запущены. 4 — Plots and files: Здесь есть очень много всего. Во-первых, небольшой файловый менеджер, во-вторых, там будут появляться графики, когда вы будете их рисовать. Там же есть вкладка с вашими пакетами (Packages) и Help по функциям. Но об этом потом. 2.5 Введение в R 2.5.1 R как калькулятор Ой-ей, консоль, скрипт че-то все непонятно. Давайте начнем с самого простого и попробуем использовать R как простой калькулятор. +, -, *, /, ^ (степень), () и т.д. Просто запускайте в консоли пока не надоест: 40+2 ## [1] 42 3-2 ## [1] 1 5*6 ## [1] 30 99/9 ## [1] 11 2^3 ## [1] 8 (2+2)*2 ## [1] 8 Ничего сложного, верно? Вводим выражение и получаем результат. Порядок выполнения арифметических операций как в математике, так что не забывайте про скобочки. Если Вы не уверены в том, какие операции имеют приоритет, то используйте скобочки, чтобы точно обозначить, в каком порядке нужно производить операции. 2.5.2 Функции Давайте теперь извлечем корень из какого-нибудь числа. В принципе, тем, кто помнит школьный курс математики, возведения в степень вполне достаточно: 16^0.5 ## [1] 4 Ну а если нет, то можете воспользоваться специальной функцией: это обычно какие-то буквенные символы с круглыми скобками сразу после названия функции. Мы подаем на вход (внутрь скобочек) какие-то данные, внутри этих функций происходят какие-то вычисления, которые выдает в ответ какие-то другие данные (или же функция записывает файл, рисует график и т.д.). Вот, например, функция для корня: sqrt(16) ## [1] 4 R — case-sensitive язык, т.е. регистр важен. SQRT(16) не будет работать. А вот так выглядит функция логарифма: log(8) ## [1] 2.079442 Так, вроде бы все нормально, но… Если Вы еще что-то помните из школьной математики, то должны понимать, что что-то здесь не так. Здесь не хватает основания логарифма! Логарифм — показатель степени, в которую надо возвести число, называемое основанием, чтобы получить данное число. То есть у логарифма 8 по основанию 2 будет значение 3: \\(\\log_2 8 = 3\\) То есть если возвести 2 в степень 3 у нас будет 8: \\(2^3 = 8\\) Только наша функция считает все как-то не так. Чтобы понять, что происходит, нам нужно залезть в хэлп этой функции: ?log Справа внизу в RStudio появится вот такое окно: Действительно, у этой функции есть еще аргумент base =. По дефолту он равен числу Эйлера (2.7182818…), т.е. функция считает натуральный логарифм. В большинстве функций R есть какой-то основной инпут — данные в том или ином формате, а есть и дополнительные параметры, которые можно прописывать вручную, если параметры по умолчанию нас не устраивают. log(x = 8, base = 2) ## [1] 3 …или просто (если Вы уверены в порядке аргументов): log(8,2) ## [1] 3 Более того, Вы можете использовать оутпут одних функций как инпут для других: log(8, sqrt(4)) ## [1] 3 Если эксплицитно писать имена аргументов, то их порядок в функции не важен: log(base = 2, x = 8) ## [1] 3 А еще можно недописывать имена аргументов, если они не совпадают с другими: log(b = 2, x = 8) ## [1] 3 Мы еще много раз будем возвращаться к функциям. Вообще, функции — это одна из важнейших штук в R (примерно так же как и в Python). Мы будем создавать свои функции, использовать функции как инпут для функций и многое-многое другое. В R очень крутые возможности работы с функциями. Поэтому подружитесь с функциями, они клевые. Арифметические знаки, которые мы использовали: +,-,/,^ и т.д. называются операторами и на самом деле тоже являются функциями: &#39;+&#39;(3,4) ## [1] 7 2.5.3 Переменные Важная штука в программировании на практически любом языке — возможность сохранять значения в переменных. В R это обычно делается с помощью вот этих символов: &lt;- (но можно использовать и обычное =, хотя это не очень принято). Для этого есть удобное сочетание клавиш: нажмите одновременно Alt - (или option - на Маке). a &lt;- 2 a ## [1] 2 После присвоения переменная появляется во вкладке Environment в RStudio: Можно использовать переменные в функциях и просто вычислениях: b &lt;- a^a+a*a b ## [1] 8 log(b,a) ## [1] 3 Вы можете сравнивать разные переменные: a == b ## [1] FALSE Заметьте, что сравнивая две переменные мы используем два знака равно ==, а не один =. Иначе это будет означать присвоение. a = b a ## [1] 8 Теперь Вы сможете понять комикс про восстание роботов на следующей странице (пусть он и совсем про другой язык программирования) Этот комикс объясняет, как важно не путать присваивание и сравнение (хотя я иногда путаю до сих пор =( ). Иногда нам нужно проверить на неравенство: a &lt;- 2 b &lt;- 3 a==b ## [1] FALSE a!=b ## [1] TRUE Восклицательный язык в программировании вообще и в R в частности стандартно означает отрицание. Еще мы можем сравнивать на больше/меньше: a&gt;b ## [1] FALSE a&lt;b ## [1] TRUE a&gt;=b ## [1] FALSE a&lt;=b ## [1] TRUE 2.6 Типы данных До этого момента мы работали только с числами (numeric): class(a) ## [1] &quot;numeric&quot; Вообще, в R много типов numeric: integer (целые), double (с десятичной дробью), complex (комплексные числа). Последние пишутся так: complexnumber &lt;- 2+2i Однако в R с этим обычно можно вообще не заморачиваться, R сам будет конвертить между форматами при необходимости. Немного подробностей здесь: Разница между numeric и integer, Как работать с комплексными числами в R Теперь же нам нужно ознакомиться с двумя другими важными типами данных в R: character: строки символов. Они должны выделяться кавычками. Можно использовать как \", так и ' (что удобно, когда строчка внутри уже содержит какие-то кавычки). s &lt;- &quot;Всем привет!&quot; s ## [1] &quot;Всем привет!&quot; class(s) ## [1] &quot;character&quot; logical: просто TRUE или FALSE. t1 &lt;- TRUE f1 &lt;- FALSE t1 ## [1] TRUE f1 ## [1] FALSE Вообще, можно еще писать T и F (но не True и False!) t2 &lt;- T f2 &lt;- F Это дурная практика, так как R защищает от перезаписи переменные TRUE и FALSE, но не защищает от этого T и F TRUE &lt;- FALSE ## Error in TRUE &lt;- FALSE: invalid (do_set) left-hand side to assignment TRUE ## [1] TRUE T &lt;- FALSE T ## [1] FALSE Теперь вы можете догадаться, что результаты сравнения, например, числовых или строковых переменных вы можете сохранять в переменные тоже! comparison &lt;- a == b comparison ## [1] FALSE Это нам очень понадобится, когда мы будем работать с реальными данными: нам нужно будет постоянно вытаскивать какие-то данные из датасета, а это как раз и построено на игре со сравнением переменных. Чтобы этим хорошо уметь пользоваться, нам нужно еще освоить как работать с логическими операторами. Про один мы немного уже говорили — это не (!): t1 ## [1] TRUE !t1 ## [1] FALSE !!t1 #Двойное отрицание! ## [1] TRUE Еще есть И (выдаст TRUE только в том случае если обе переменные TRUE): t1&amp;t2 ## [1] TRUE t1&amp;f1 ## [1] FALSE А еще ИЛИ (выдаст TRUE в случае если хотя бы одна из переменных TRUE): t1 | f1 ## [1] TRUE f1 | f2 ## [1] FALSE Если кому-то вдруг понадобиться другое ИЛИ — есть функция xor(), принимающий два аргумента. Поздравляю, мы только что разобрались с самой занудной частью. Пора переходить к важному и интересному. ВЕКТОРАМ! 2.7 Вектор Если у вас не было линейной алгебры (или у вас с ней было все плохо), то просто запомните, что вектор (или atomic vector или atomic) — это набор (столбик) чисел в определенном порядке. P.S. Если вы привыкли из школьного курса физики считать вектора стрелочками, то не спешите возмущаться и паниковать. Представьте стрелочки как точки из нуля координат {0,0} до какой-то точки на координатной плоскости, например, {2,1}. Вот последние два числа и будем считать вектором. Поэтому постарайтесь на время выбросить стрелочки из головы. На самом деле, мы уже работали с векторами в R, но, возможно, Вы об этом даже не догадывались. Дело в том, что в R нет как таковых “значений”, есть вектора длиной 1. Такие дела! Чтобы создать вектор из нескольких значений, нужно воспользоваться функцией c(): c(4,8,15,16,23,42) ## [1] 4 8 15 16 23 42 c(&quot;Хэй&quot;, &quot;Хэй&quot;, &quot;Ха&quot;) ## [1] &quot;Хэй&quot; &quot;Хэй&quot; &quot;Ха&quot; Одна из самых мерзких и раздражающих причин ошибок в коде — это использование с из кириллицы вместо c из латиницы. Видите разницу? И я не вижу. А R видит. И об этом сообщает: с(3, 4, 5) ## Error in с(3, 4, 5): could not find function &quot;с&quot; Для создания числовых векторов есть удобный оператор : 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 5:-3 ## [1] 5 4 3 2 1 0 -1 -2 -3 Этот оператор создает вектор от первого числа до второго с шагом 1. Вы не представляете, как часто эта штука нам пригодится… Если же нужно сделать вектор с другим шагом, то есть функция seq(): seq(10,100, by = 10) ## [1] 10 20 30 40 50 60 70 80 90 100 Кроме того, можно задавать не шаг, а длину вектора. Тогда шаг функция seq() посчитает сама: seq(1,13, length.out = 4) ## [1] 1 5 9 13 Другая функция — rep() — позволяет создавать вектора с повторяющимися значениями. Первый аргумент — значение, которое нужно повторять, а второй аргумент — сколько раз повторять. rep(1, 5) ## [1] 1 1 1 1 1 И первый, и второй аргумент могут быть векторами! rep(1:3, 3) ## [1] 1 2 3 1 2 3 1 2 3 rep(1:3, 1:3) ## [1] 1 2 2 3 3 3 Еще можно объединять вектора (что мы, по сути, и делали, просто с векторами длиной 1): v1 &lt;- c(&quot;Hey&quot;, &quot;Ho&quot;) v2 &lt;- c(&quot;Let&#39;s&quot;, &quot;Go!&quot;) c(v1,v2) ## [1] &quot;Hey&quot; &quot;Ho&quot; &quot;Let&#39;s&quot; &quot;Go!&quot; 2.7.1 Coercion Что будет, если вы объедините два вектора с значениями разных типов? Ошибка? Мы уже обсуждали, что в atomic может быть только один тип данных. В некоторых языках программирования при операции с данными разных типов мы бы получили ошибку. А вот в R при несовпадении типов пройзойдет попытка привести типы к “общему знаменателю”, то есть конвертировать данные в более “широкий” тип. Например: c(FALSE, 2) ## [1] 0 2 FALSE превратился в 0 (а TRUE превратился бы в 1), чтобы можно было оба значения объединить в вектор. То же самое произошло бы в случае операций с векторами: 2 + TRUE ## [1] 3 Это называется coercion. Более сложный пример: c(TRUE, 3, &quot;Привет&quot;) ## [1] &quot;TRUE&quot; &quot;3&quot; &quot;Привет&quot; У R есть иерархия коэрсинга: NULL &lt; raw &lt; logical &lt; integer &lt; double &lt; complex &lt; character &lt; list &lt; expression. Мы из этого списка еще многого не знаем, сейчас важно запомнить, что логические данные — TRUE и FALSE — превращаются в 0 и 1 соответственно, а 0 и 1 в строчки \"0\" и \"1\". Если Вы боитесь полагаться на coercion, то можете воспользоваться функциями as.нужныйтипданных: as.numeric(c(TRUE, FALSE, FALSE)) ## [1] 1 0 0 as.character(as.numeric(c(TRUE, FALSE, FALSE))) ## [1] &quot;1&quot; &quot;0&quot; &quot;0&quot; Можно превращать и обратно, например, строковые значения в числовые. Если среди числа встретится буква или другой неподходящий знак, то мы получим предупреждение NA — пропущенное значение (мы очень скоро научимся с ними работать). as.numeric(c(&quot;1&quot;, &quot;2&quot;, &quot;три&quot;)) ## Warning: NAs introduced by coercion ## [1] 1 2 NA 2.7.2 Операции с векторами Все те арифметические операции, что мы использовали ранее, можно использовать с векторами одинаковой длины: n &lt;- 1:4 m &lt;- 4:1 n + m ## [1] 5 5 5 5 n - m ## [1] -3 -1 1 3 n * m ## [1] 4 6 6 4 n / m ## [1] 0.2500000 0.6666667 1.5000000 4.0000000 n ^ m + m * (n - m) ## [1] -11 5 11 7 Если после какого-нибудь MATLAB Вы привыкли, что по умолчанию операторы работают по правилам линейной алгебры и m*n будет давать скалярное произведение (dot product), то снова нет. Для скалярного произведения нужно использовать операторы с % по краям: n %*% m ## [,1] ## [1,] 20 Абсолютно так же и с операциями с матрицами в R, хотя про матрицы будет немного позже. В принципе, большинство функций в R, которые работают с отдельными значениями, так же хорошо работают и с целыми векторами. Скажем, Вы хотите извлечь корень из нескольких чисел, для этого не нужны никакие циклы (как это обычно делается в других языках программирования). Можно просто “скормить” вектор функции и получить результат применения функции к каждому элементу вектора: sqrt(1:10) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 ## [9] 3.000000 3.162278 2.7.3 Recycling Допустим мы хотим совершить какую-нибудь операцию с двумя векторами. Как мы убедились, с этим обычно нет никаких проблем, если они совпадают по длине. А что если вектора не совпадают по длине? Ничего страшного! Здесь будет работать правило ресайклинга (recycling = правило переписывания). Это означает, что если короткий вектор кратен по длине длинному, то он будет повторять короткий необходимое количество раз: n &lt;- 1:4 m &lt;- 1:2 n * m ## [1] 1 4 3 8 А что будет, если совершать операции с вектором и отдельным значением? Можно считать это частным случаем ресайклинга: короткий вектор длиной 1 будет повторятся столько раз, сколько нужно, чтобы он совпадал по длине с длинным: n * 2 ## [1] 2 4 6 8 Если же меньший вектор не кратен большему (например, один из них длиной 3, а другой длиной 4), то R посчитает результат, но выдаст предупреждение. n + c(3,4,5) ## Warning in n + c(3, 4, 5): longer object length is not a multiple of shorter ## object length ## [1] 4 6 8 7 Проблема в том, что эти предупреждения могут в неожиданный момент стать причиной ошибок. Поэтому не стоит полагаться на ресайклинг некратных по длине векторов. См. здесь. А вот ресайклинг кратных по длине векторов — это очень удобная штука, которая используется очень часто. 2.7.4 Индексирование векторов Итак, мы подошли к одному из самых сложных моментов. И одному из основных. От того, как хорошо вы научись с этим работать, зависит весь Ваш дальнейший успех на R-поприще! Речь пойдет об индексировании векторов. Задача, которую Вам придется решать каждые пять минут работы в R - как выбрать из вектора (или же списка, матрицы и датафрейма) какую-то его часть. Для этого используются квадратные скобочки [] (не круглые - они для функций!). Самое простое - индексировать по номеру индекса, т.е. порядку значения в векторе. n &lt;- 1:10 n[1] ## [1] 1 n[10] ## [1] 10 Если вы знакомы с другими языками программирования (не MATLAB, там все так же) и уже научились думать, что индексация с 0 — это очень удобно и очень правильно (ну или просто свыклись с этим), то в R Вам придется переучиться обратно. Здесь первый индекс — это 1, а последний равен длине вектора — ее можно узнать с помощью функции length(). С обоих сторон индексы берутся включительно. С помощью индексирования можно не только вытаскивать имеющиеся значения в векторе, но и присваивать им новые: n[3] &lt;- 20 n ## [1] 1 2 20 4 5 6 7 8 9 10 Конечно, можно использовать целые векторы для индексирования: n[4:7] ## [1] 4 5 6 7 n[10:1] ## [1] 10 9 8 7 6 5 4 20 2 1 Индексирование с минусом выдаст вам все значения вектора кроме выбранных (простите, пользователя Python, которые ожидают здесь отсчет с конца…): n[-1] ## [1] 2 20 4 5 6 7 8 9 10 n[c(-4, -5)] ## [1] 1 2 20 6 7 8 9 10 Более того, можно использовать логический вектор для индексирования. В этом случае нужен логический вектор такой же длины: n[c(TRUE,FALSE,TRUE,FALSE,TRUE,FALSE,TRUE,FALSE,TRUE,FALSE)] ## [1] 1 20 5 7 9 Ну а если они не равны, то тут будет снова работать правило ресайклинга! n[c(TRUE,FALSE)] #то же самое - recycling rule! ## [1] 1 20 5 7 9 Есть еще один способ индексирования векторов, но он несколько более редкий: индексирование по имени. Дело в том, что для значений векторов можно (но не обязательно) присваивать имена: my_named_vector &lt;- c(first = 1, second = 2, third = 3) my_named_vector[&#39;first&#39;] ## first ## 1 А еще можно “вытаскивать” имена из вектора с помощью функции names() и присваивать таким образом новые. d &lt;- 1:4 names(d) &lt;- letters[1:4] d[&quot;a&quot;] ## a ## 1 letters - это “зашитая” в R константа - вектор букв от a до z. Иногда это очень удобно! Кроме того, есть константа LETTERS - то же самое, но заглавными буквами. А еще есть названия месяцев на английском и числовая константа pi. Теперь посчитаем среднее вектора n: mean(n) ## [1] 7.2 А как вытащить все значения, которые больше среднего? Сначала получим логический вектор — какие значения больше среднего: larger &lt;- n &gt; mean(n) larger ## [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE TRUE TRUE TRUE А теперь используем его для индексирования вектора n: n[larger] ## [1] 20 8 9 10 Можно все это сделать в одну строчку: n[n&gt;mean(n)] ## [1] 20 8 9 10 Предыдущая строчка отражает то, что мы будем постоянно делать в R: вычленять (subset) из данных отдельные куски на основании разных условий. 2.7.5 NA — пропущенные значения В реальных данных у нас часто чего-то не хватает. Например, из-за технической ошибки или невнимательности не получилось записать какое-то измерение. Для этого в R есть NA. NA — это не строка \"NA\", не 0, не пустая строка \"\" и не FALSE. NA — это NA. Большинство операций с векторами, содержащими NA будут выдавать NA: missed &lt;- NA missed == &quot;NA&quot; ## [1] NA missed == &quot;&quot; ## [1] NA missed == NA ## [1] NA Заметьте: даже сравнение NA c NA выдает NA! Иногда NA в данных очень бесит: n[5] &lt;- NA n ## [1] 1 2 20 4 NA 6 7 8 9 10 mean(n) ## [1] NA Что же делать? Наверное, надо сравнить вектор с NA и исключить этих пакостников. Давайте попробуем: n == NA ## [1] NA NA NA NA NA NA NA NA NA NA Ах да, мы ведь только что узнали, что даже сравнение NA c NA приводит к NA. Чтобы выбраться из этой непростой ситуации, используйте функцию is.na(): is.na(n) ## [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE Результат выполнения is.na(n) выдает FALSE в тех местах, где у нас числа и TRUE там, где у нас NA. Нам нужно сделать наоборот. Здесь нам понадобится оператор ! (мы его уже встречали), который инвертирует логические значения: n[!is.na(n)] ## [1] 1 2 20 4 6 7 8 9 10 Ура, мы можем считать среднее! mean(n[!is.na(n)]) ## [1] 7.444444 Теперь Вы понимаете, зачем нужно отрицание (!) Вообще, есть еще один из способов посчитать среднее, если есть NA. Для этого надо залезть в хэлп по функции mean(): ?mean() В хэлпе мы найдем параметр na.rm =, который по дефолту FALSE. Вы знаете, что нужно делать! mean(n, na.rm = TRUE) ## [1] 7.444444 Еееее! NA может появляться в векторах других типов тоже. Кроме NA есть еще NaN — это разные вещи. NaN расшифровывается как Not a Number и получается в результате таких операций как 0/0. 2.7.6 В любой непонятной ситуации — ищите в поисковике Если вдруг вы не знаете, что искать в хэлпе, или хэлпа попросту недостаточно, то… ищите в поисковике! Нет ничего постыдного в том, чтобы искать в Интернете решения проблем. Это абсолютно нормально. Используйте силу интернета во благо и да помогут Вам Stackoverflow и бесчисленные R-туториалы! Computer Programming To Be Officially Renamed “Googling Stack Overflow”Source: http://t.co/xu7acfXvFF pic.twitter.com/iJ9k7aAVhd — Stack Exchange July 20, 2015 Главное, помните: загуглить работающий ответ всегда недостаточно. Надо понять, как и почему он работает. Иначе что-то обязательно пойдет не так. Кроме того, правильно загуглить проблему — не так уж и просто. Does anyone ever get good at R or do they just get good at googling how to do things in R — 🔬🖤Lauren M. Seyler, Ph.D.❤️⚒ href=“https://twitter.com/mousquemere/status/1125522375141883907?ref_src=twsrc%5Etfw”&gt;May 6, 2019 Итак, с векторами мы более-менее разобрались. Помните, что вектора — это один из краеугольных камней Вашей работы в R. Если Вы хорошо с ними разобрались, то дальше все будет довольно несложно. Тем не менее, вектора — это не все. Есть еще два важных типа данных: списки (list) и матрицы (matrix). Их можно рассматривать как своеобразное “расширение” векторов, каждый в свою сторону. Ну а списки и матрицы нужны чтобы понять основной тип данных в R — data.frame. 2.8 Матрицы (matrix) Если вдруг Вас пугает это слово, то совершенно зря. Матрица — это всего лишь “двумерный” вектор: вектор, у которого есть не только длина, но и ширина. Создать матрицу можно с помощью функции matrix() из вектора, указав при этом количество строк и столбцов. A &lt;- matrix(1:20, nrow=5,ncol=4) A ## [,1] [,2] [,3] [,4] ## [1,] 1 6 11 16 ## [2,] 2 7 12 17 ## [3,] 3 8 13 18 ## [4,] 4 9 14 19 ## [5,] 5 10 15 20 Если мы знаем сколько значений в матрице и сколько мы хотим строк, то количество столбцов указывать необязательно: A &lt;- matrix(1:20, nrow=5) A ## [,1] [,2] [,3] [,4] ## [1,] 1 6 11 16 ## [2,] 2 7 12 17 ## [3,] 3 8 13 18 ## [4,] 4 9 14 19 ## [5,] 5 10 15 20 Все остальное так же как и с векторами: внутри находится данные только одного типа. Поскольку матрица — это уже двумерный массив, то у него имеется два индекса. Эти два индекса разделяются запятыми. A[2,3] ## [1] 12 A[2:4, 1:3] ## [,1] [,2] [,3] ## [1,] 2 7 12 ## [2,] 3 8 13 ## [3,] 4 9 14 Первый индекс — выбор строк, второй индекс — выбор колонок. Если же мы оставляем пустое поле вместо числа, то мы выбираем все строки/колонки в зависимости от того, оставили мы поле пустым до или после запятой: A[,1:3] ## [,1] [,2] [,3] ## [1,] 1 6 11 ## [2,] 2 7 12 ## [3,] 3 8 13 ## [4,] 4 9 14 ## [5,] 5 10 15 A[2:4,] ## [,1] [,2] [,3] [,4] ## [1,] 2 7 12 17 ## [2,] 3 8 13 18 ## [3,] 4 9 14 19 A[,] ## [,1] [,2] [,3] [,4] ## [1,] 1 6 11 16 ## [2,] 2 7 12 17 ## [3,] 3 8 13 18 ## [4,] 4 9 14 19 ## [5,] 5 10 15 20 В принципе, это все, что нам нужно знать о матрицах. Матрицы используются в R довольно редко, особенно по сравнению, например, с MATLAB. Но вот индексировать матрицы хорошо бы уметь: это понадобится в работе с датафреймами. То, что матрица - это просто двумерный вектор, не является метафорой: в R матрица - это по сути своей вектор с дополнительными атрибутами dim и dimnames. Атрибуты — это неотъемлемые свойства объектов, для всех объектов есть обязательные атрибуты типа и длины и могут быть любые необязательные атрибуты. Можно задавать свои атрибуты или удалять уже присвоенные: удаление атрибута dim у матрицы превратит ее в обычный вектор. Про атрибуты подробнее можно почитать здесь или на стр. 99–101 книги “R in a Nutshell” (Adler 2010). 2.9 Списки (list) Теперь представим себе вектор без ограничения на одинаковые данные внутри. И получим список! l &lt;- list(42, &quot;Пам пам&quot;, TRUE) l ## [[1]] ## [1] 42 ## ## [[2]] ## [1] &quot;Пам пам&quot; ## ## [[3]] ## [1] TRUE А это значит, что там могут содержаться самые разные данные, в том числе и другие списки и векторы! lbig &lt;- list(c(&quot;Wow&quot;, &quot;this&quot;, &quot;list&quot;, &quot;is&quot;, &quot;so&quot;, &quot;big&quot;), &quot;16&quot;, l) lbig ## [[1]] ## [1] &quot;Wow&quot; &quot;this&quot; &quot;list&quot; &quot;is&quot; &quot;so&quot; &quot;big&quot; ## ## [[2]] ## [1] &quot;16&quot; ## ## [[3]] ## [[3]][[1]] ## [1] 42 ## ## [[3]][[2]] ## [1] &quot;Пам пам&quot; ## ## [[3]][[3]] ## [1] TRUE Если у нас сложный список, то есть очень классная функция, чтобы посмотреть, как он устроен, под названием str(): str(lbig) ## List of 3 ## $ : chr [1:6] &quot;Wow&quot; &quot;this&quot; &quot;list&quot; &quot;is&quot; ... ## $ : chr &quot;16&quot; ## $ :List of 3 ## ..$ : num 42 ## ..$ : chr &quot;Пам пам&quot; ## ..$ : logi TRUE Как и в случае с векторами мы можем давать имена элементам списка: namedl &lt;- list(age = 24, PhDstudent = T, language = &quot;Russian&quot;) namedl ## $age ## [1] 24 ## ## $PhDstudent ## [1] FALSE ## ## $language ## [1] &quot;Russian&quot; К списку можно обращаться как с помощью индексов, так и по именам. Начнем с последнего: namedl$age ## [1] 24 А вот с индексами сложнее, и в этом очень легко запутаться. Давайте попробуем сделать так, как мы делали это раньше: namedl[1] ## $age ## [1] 24 Мы, по сути, получили элемент списка - просто как часть списка, т.е. как список длиной один: class(namedl) ## [1] &quot;list&quot; class(namedl[1]) ## [1] &quot;list&quot; А вот чтобы добраться до самого элемента списка (и сделать с ним что-то хорошее) нам нужна не одна, а две квадратных скобочки: namedl[[1]] ## [1] 24 class(namedl[[1]]) ## [1] &quot;numeric&quot; Indexing lists in #rstats. Inspired by the Residence Inn pic.twitter.com/YQ6axb2w7t — Hadley Wickham (@ href=“https://twitter.com/hadleywickham/status/643381054758363136?ref_src=twsrc%5Etfw”&gt;September 14, 2015 Как и в случае с вектором, к элементу списка можно обращаться по имени. namedl[[&#39;age&#39;]] ## [1] 24 Хотя последнее — практически то же самое, что и использование знака $. Списки довольно часто используются в R, но реже, чем в Python. Со многими объектами в R, такими как результаты статистических тестов, объекты ggplot и т.д. удобно работать именно как со списками — к ним все вышеописанное применимо. Кроме того, некоторые данные мы изначально получаем в виде древообразной структуры — хочешь не хочешь, а придется работать с этим как со списком. Но обычно после этого стоит как можно скорее превратить список в датафрейм. 2.10 Data.frame Итак, мы перешли к самому главному. Самому-самому. Датафреймы (data.frames). Более того, сейчас станет понятно, зачем нам нужно было разбираться со всеми предыдущими темами. Без векторов мы не смогли бы разобраться с матрицами и списками. А без последних мы не сможем понять, что такое датафрейм. name &lt;- c(&quot;Ivan&quot;, &quot;Eugeny&quot;, &quot;Lena&quot;, &quot;Misha&quot;, &quot;Sasha&quot;) age &lt;- c(26, 34, 23, 27, 26) student &lt;- c(FALSE, FALSE, TRUE, TRUE, TRUE) df = data.frame(name, age, student) df ## name age student ## 1 Ivan 26 FALSE ## 2 Eugeny 34 FALSE ## 3 Lena 23 TRUE ## 4 Misha 27 TRUE ## 5 Sasha 26 TRUE str(df) ## &#39;data.frame&#39;: 5 obs. of 3 variables: ## $ name : Factor w/ 5 levels &quot;Eugeny&quot;,&quot;Ivan&quot;,..: 2 1 3 4 5 ## $ age : num 26 34 23 27 26 ## $ student: logi FALSE FALSE TRUE TRUE TRUE Вообще, очень похоже на список, не правда ли? Так и есть, датафрейм — это что-то вроде проименованного списка, каждый элемент которого является atomic вектором фиксированной длины. Скорее всего, список Вы представляли “горизонтально”. Если это так, то теперь “переверните” его у себя в голове. Так, чтоб названия векторов оказались сверху, а колонки стали столбцами. Поскольку длина всех этих векторов равна (обязательное условие!), то данные представляют собой табличку, похожую на матрицу. Но в отличие от матрицы, разные столбцы могут имет разные типы данных: первая колонка — character, вторая колонка — numeric, третья колонка — logical. Тем не менее, обращаться с датафреймом можно и как с проименованным списком, и как с матрицей: df$age[2:3] ## [1] 34 23 Здесь мы сначала вытащили колонку age с помощью оператора $. Результатом этой операции является числовой вектор, из которого мы вытащили кусок, выбрав индексы 2 и 3. Используя оператор $ и присваивание можно создавать новые колонки датафрейма: df$lovesR &lt;- TRUE #правило recycling - узнали? df ## name age student lovesR ## 1 Ivan 26 FALSE TRUE ## 2 Eugeny 34 FALSE TRUE ## 3 Lena 23 TRUE TRUE ## 4 Misha 27 TRUE TRUE ## 5 Sasha 26 TRUE TRUE Ну а можно просто обращаться с помощью двух индексов через запятую, как мы это делали с матрицей: df[3:5, 2:3] ## age student ## 3 23 TRUE ## 4 27 TRUE ## 5 26 TRUE Как и с матрицами, первый индекс означает строчки, а второй — столбцы. А еще можно использовать названия колонок внутри квадратных скобок: df[1:2,&quot;age&quot;] ## [1] 26 34 И здесь перед нами открываются невообразимые возможности! Узнаем, любят ли R те, кто моложе среднего возраста в группе: df[df$age &lt; mean(df$age), 4] ## [1] TRUE TRUE TRUE TRUE Эту же задачу можно выполнить другими способами: df$lovesR[df$age &lt; mean(df$age)] ## [1] TRUE TRUE TRUE TRUE df[df$age &lt; mean(df$age), &#39;lovesR&#39;] ## [1] TRUE TRUE TRUE TRUE В большинстве случаев подходят сразу несколько способов — тем не менее, стоит овладеть ими всеми. Датафреймы удобно просматривать в RStudio. Для это нужно написать команду View(df) или же просто нажать на названии нужной переменной из списка вверху справа (там где Environment). Тогда увидите табличку, очень похожую на Excel и тому подобные программы для работы с таблицами. Там же есть и всякие возможности для фильтрации, сортировки и поиска… Но, конечно, интереснее все эти вещи делать руками, т.е. с помощью написания кода. На этом пора заканчивать с введением и приступать к реальным данным. 2.11 Начинаем работу с реальными данными Итак, пришло время перейти к реальным данным. Мы начнем с использования датасета (так мы будем называть любой набор данных) по Игре Престолов, а точнее, по книгам цикла “Песнь льда и пламени” Дж. Мартина. Да, будут спойлеры, но сериал уже давно закончился и сильно разошелся с книгами… 2.11.1 Рабочая папка и проекты Для начала скачайте файл по ссылке Он, скорее всего, появился у Вас в папке “Загрузки”. Если мы будем просто пытаться прочитать этот файл (например, с помощью read.csv() — мы к этой функцией очень скоро перейдем), указав его имя и разрешение, то наткнемся на такую ошибку: Ошибка в file(file, “rt”) :не могу открыть соединение Вдобавок: Предупреждение: В file(file, “rt”) : не могу открыть файл ‘character-deaths.csv’: No such file or directory Это означает, что R не может найти нужный файл. Вообще-то мы даже не сказали, где искать. Нам нужно как-то совместить место, где R ищет загружаемые файлы и сами файлы. Для этого есть несколько способов. Магомет идет к горе: перемещение файлов в рабочую папку. Для этого нужно узнать, какая папка является рабочей с помощью функции getwd() (без аргументов), найти эту папку в проводнике и переместить туда файл. После этого можно использовать просто название файла с разрешением: got &lt;- read.csv(&quot;character-deaths.csv&quot;) Гора идет к Магомету: изменение рабочей папки. Можно просто сменить рабочую папку с помощью setwd() на ту, где сейчас лежит файл, прописав путь до этой папки. Теперь файл находится в рабочей папке: got &lt;- read.csv(&quot;character-deaths.csv&quot;) Этот вариант использовать не рекомендуется. Как минимум, это сразу делает невозможным запустить скрипт на другом компьютере. Гора находит Магомета по месту прописки: указание полного пути файла. got &lt;- read.csv(&quot;/Users/Username/Some_Folder/character-deaths.csv&quot;) Этот вариант страдает теми же проблемами, что и предыдущий, поэтому тоже не рекомендуется. Для пользователей Windows есть дополнительная сложность: знак / является особым знаком для R, поэтому вместо него нужно использовать двойной //. Магомет использует кнопочный интерфейс: Import Dataset. Во вкладке Environment справа в окне RStudio есть кнопка “Import Dataset”. Возможно, у Вас возникло непреодолимое желание отдохнуть от написания кода и понажимать кнопочки — сопротивляйтесь этому всеми силами, но не вините себя, если не сдержитесь. Гора находит Магомета в интернете. Многие функции в R, предназначенные для чтения файлов, могут прочитать файл не только на Вашем компьютере, но и сразу из интернета. Для этого просто используйте ссылку вместо пути: got &lt;- read.csv(&quot;https://raw.githubusercontent.com/Pozdniakov/stats/master/data/character-deaths.csv&quot;) Каждый Магомет получает по своей горе: использование проектов в RStudio. На первый взгляд это кажется чем-то очень сложным, но это не так. Это очень просто и ОЧЕНЬ удобно. При создании проекта создается отдельная папочка, где у Вас лежат данные, хранятся скрипты, вспомогательные файлы и отчеты. Если нужно вернуться к другому проекту — просто открываете другой проект, с другими файлами и скриптами. Это еще помогает не пересекаться переменным из разных проектов — а то, знаете, использование двух переменных data в разных скриптах чревато ошибками. Поэтому очень удобным решением будет выделение отдельного проекта под этот курс. 2.11.2 Импорт данных Как Вы уже поняли, импортирование данных - одна из самых муторных и неприятных вещей в R. Если у Вас получится с этим справится, то все остальное - ерунда. Мы уже разобрались с первой частью этого процесса - нахождением файла с данными, осталось научиться их читать. Здесь стоит сделать небольшую ремарку. Довольно часто данные представляют собой табличку. Или же их можно свести к табличке. Такая табличка, как мы уже выяснили, удобно репрезентируется в виде датафрейма. Но как эти данные хранятся на компьютере? Есть два варианта: в бинарном и в текстовом файле. Текстовый файл означает, что такой файл можно открыть в программе “Блокнот” или ее аналоге и увидеть напечатанный текст: скрипт, роман или упорядоченный набор цифр и букв. Нас сейчас интересует именно последний случай. Таблица может быть представлена как текст: отдельные строчки в файле будут разделять разные строчки таблицы, а какой-нибудь знак-разделитель отделет колонки друг от друга. Для чтения данных из текстового файла есть довольно удобная функция read.table(). Почитайте хэлп по ней и ужаснитесь: столько разных параметров на входе! Но там же вы увидете функции read.csv(), read.csv2() и некоторые другие — по сути, это тот же read.table(), но с другими дефолтными параметрами, соответствующие формату файла, который мы загружаем. В данном случае используется формат .csv, что означает Comma Separated Values (Значения, Разделенные Запятыми). Это просто текстовый файл, в котором “закодирована” таблица: разные строчки разделяют разные строчки таблицы, а столбцы отделяются запятыми. С этим связана одна проблема: в некоторых странах (в т.ч. и России) принято использовать запятую для разделения дробной части числа, а не точку, как это делается в большинстве стран мира. Поэтому есть “другой” формат .csv, где значения разделены точкой с запятой (;), а дробные значения - запятой (,). В этом и различие функций read.csv() и read.csv2() — первая функция предназначена для “международного” формата, вторая - для (условно) “Российского”. В первой строчке обычно содержатся названия столбцов - и это чертовски удобно, функции read.csv() и read.csv2() по дефолту считают первую строчку именно как название для колонок. Итак, прочитаем наш файл. Для этого используем только параметр file =, который идет первым, и для параметра stringsAsFactors = поставим значение FALSE: got &lt;- read.csv(&quot;data/character-deaths.csv&quot;, stringsAsFactors = FALSE) По сути, факторы - это примерно то же самое, что и character, но закодированные числами. Когда-то это было придумано для экономии используемых времени и памяти, сейчас же обычно становится просто лишней морокой. Но некоторые функции требуют именно character, некоторые factor, в большинстве случаев это без разницы. Но иногда непонимание может привести к дурацким ошибкам. В данном случае мы просто пока обойдемся без факторов. Можете проверить с помощью View(got): все работает! Если же вылезает какая-то странная ерунда или же просто ошибка - попробуйте другие функции и покопаться с параметрами. Для этого читайте Help. Кроме .csv формата есть и другие варианты хранения таблиц в виде текста. Например, .tsv - тоже самое, что и .csv, но разделитель - знак табуляции. Для чтения таких файлов есть функция read.delim() и read.delim2(). Впрочем, даже если бы ее и не было, можно было бы просто подобрать нужные параметры для функции read.table(). Есть даже функции, которые пытаются сами “угадать” нужные параметры для чтения — часто они справляются с этим довольно удачно. Но не всегда. Поэтому стоит научиться справляться с любого рода данными на входе. Тем не менее, далеко не всегда таблицы представлены в виде текстового файла. Самый распространенный пример таблицы в бинарном виде — родные форматы Microsoft Excel. Если Вы попробуете открыть .xlsx файл в Блокноте, то увидите кракозябры. Это делает работу с этим файлами гораздо менее удобной, поэтому стоит избегать экселевских форматов и стараться все сохранять в .csv. Для работы с экселевскими файлами есть много пакетов: readxl, xlsx, openxlsx. Для чтения файлов SPSS, Stata, SAS есть пакет foreign. Что такое пакеты и как их устанавливать мы изучим позже. 2.12 Препроцессинг данных в R Вчера мы узнали про основы языка R, про то, как работать с векторами, списками, матрицами и, наконец, датафреймами. Мы закончили день на загрузке данных, с чего мы и начнем сегодня: got &lt;- read.csv(&quot;data/character-deaths.csv&quot;, stringsAsFactors = F) После загрузки данных стоит немного “осмотреть” получившийся датафрейм got. 2.12.1 Исследование данных Ок, давайте немного поизучаем датасет. Обычно мы привыкли глазами пробегать по данным, листая строки и столбцы — и это вполне правильно и логично, от этого не нужно отучаться. Но мы можем дополнить наш базовый зрительнопоисковой инструментарий несколькими полезными командами. Во-первых, вспомним другую полезную функцию str(): str(got) ## &#39;data.frame&#39;: 917 obs. of 13 variables: ## $ Name : chr &quot;Addam Marbrand&quot; &quot;Aegon Frey (Jinglebell)&quot; &quot;Aegon Targaryen&quot; &quot;Adrack Humble&quot; ... ## $ Allegiances : chr &quot;Lannister&quot; &quot;None&quot; &quot;House Targaryen&quot; &quot;House Greyjoy&quot; ... ## $ Death.Year : int NA 299 NA 300 NA NA 300 300 NA NA ... ## $ Book.of.Death : int NA 3 NA 5 NA NA 4 5 NA NA ... ## $ Death.Chapter : int NA 51 NA 20 NA NA 35 NA NA NA ... ## $ Book.Intro.Chapter: int 56 49 5 20 NA NA 21 59 11 0 ... ## $ Gender : int 1 1 1 1 1 1 1 0 1 1 ... ## $ Nobility : int 1 1 1 1 1 1 1 1 1 0 ... ## $ GoT : int 1 0 0 0 0 0 1 1 0 0 ... ## $ CoK : int 1 0 0 0 0 1 0 1 1 0 ... ## $ SoS : int 1 1 0 0 1 1 1 1 0 1 ... ## $ FfC : int 1 0 0 0 0 0 1 0 1 0 ... ## $ DwD : int 0 0 1 1 0 0 0 1 0 0 ... Давайте разберемся с переменными в датафрейме: Колонка Name — здесь все понятно. Важно, что эти имена записаны абсолютно по-разному: где-то с фамилией, где-то без, где-то в скобочках есть пояснения. Колонка Allegiances — к какому дому принадлежит персонаж. С этим сложно, иногда они меняют дома, здесь путаются сами семьи и персонажи, лояльные им. Особой разницы между Stark и House Stark нет. Следующие колонки - Death Year, Book.of.Death, Death.Chapter, Book.Intro.Chapter — означают номер главы, в которой персонаж впервые появляется, а так же номер книги, глава и год (от завоевания Вестероса Эйгоном Таргариеном), в которой персонаж умирает. Gender — 1 для мужчин, 0 для женщин. Nobility — дворянское происхождение персонажа. Последние 5 столбцов содержат информацию, появлялся ли персонаж в книге (всего книг пока что 5). Другая полезная функция для больших таблиц — функция head(): она выведет первые несколько (по дефолту 6) строчек датафрейма. head(got) ## Name Allegiances Death.Year Book.of.Death ## 1 Addam Marbrand Lannister NA NA ## 2 Aegon Frey (Jinglebell) None 299 3 ## 3 Aegon Targaryen House Targaryen NA NA ## 4 Adrack Humble House Greyjoy 300 5 ## 5 Aemon Costayne Lannister NA NA ## 6 Aemon Estermont Baratheon NA NA ## Death.Chapter Book.Intro.Chapter Gender Nobility GoT CoK SoS FfC DwD ## 1 NA 56 1 1 1 1 1 1 0 ## 2 51 49 1 1 0 0 1 0 0 ## 3 NA 5 1 1 0 0 0 0 1 ## 4 20 20 1 1 0 0 0 0 1 ## 5 NA NA 1 1 0 0 1 0 0 ## 6 NA NA 1 1 0 1 1 0 0 Есть еще функция tail(). Догадайтесь сами, что она делает. Для некоторых переменных полезно посмотреть таблицы частотности с помощью функции table(): table(got$Allegiances) ## ## Arryn Baratheon Greyjoy House Arryn House Baratheon ## 23 56 51 7 8 ## House Greyjoy House Lannister House Martell House Stark House Targaryen ## 24 21 12 35 19 ## House Tully House Tyrell Lannister Martell Night&#39;s Watch ## 8 11 81 25 116 ## None Stark Targaryen Tully Tyrell ## 253 73 17 22 15 ## Wildling ## 40 Уау! Очень просто и удобно, не так ли? Функция table() может принимать сразу несколько столбцов. Это удобно для получения таблиц сопряженности: table(got$Allegiances, got$Gender) ## ## 0 1 ## Arryn 3 20 ## Baratheon 6 50 ## Greyjoy 4 47 ## House Arryn 3 4 ## House Baratheon 0 8 ## House Greyjoy 1 23 ## House Lannister 2 19 ## House Martell 7 5 ## House Stark 6 29 ## House Targaryen 5 14 ## House Tully 0 8 ## House Tyrell 4 7 ## Lannister 12 69 ## Martell 7 18 ## Night&#39;s Watch 0 116 ## None 51 202 ## Stark 21 52 ## Targaryen 1 16 ## Tully 2 20 ## Tyrell 6 9 ## Wildling 16 24 2.12.2 Subsetting Как мы обсуждали на прошлом занятии, мы можем сабсеттить (выделять часть датафрейма) датафрейм, обращаясь к нему и как к матрице: датафрейм[вектор_с_номерами_строк, вектор_с_номерами_колонок] got[100:115, 1:2] ## Name Allegiances ## 100 Blue Bard House Tyrell ## 101 Bonifer Hasty Lannister ## 102 Borcas Night&#39;s Watch ## 103 Boremund Harlaw Greyjoy ## 104 Boros Blount Baratheon ## 105 Borroq Wildling ## 106 Bowen Marsh Night&#39;s Watch ## 107 Bran Stark House Stark ## 108 Brandon Norrey Stark ## 109 Brenett None ## 110 Brienne of Tarth Stark ## 111 Bronn Lannister ## 112 Brown Bernarr Night&#39;s Watch ## 113 Brusco None ## 114 Bryan Fossoway Baratheon ## 115 Bryce Caron Baratheon и используя имена колонок: got[508:515, &quot;Name&quot;] ## [1] &quot;Mance Rayder&quot; &quot;Mandon Moore&quot; &quot;Maric Seaworth&quot; &quot;Marei&quot; ## [5] &quot;Margaery Tyrell&quot; &quot;Marillion&quot; &quot;Maris&quot; &quot;Marissa Frey&quot; и даже используя вектора названий колонок! got[508:515, c(&quot;Name&quot;, &quot;Allegiances&quot;, &quot;Gender&quot;)] ## Name Allegiances Gender ## 508 Mance Rayder Wildling 1 ## 509 Mandon Moore Baratheon 1 ## 510 Maric Seaworth House Baratheon 1 ## 511 Marei None 0 ## 512 Margaery Tyrell House Tyrell 0 ## 513 Marillion Arryn 1 ## 514 Maris Wildling 0 ## 515 Marissa Frey None 0 Мы можем вытаскивать отдельные колонки как векторы: houses &lt;- got$Allegiances unique(houses) #посмотреть все уникальные значения --- почти как с помощью table() ## [1] &quot;Lannister&quot; &quot;None&quot; &quot;House Targaryen&quot; &quot;House Greyjoy&quot; ## [5] &quot;Baratheon&quot; &quot;Night&#39;s Watch&quot; &quot;Arryn&quot; &quot;House Stark&quot; ## [9] &quot;House Tyrell&quot; &quot;Tyrell&quot; &quot;Stark&quot; &quot;Greyjoy&quot; ## [13] &quot;House Lannister&quot; &quot;Martell&quot; &quot;House Martell&quot; &quot;Wildling&quot; ## [17] &quot;Targaryen&quot; &quot;House Arryn&quot; &quot;House Tully&quot; &quot;Tully&quot; ## [21] &quot;House Baratheon&quot; Итак, давайте решим нашу первую задачу — вытащим в отдельный датасет всех представителей Ночного Дозора. Для этого нам нужно создать вектор логических значений — результат сравнений колонки Allegiances со значением \"Night's Watch\" и использовать его как вектор индексов для датафрейма. vectornight &lt;- got$Allegiances == &quot;Night&#39;s Watch&quot; head(vectornight) ## [1] FALSE FALSE FALSE FALSE FALSE FALSE Теперь этот вектор с TRUE и FALSE нам надо использовать для индексирования строк. Но что со столбцами? Если мы хотем сохранить все столбцы, то после запятой внутри квадратных скобок нам не нужно ничего указывать: nightswatch &lt;- got[vectornight,] head(nightswatch) ## Name Allegiances Death.Year Book.of.Death ## 7 Aemon Targaryen (son of Maekar I) Night&#39;s Watch 300 4 ## 10 Aethan Night&#39;s Watch NA NA ## 13 Alan of Rosby Night&#39;s Watch 300 5 ## 16 Albett Night&#39;s Watch NA NA ## 24 Alliser Thorne Night&#39;s Watch NA NA ## 49 Arron Night&#39;s Watch NA NA ## Death.Chapter Book.Intro.Chapter Gender Nobility GoT CoK SoS FfC DwD ## 7 35 21 1 1 1 0 1 1 0 ## 10 NA 0 1 0 0 0 1 0 0 ## 13 4 18 1 1 0 1 1 0 1 ## 16 NA 26 1 0 1 0 0 0 0 ## 24 NA 19 1 0 1 1 1 0 1 ## 49 NA 75 1 0 0 0 1 0 1 Вуаля! Все это можно сделать проще и в одну строку: nightswatch &lt;- got[got$Allegiances == &quot;Night&#39;s Watch&quot;,] И не забывайте про запятую! Теперь попробуем вытащить одновременно всех Одичалых (Wildling) и всех представителей Ночного Дозора. Это можно сделать, используя оператор | (ИЛИ) при выборе колонок: nightwatch_wildling &lt;- got[got$Allegiances == &quot;Night&#39;s Watch&quot; | got$Allegiances == &quot;Wildling&quot;,] head(nightwatch_wildling) ## Name Allegiances Death.Year Book.of.Death ## 7 Aemon Targaryen (son of Maekar I) Night&#39;s Watch 300 4 ## 10 Aethan Night&#39;s Watch NA NA ## 13 Alan of Rosby Night&#39;s Watch 300 5 ## 16 Albett Night&#39;s Watch NA NA ## 24 Alliser Thorne Night&#39;s Watch NA NA ## 49 Arron Night&#39;s Watch NA NA ## Death.Chapter Book.Intro.Chapter Gender Nobility GoT CoK SoS FfC DwD ## 7 35 21 1 1 1 0 1 1 0 ## 10 NA 0 1 0 0 0 1 0 0 ## 13 4 18 1 1 0 1 1 0 1 ## 16 NA 26 1 0 1 0 0 0 0 ## 24 NA 19 1 0 1 1 1 0 1 ## 49 NA 75 1 0 0 0 1 0 1 Кажется очевидным следующий вариант: got[got$Allegiances == c(\"Night's Watch\", \"Wildling\"),]. Однако это выдаст не совсем то, что нужно, хотя результат может показаться верным на первый взгляд. Попробуйте самостоятельно ответить на вопрос, что происходит в данном случае и чем результат отличается от предполагаемого. Подсказка: вспомните правило recycling. Для таких случаев есть удобный оператор %in%, который позволяет сравнить каждое значение вектора с целым набором значений. Если значение вектора хотя бы один раз встречается в векторе справа от %in%, то результат — TRUE: 1:6 %in% c(1,4,5) ## [1] TRUE FALSE FALSE TRUE TRUE FALSE nightwatch_wildling &lt;- got[got$Allegiances %in% c(&quot;Night&#39;s Watch&quot;, &quot;Wildling&quot;),] head(nightwatch_wildling) ## Name Allegiances Death.Year Book.of.Death ## 7 Aemon Targaryen (son of Maekar I) Night&#39;s Watch 300 4 ## 10 Aethan Night&#39;s Watch NA NA ## 13 Alan of Rosby Night&#39;s Watch 300 5 ## 16 Albett Night&#39;s Watch NA NA ## 24 Alliser Thorne Night&#39;s Watch NA NA ## 49 Arron Night&#39;s Watch NA NA ## Death.Chapter Book.Intro.Chapter Gender Nobility GoT CoK SoS FfC DwD ## 7 35 21 1 1 1 0 1 1 0 ## 10 NA 0 1 0 0 0 1 0 0 ## 13 4 18 1 1 0 1 1 0 1 ## 16 NA 26 1 0 1 0 0 0 0 ## 24 NA 19 1 0 1 1 1 0 1 ## 49 NA 75 1 0 0 0 1 0 1 2.12.3 Создание новых колонок Давайте создадим новую колонку, которая будет означать, жив ли еще персонаж (по книгам). Заметьте, что в этом датасете, хоть он и посвящен смертям персонажей, нет нужной колонки. Мы можем попытаться “вытащить” эту информацию. В колонках Death.Year, Death.Chapter и Book.of.Death стоит NA у многих персонажей. Например, у Arya Stark, которая и по книгам, и по сериалу живее всех живых и мертвых: got[got$Name == &quot;Arya Stark&quot;,] ## Name Allegiances Death.Year Book.of.Death Death.Chapter ## 56 Arya Stark Stark NA NA NA ## Book.Intro.Chapter Gender Nobility GoT CoK SoS FfC DwD ## 56 2 0 1 1 1 1 1 1 Следовательно, если в Book.of.Death стоит NA, мы можем предположить, что Джордж Мартин еще не занес своей карающей руки над этим героем. Мы можем создать новую колонку Is.Alive: got$Is.Alive &lt;- is.na(got$Book.of.Death) 2.12.4 data.table vs. tidyverse В принципе, с помощью базового R можно сделать все, что угодно. Однако базовые инструменты R — не всегда самые удобные. Идея сделать работу с датафреймами в R еще быстрее и удобнее сподвигла разработчиков на создание новых инструментов — data.table и tidyverse (dplyr). Это два конкурирующих подхода, которые сильно перерабатывают язык, хотя это по-прежнему все тот же R — поэтому их еще называют “диалектами” R. Оба подхода обладают своими преимуществами и недостатками, но на сегодняшний день tidyverse считается более популярным. Основное преимущество этого подхода — в относительной легкости освоения. Обычно код, написанный в tidyverse можно примерно понять, даже не владея им. Преимущество data.table — в суровом лаконичном синтаксисе и наиболее эффективных алгоритмах. Последние обеспечивают очень серьезный прирост в скорости в работе с данными. Чтение файлов и манипуляция данными может быть на порядки быстрее, поэтому если Ваш датасет с трудом пролезает в оперативную память компьютера, а исполнение скрипта занимает длительное время - стоит задуматься о переходе на data.table. Что из этого учить — решать Вам, но знать оба совсем не обязательно: они решают те же самые задачи, просто совсем разными способами. За data.table — скорость, за tidyverse - понятность синтаксиса. Очень советую почитать обсуждение на эту тему здесь. Ссылки на литературу "],
["tidy-dplyr.html", "3 tidyverse: Загрузка и трансформация данных 3.1 Загрузка данных 3.2 tibble 3.3 dplyr 3.4 Соединение датафреймов 3.5 tidyr package 3.6 Полезные надстройки", " 3 tidyverse: Загрузка и трансформация данных tidyverse — это набор пакетов: ggplot2, для визуализации tibble, для работы с тибблами, современный вариант датафрейма tidyr, для формата tidy data readr, для чтения файлов в R purrr, для функционального программирования dplyr, для преобразованиия данных stringr, для работы со строковыми переменными forcats, для работы с переменными-факторами Полезно также знать о следующих: readxl, для чтения .xls и .xlsx jsonlite, для работы с JSON rvest, для веб-скреппинга lubridate, для работы с временем tidytext, для работы с текстами и корпусами broom, для перевода в tidy формат статистические модели library(&quot;tidyverse&quot;) ## ── Attaching packages ───────────────────── tidyverse 1.3.0 ── ## ✔ ggplot2 3.2.1 ✔ purrr 0.3.3 ## ✔ tibble 2.1.3 ✔ dplyr 0.8.3 ## ✔ tidyr 1.0.0 ✔ stringr 1.4.0 ## ✔ readr 1.3.1 ✔ forcats 0.4.0 ## ── Conflicts ──────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() 3.1 Загрузка данных 3.1.1 Рабочая директория Все в R происходит где-то. Нужно загружать файлы с данными, нужно их куда-то сохранять. Желательно иметь для каждого проекта некоторую отдельную папку на компьютере, куда складывать все, отнсящееся к этому проекту. Две команды позволят опредить текущую рабочую дерикторию (getwd()) и (setwd(.../path/to/your/directory)). 3.1.2 Форматы данных: .csv Существет много форматов данных, которые придумали люди. Большинство из них можно загрузить в R. Так как центральный объект в R – таблица \\(n \\times k\\), то и работать мы большую часть времени будем с таблицами. Наиболее распространенные способы хранить данные сейчас это .csv (разберем в данном разделе) и .json (разберем в разделе @ref{lists}). .csv (comma separated values) – является обычным текстовым файлом, в котором перечислены значения с некоторым фиксированным разделителем: запятой, табуляцией, точка с запятой, пробел и др. Такие файлы обычно легко открывает LibreOffice, а в Microsoft Excel нужны некоторые трюки. 3.1.3 Загрузка данных: readr, readxl Стандартной функцией для чтения .csv файлов в R является функция read.csv(), но мы будем использовать функцию read_csv() из пакета readr. read_csv(&quot;...&quot;) Вместо многоточия может стоять: название файла (если он, есть в текущей рабочей дериктории) read_csv(&quot;my_file.csv&quot;) относительный путь к файлу (если он, верен для текущей рабочей дериктории) read_csv(&quot;data/my_file.csv&quot;) полный путь к файлу (если он, верен для текущей рабочей дериктории) read_csv(&quot;/home/user_name/work/data/my_file.csv&quot;) интернет ссылка (тогда, компьютер должен быть подключен к интернету) read_csv(&quot;https://my_host/my_file.csv&quot;) Для чтения других форматов .csv файлов используются другие функции: read_tsv() – для файлов с табуляцией в качестве разделителя read_csv2() – для файлов с точкой с запятой в качестве разделителя read_delim(file = \"...\", delim = \"...\") – для файлов с любым разделителем, задаваемым аргументом delim Стандартной практикой является создавать первой строкой .csv файлов названия столбцов, поэтому по умолчанию функции read_...() будут создавать таблицу, считая первую строку названием столбцов. Чтобы изменить это поведение следует использовать аргумент col_names = FALSE. Другая проблема при чтении файлов – кодировка и локаль. На разных компьютерах разные локали и дефолтные кодировки, так что имеет смысл знать про аргумент locale(encoding = \"UTF-8\"). Попробуйте корректно считать в R файл по этой ссылке. ## # A tibble: 3 x 3 ## cyrillic ipa_symbols greek ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 а ʁ α ## 2 б ʔ β ## 3 в ʃ γ Благодаря readxl пакету Также данные можно скачать напрямую из файлов .xls (функция read_xls) и .xlsx (функция read_xlsx), однако эти функции не умеют читать из интернета. library(&quot;readxl&quot;) xlsx_example &lt;- read_xlsx(&quot;...&quot;) Существует еще один экстравагантный способ хранить данные: это формат файлов R .RData. Создадим data.frame: my_df &lt;- data.frame(letters = c(&quot;a&quot;, &quot;b&quot;), numbers = 1:2) my_df ## letters numbers ## 1 a 1 ## 2 b 2 Теперь можно сохранить файл… save(my_df, file = &quot;data/my_df.RData&quot;) удалить переменную… rm(my_df) my_df ## Error in eval(expr, envir, enclos): object &#39;my_df&#39; not found и загрузить все снова: load(&quot;data/my_df.RData&quot;) my_df ## letters numbers ## 1 a 1 ## 2 b 2 3.1.3.1 Misspelling dataset Этот датасет я переработал из данных, собранных для статьи The Gyllenhaal Experiment, написанной Расселом Гольденбергом и Мэттом Дэниэлсом для издания pudding. Они анализировали ошибки в правописании при поиске имен и фамилий звезд. misspellings &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/misspelling_dataset.csv&quot;) ## Parsed with column specification: ## cols( ## correct = col_character(), ## spelling = col_character(), ## count = col_double() ## ) misspellings ## # A tibble: 15,477 x 3 ## correct spelling count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel deschanel 18338 ## 2 deschanel dechanel 1550 ## 3 deschanel deschannel 934 ## 4 deschanel deschenel 404 ## 5 deschanel deshanel 364 ## 6 deschanel dechannel 359 ## 7 deschanel deschanelle 316 ## 8 deschanel dechanelle 192 ## 9 deschanel deschanell 174 ## 10 deschanel deschenal 165 ## # … with 15,467 more rows В датасете следующие переменные: correct – корректное написание фамилии spelling – написание, которое сделали пользователи count – количество случаев такого написания 3.1.3.2 diamonds diamonds ## # A tibble: 53,940 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 ## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 ## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 ## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49 ## 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39 ## # … with 53,930 more rows ?diamonds 3.2 tibble Пакет tibble – является альтернативой штатного датафрейма в R. Существует встроенная переменная month.name: month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; Можно создать датафрейм таким образом: data.frame(id = 1:12, months = month.name, n_letters = nchar(months)) ## Error in nchar(months): cannot coerce type &#39;closure&#39; to vector of type &#39;character&#39; Однако переменная months не создана пользователем, так что данный код выдает ошибку. Корректный способ сделать это базовыми средствами: data.frame(id = 1:12, months = month.name, n_letters = nchar(month.name)) ## id months n_letters ## 1 1 January 7 ## 2 2 February 8 ## 3 3 March 5 ## 4 4 April 5 ## 5 5 May 3 ## 6 6 June 4 ## 7 7 July 4 ## 8 8 August 6 ## 9 9 September 9 ## 10 10 October 7 ## 11 11 November 8 ## 12 12 December 8 Одно из отличий tibble от базового датафрейма – возможность использовать создаваемые “по ходу пьесы переменные” tibble(id = 1:12, months = month.name, n_letters = nchar(months)) ## # A tibble: 12 x 3 ## id months n_letters ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 1 January 7 ## 2 2 February 8 ## 3 3 March 5 ## 4 4 April 5 ## 5 5 May 3 ## 6 6 June 4 ## 7 7 July 4 ## 8 8 August 6 ## 9 9 September 9 ## 10 10 October 7 ## 11 11 November 8 ## 12 12 December 8 Если в окружении пользователя уже есть переменная с датафреймом, его легко можно переделать в tibble при помощи функции as_tibble(): df &lt;- data.frame(id = 1:12, months = month.name) df ## id months ## 1 1 January ## 2 2 February ## 3 3 March ## 4 4 April ## 5 5 May ## 6 6 June ## 7 7 July ## 8 8 August ## 9 9 September ## 10 10 October ## 11 11 November ## 12 12 December as_tibble(df) ## # A tibble: 12 x 2 ## id months ## &lt;int&gt; &lt;fct&gt; ## 1 1 January ## 2 2 February ## 3 3 March ## 4 4 April ## 5 5 May ## 6 6 June ## 7 7 July ## 8 8 August ## 9 9 September ## 10 10 October ## 11 11 November ## 12 12 December Функицонально tibble от data.frame ничем не отличается, однако существует ряд несущественных отличий. Кроме того стоит помнить, что многие функции из tidyverse возвращают именно tibble, а не data.frame. 3.3 dplyr В сжатом виде содержание этого раздела хранится вот здесь или здесь. 3.3.1 dplyr::filter() Эта функция фильтрует строчки по условиям, основанным на столбцах. Сколько неправильных произношений, которые написали меньше 10 юзеров? misspellings %&gt;% filter(count &lt; 10) ## # A tibble: 14,279 x 3 ## correct spelling count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel deshanael 9 ## 2 deschanel daychanel 9 ## 3 deschanel deschaneles 9 ## 4 deschanel dashenel 9 ## 5 deschanel deschenael 9 ## 6 deschanel deechanel 9 ## 7 deschanel deichanel 9 ## 8 deschanel dechantel 9 ## 9 deschanel deychanel 9 ## 10 deschanel daschenell 9 ## # … with 14,269 more rows %&gt;% — конвеер (pipe) отправляет результат работы одной функции в другую. sort(sqrt(abs(sin(1:22))), decreasing = TRUE) ## [1] 0.9999951 0.9952926 0.9946649 0.9805088 0.9792468 0.9554817 0.9535709 ## [8] 0.9173173 0.9146888 0.8699440 0.8665952 0.8105471 0.8064043 0.7375779 ## [15] 0.7325114 0.6482029 0.6419646 0.5365662 0.5285977 0.3871398 0.3756594 ## [22] 0.0940814 1:22 %&gt;% sin() %&gt;% abs() %&gt;% sqrt() %&gt;% sort(., decreasing = TRUE) # зачем здесь точка? ## [1] 0.9999951 0.9952926 0.9946649 0.9805088 0.9792468 0.9554817 0.9535709 ## [8] 0.9173173 0.9146888 0.8699440 0.8665952 0.8105471 0.8064043 0.7375779 ## [15] 0.7325114 0.6482029 0.6419646 0.5365662 0.5285977 0.3871398 0.3756594 ## [22] 0.0940814 Конвееры в tidyverse пришли из пакета magrittr. Иногда они работают не корректно с функциями не из tidyverse. 3.3.2 dplyr::slice() Эта функция фильтрует строчки по индексу. misspellings %&gt;% slice(3:7) ## # A tibble: 5 x 3 ## correct spelling count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel deschannel 934 ## 2 deschanel deschenel 404 ## 3 deschanel deshanel 364 ## 4 deschanel dechannel 359 ## 5 deschanel deschanelle 316 3.3.3 dplyr::select() Эта функция позволяет выбрать столбцы. diamonds %&gt;% select(8:10) ## # A tibble: 53,940 x 3 ## x y z ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3.95 3.98 2.43 ## 2 3.89 3.84 2.31 ## 3 4.05 4.07 2.31 ## 4 4.2 4.23 2.63 ## 5 4.34 4.35 2.75 ## 6 3.94 3.96 2.48 ## 7 3.95 3.98 2.47 ## 8 4.07 4.11 2.53 ## 9 3.87 3.78 2.49 ## 10 4 4.05 2.39 ## # … with 53,930 more rows diamonds %&gt;% select(color:price) ## # A tibble: 53,940 x 5 ## color clarity depth table price ## &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 E SI2 61.5 55 326 ## 2 E SI1 59.8 61 326 ## 3 E VS1 56.9 65 327 ## 4 I VS2 62.4 58 334 ## 5 J SI2 63.3 58 335 ## 6 J VVS2 62.8 57 336 ## 7 I VVS1 62.3 57 336 ## 8 H SI1 61.9 55 337 ## 9 E VS2 65.1 61 337 ## 10 H VS1 59.4 61 338 ## # … with 53,930 more rows diamonds %&gt;% select(-carat) ## # A tibble: 53,940 x 9 ## cut color clarity depth table price x y z ## &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 ## 7 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 ## 8 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 ## 9 Fair E VS2 65.1 61 337 3.87 3.78 2.49 ## 10 Very Good H VS1 59.4 61 338 4 4.05 2.39 ## # … with 53,930 more rows diamonds %&gt;% select(-c(carat, cut, x, y, z)) ## # A tibble: 53,940 x 5 ## color clarity depth table price ## &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 E SI2 61.5 55 326 ## 2 E SI1 59.8 61 326 ## 3 E VS1 56.9 65 327 ## 4 I VS2 62.4 58 334 ## 5 J SI2 63.3 58 335 ## 6 J VVS2 62.8 57 336 ## 7 I VVS1 62.3 57 336 ## 8 H SI1 61.9 55 337 ## 9 E VS2 65.1 61 337 ## 10 H VS1 59.4 61 338 ## # … with 53,930 more rows diamonds %&gt;% select(cut, depth, price) ## # A tibble: 53,940 x 3 ## cut depth price ## &lt;ord&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Ideal 61.5 326 ## 2 Premium 59.8 326 ## 3 Good 56.9 327 ## 4 Premium 62.4 334 ## 5 Good 63.3 335 ## 6 Very Good 62.8 336 ## 7 Very Good 62.3 336 ## 8 Very Good 61.9 337 ## 9 Fair 65.1 337 ## 10 Very Good 59.4 338 ## # … with 53,930 more rows 3.3.4 dplyr::arrange() Эта функция сортирует (строки по алфавиту, а числа по порядку). misspellings %&gt;% arrange(count) ## # A tibble: 15,477 x 3 ## correct spelling count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel deschil 1 ## 2 deschanel deshauneil 1 ## 3 deschanel deschmuel 1 ## 4 deschanel deshannle 1 ## 5 deschanel deslanges 1 ## 6 deschanel deshoenel 1 ## 7 deschanel dechadel 1 ## 8 deschanel dooschaney 1 ## 9 deschanel dishana 1 ## 10 deschanel deshaneil 1 ## # … with 15,467 more rows diamonds %&gt;% arrange(desc(carat), price) ## # A tibble: 53,940 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5.01 Fair J I1 65.5 59 18018 10.7 10.5 6.98 ## 2 4.5 Fair J I1 65.8 58 18531 10.2 10.2 6.72 ## 3 4.13 Fair H I1 64.8 61 17329 10 9.85 6.43 ## 4 4.01 Premium I I1 61 61 15223 10.1 10.1 6.17 ## 5 4.01 Premium J I1 62.5 62 15223 10.0 9.94 6.24 ## 6 4 Very Good I I1 63.3 58 15984 10.0 9.94 6.31 ## 7 3.67 Premium I I1 62.4 56 16193 9.86 9.81 6.13 ## 8 3.65 Fair H I1 67.1 53 11668 9.53 9.48 6.38 ## 9 3.51 Premium J VS2 62.5 59 18701 9.66 9.63 6.03 ## 10 3.5 Ideal H I1 62.8 57 12587 9.65 9.59 6.03 ## # … with 53,930 more rows 3.3.5 dplyr::distinct() Эта функция возращает уникальные значения в столбце или комбинации столбцов. misspellings %&gt;% distinct(correct) ## # A tibble: 15 x 1 ## correct ## &lt;chr&gt; ## 1 deschanel ## 2 mclachlan ## 3 galifianakis ## 4 labeouf ## 5 macaulay ## 6 mcconaughey ## 7 minaj ## 8 morissette ## 9 poehler ## 10 shyamalan ## 11 kaepernick ## 12 mcgwire ## 13 palahniuk ## 14 picabo ## 15 johansson misspellings %&gt;% distinct(spelling) ## # A tibble: 15,462 x 1 ## spelling ## &lt;chr&gt; ## 1 deschanel ## 2 dechanel ## 3 deschannel ## 4 deschenel ## 5 deshanel ## 6 dechannel ## 7 deschanelle ## 8 dechanelle ## 9 deschanell ## 10 deschenal ## # … with 15,452 more rows diamonds %&gt;% distinct(color, cut) ## # A tibble: 35 x 2 ## color cut ## &lt;ord&gt; &lt;ord&gt; ## 1 E Ideal ## 2 E Premium ## 3 E Good ## 4 I Premium ## 5 J Good ## 6 J Very Good ## 7 I Very Good ## 8 H Very Good ## 9 E Fair ## 10 J Ideal ## # … with 25 more rows Во встроенном в tidyverse датасете starwars отфильтруйте существ выше 180 (height) и весом меньше 80 (mass) и выведите уникальные значений мест, откуда они происходят (homeworld). 3.3.6 dplyr::mutate() Эта функция позволяет создать новые переменные. misspellings %&gt;% mutate(misspelling_length = nchar(spelling), id = 1:n()) ## # A tibble: 15,477 x 5 ## correct spelling count misspelling_length id ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 deschanel deschanel 18338 9 1 ## 2 deschanel dechanel 1550 8 2 ## 3 deschanel deschannel 934 10 3 ## 4 deschanel deschenel 404 9 4 ## 5 deschanel deshanel 364 8 5 ## 6 deschanel dechannel 359 9 6 ## 7 deschanel deschanelle 316 11 7 ## 8 deschanel dechanelle 192 10 8 ## 9 deschanel deschanell 174 10 9 ## 10 deschanel deschenal 165 9 10 ## # … with 15,467 more rows Создайте переменную с индексом Кетле: \\(\\frac{mass}{height^2}\\) для всех существ датасета starwars. Сколько героев страдают ожирением (т. е. имеют индекс массы тела больше 30)? (Не забудьте перевести рост из сантиметров в метры). 3.3.7 dplyr::group_by(...) %&gt;% summarise(...) Эта функция позволяет сгруппировать переменные по какому-то из столбцов и получить какой-нибудь вывод из описательной статистики (максимум, минимум, последний, первый, среднее, медиану и т. п.). misspellings %&gt;% summarise(min(count), mean(count)) ## # A tibble: 1 x 2 ## `min(count)` `mean(count)` ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 21.8 misspellings %&gt;% group_by(correct) %&gt;% summarise(mean(count)) ## # A tibble: 15 x 2 ## correct `mean(count)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel 25.9 ## 2 galifianakis 8.64 ## 3 johansson 74.8 ## 4 kaepernick 29.1 ## 5 labeouf 61.2 ## 6 macaulay 17.6 ## 7 mcconaughey 7.74 ## 8 mcgwire 55.3 ## 9 mclachlan 14.8 ## 10 minaj 140. ## 11 morissette 55.2 ## 12 palahniuk 10.2 ## 13 picabo 23.2 ## 14 poehler 65.3 ## 15 shyamalan 16.9 misspellings %&gt;% group_by(correct) %&gt;% summarise(my_mean = mean(count)) ## # A tibble: 15 x 2 ## correct my_mean ## &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel 25.9 ## 2 galifianakis 8.64 ## 3 johansson 74.8 ## 4 kaepernick 29.1 ## 5 labeouf 61.2 ## 6 macaulay 17.6 ## 7 mcconaughey 7.74 ## 8 mcgwire 55.3 ## 9 mclachlan 14.8 ## 10 minaj 140. ## 11 morissette 55.2 ## 12 palahniuk 10.2 ## 13 picabo 23.2 ## 14 poehler 65.3 ## 15 shyamalan 16.9 Если нужно посчитать количество вхождений, то можно использовать функцию n() в summarise() или же функцию count(): misspellings %&gt;% group_by(correct) %&gt;% summarise(n = n()) ## # A tibble: 15 x 2 ## correct n ## &lt;chr&gt; &lt;int&gt; ## 1 deschanel 1015 ## 2 galifianakis 2633 ## 3 johansson 392 ## 4 kaepernick 779 ## 5 labeouf 449 ## 6 macaulay 1458 ## 7 mcconaughey 2897 ## 8 mcgwire 262 ## 9 mclachlan 1054 ## 10 minaj 200 ## 11 morissette 478 ## 12 palahniuk 1541 ## 13 picabo 460 ## 14 poehler 386 ## 15 shyamalan 1473 misspellings %&gt;% count(correct) ## # A tibble: 15 x 2 ## correct n ## &lt;chr&gt; &lt;int&gt; ## 1 deschanel 1015 ## 2 galifianakis 2633 ## 3 johansson 392 ## 4 kaepernick 779 ## 5 labeouf 449 ## 6 macaulay 1458 ## 7 mcconaughey 2897 ## 8 mcgwire 262 ## 9 mclachlan 1054 ## 10 minaj 200 ## 11 morissette 478 ## 12 palahniuk 1541 ## 13 picabo 460 ## 14 poehler 386 ## 15 shyamalan 1473 А что будет, если в датасете misspellings создать переменную n и зоставить отсортировать по переменным correct и n? Можно даже отсортировать результат: misspellings %&gt;% count(correct, sort = TRUE) ## # A tibble: 15 x 2 ## correct n ## &lt;chr&gt; &lt;int&gt; ## 1 mcconaughey 2897 ## 2 galifianakis 2633 ## 3 palahniuk 1541 ## 4 shyamalan 1473 ## 5 macaulay 1458 ## 6 mclachlan 1054 ## 7 deschanel 1015 ## 8 kaepernick 779 ## 9 morissette 478 ## 10 picabo 460 ## 11 labeouf 449 ## 12 johansson 392 ## 13 poehler 386 ## 14 mcgwire 262 ## 15 minaj 200 Если вы хотите создать не какое-то саммари, а целый дополнительный столбец с этим саммари вместо функции summarise() нужно использовать функцию mutate(): misspellings %&gt;% group_by(correct) %&gt;% mutate(my_mean = mean(count)) ## # A tibble: 15,477 x 4 ## # Groups: correct [15] ## correct spelling count my_mean ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 deschanel deschanel 18338 25.9 ## 2 deschanel dechanel 1550 25.9 ## 3 deschanel deschannel 934 25.9 ## 4 deschanel deschenel 404 25.9 ## 5 deschanel deshanel 364 25.9 ## 6 deschanel dechannel 359 25.9 ## 7 deschanel deschanelle 316 25.9 ## 8 deschanel dechanelle 192 25.9 ## 9 deschanel deschanell 174 25.9 ## 10 deschanel deschenal 165 25.9 ## # … with 15,467 more rows Схематически это выглядит так: В датасете starwars запишите в отдельную переменную среднее значение роста (height) по каждой расе (species). 3.4 Соединение датафреймов 3.4.1 bind_... Это семейство функций позволяет соединять разные датафреймы: my_tbl &lt;- tibble(a = c(1, 5, 2), b = c(&quot;e&quot;, &quot;g&quot;, &quot;s&quot;)) Чтобы соединить строчки датафреймов с одинаковым набором колонок: my_tbl %&gt;% bind_rows(my_tbl) ## # A tibble: 6 x 2 ## a b ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 e ## 2 5 g ## 3 2 s ## 4 1 e ## 5 5 g ## 6 2 s Вместо отсутствующих колонок появятся NA: my_tbl %&gt;% bind_rows(my_tbl[,-1]) ## # A tibble: 6 x 2 ## a b ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 e ## 2 5 g ## 3 2 s ## 4 NA e ## 5 NA g ## 6 NA s Чтобы соединить строчки датафреймов с одинаковым набором строчек (если названия столбцов будут пересекаться, то они будут пронумерованы): my_tbl %&gt;% bind_cols(my_tbl) # соединяет колонки ## # A tibble: 3 x 4 ## a b a1 b1 ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 e 1 e ## 2 5 g 5 g ## 3 2 s 2 s Соединяя датафреймы с разным количеством строк my_tbl %&gt;% bind_cols(my_tbl[-1,]) ## Error: Argument 2 must be length 3, not 2 3.4.2 dplyr::.._join() Эти функции позволяют соединять датафреймы. languages &lt;- data_frame( languages = c(&quot;Selkup&quot;, &quot;French&quot;, &quot;Chukchi&quot;, &quot;Polish&quot;), countries = c(&quot;Russia&quot;, &quot;France&quot;, &quot;Russia&quot;, &quot;Poland&quot;), iso = c(&quot;sel&quot;, &quot;fra&quot;, &quot;ckt&quot;, &quot;pol&quot;) ) ## Warning: `data_frame()` is deprecated, use `tibble()`. ## This warning is displayed once per session. languages ## # A tibble: 4 x 3 ## languages countries iso ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Selkup Russia sel ## 2 French France fra ## 3 Chukchi Russia ckt ## 4 Polish Poland pol country_population &lt;- data_frame( countries = c(&quot;Russia&quot;, &quot;Poland&quot;, &quot;Finland&quot;), population_mln = c(143, 38, 5)) country_population ## # A tibble: 3 x 2 ## countries population_mln ## &lt;chr&gt; &lt;dbl&gt; ## 1 Russia 143 ## 2 Poland 38 ## 3 Finland 5 inner_join(languages, country_population) ## Joining, by = &quot;countries&quot; ## # A tibble: 3 x 4 ## languages countries iso population_mln ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Selkup Russia sel 143 ## 2 Chukchi Russia ckt 143 ## 3 Polish Poland pol 38 left_join(languages, country_population) ## Joining, by = &quot;countries&quot; ## # A tibble: 4 x 4 ## languages countries iso population_mln ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Selkup Russia sel 143 ## 2 French France fra NA ## 3 Chukchi Russia ckt 143 ## 4 Polish Poland pol 38 right_join(languages, country_population) ## Joining, by = &quot;countries&quot; ## # A tibble: 4 x 4 ## languages countries iso population_mln ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Selkup Russia sel 143 ## 2 Chukchi Russia ckt 143 ## 3 Polish Poland pol 38 ## 4 &lt;NA&gt; Finland &lt;NA&gt; 5 anti_join(languages, country_population) ## Joining, by = &quot;countries&quot; ## # A tibble: 1 x 3 ## languages countries iso ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 French France fra anti_join(country_population, languages) ## Joining, by = &quot;countries&quot; ## # A tibble: 1 x 2 ## countries population_mln ## &lt;chr&gt; &lt;dbl&gt; ## 1 Finland 5 full_join(country_population, languages) ## Joining, by = &quot;countries&quot; ## # A tibble: 5 x 4 ## countries population_mln languages iso ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Russia 143 Selkup sel ## 2 Russia 143 Chukchi ckt ## 3 Poland 38 Polish pol ## 4 Finland 5 &lt;NA&gt; &lt;NA&gt; ## 5 France NA French fra 3.5 tidyr package Давайте посмотрим на датасет с количеством носителей разных языков в Индии согласно переписи 2001 года (данные из Википедии): langs_in_india_short &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/languages_in_india.csv&quot;) ## Parsed with column specification: ## cols( ## language = col_character(), ## n_L1_sp = col_double(), ## n_L2_sp = col_double(), ## n_L3_sp = col_double(), ## n_all_sp = col_double() ## ) Short format langs_in_india_short ## # A tibble: 12 x 5 ## language n_L1_sp n_L2_sp n_L3_sp n_all_sp ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hindi 422048642 98207180 31160696 551416518 ## 2 English 226449 86125221 38993066 125344736 ## 3 Bengali 83369769 6637222 1108088 91115079 ## 4 Telugu 74002856 9723626 1266019 84992501 ## 5 Marathi 71936894 9546414 2701498 84184806 ## 6 Tamil 60793814 4992253 956335 66742402 ## 7 Urdu 51536111 6535489 1007912 59079512 ## 8 Kannada 37924011 11455287 1396428 50775726 ## 9 Gujarati 46091617 3476355 703989 50271961 ## 10 Odia 33017446 3272151 319525 36609122 ## 11 Malayalam 33066392 499188 195885 33761465 ## 12 Sanskrit 14135 1234931 3742223 4991289 Long format ## # A tibble: 48 x 3 ## language type n_speakers ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Hindi n_L1_sp 422048642 ## 2 Hindi n_L2_sp 98207180 ## 3 Hindi n_L3_sp 31160696 ## 4 Hindi n_all_sp 551416518 ## 5 English n_L1_sp 226449 ## 6 English n_L2_sp 86125221 ## 7 English n_L3_sp 38993066 ## 8 English n_all_sp 125344736 ## 9 Bengali n_L1_sp 83369769 ## 10 Bengali n_L2_sp 6637222 ## # … with 38 more rows Short format → Long format: tidyr::pivot_longer() langs_in_india_short %&gt;% pivot_longer(names_to = &quot;type&quot;, values_to = &quot;n_speakers&quot;, n_L1_sp:n_all_sp)-&gt; langs_in_india_long langs_in_india_long ## # A tibble: 48 x 3 ## language type n_speakers ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Hindi n_L1_sp 422048642 ## 2 Hindi n_L2_sp 98207180 ## 3 Hindi n_L3_sp 31160696 ## 4 Hindi n_all_sp 551416518 ## 5 English n_L1_sp 226449 ## 6 English n_L2_sp 86125221 ## 7 English n_L3_sp 38993066 ## 8 English n_all_sp 125344736 ## 9 Bengali n_L1_sp 83369769 ## 10 Bengali n_L2_sp 6637222 ## # … with 38 more rows Long format → Short format: tidyr::pivot_wider() langs_in_india_long %&gt;% pivot_wider(names_from = &quot;type&quot;, values_from = &quot;n_speakers&quot;)-&gt; langs_in_india_short langs_in_india_short ## # A tibble: 12 x 5 ## language n_L1_sp n_L2_sp n_L3_sp n_all_sp ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hindi 422048642 98207180 31160696 551416518 ## 2 English 226449 86125221 38993066 125344736 ## 3 Bengali 83369769 6637222 1108088 91115079 ## 4 Telugu 74002856 9723626 1266019 84992501 ## 5 Marathi 71936894 9546414 2701498 84184806 ## 6 Tamil 60793814 4992253 956335 66742402 ## 7 Urdu 51536111 6535489 1007912 59079512 ## 8 Kannada 37924011 11455287 1396428 50775726 ## 9 Gujarati 46091617 3476355 703989 50271961 ## 10 Odia 33017446 3272151 319525 36609122 ## 11 Malayalam 33066392 499188 195885 33761465 ## 12 Sanskrit 14135 1234931 3742223 4991289 Вот здесь лежит датасет, который содержит информацию о селах в Дагестане в формате .xlsx. Данные разделены по разным листам и содержат следующие переменные (данные получены из разных источников, поэтому имеют суффикс _s1 – первый источник и _s2 – второй источник): id_s1 – (s1) идентификационный номер из первого источника; name_1885 – (s1) название селения из переписи 1885 census_1885 – (s1) число людей из переписи 1885 name_1895 – (s1) название селения из переписи 1895 census_1895 – (s1) число людей из переписи 1895 name_1926 – (s1) название селения из переписи 1926 language_s1 – (s1) язык данного селения согласно первому источнику census_1926 – (s1) число людей из переписи 1926 name_2010 – (s1) название селения из переписи 2010 census_2010 – (s1) число людей из переписи 2010 name_s2 – (s2) название селения согласно второму источнику language_s2 – (s2) язык данного селения согласно первому источнику Lat – (s2) широта селения Lon – (s2) долгота селения elevation – (s2) высота селения над уровнем моря Во-первых, объедините все листы .xlsx воедино: ## # A tibble: 6 x 15 ## id_s1 name_1885 census_1885 name_1895 census_1895 name_1926 language_s1 ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 15 Амишта (… 122 Амишта (… 141 Амишта Avar ## 2 17 Джалатлу… 169 Джалатру… 190 Джалатлу… Avar ## 3 19 Цалкита 102 Цалкита 97 Цалкита Avar ## 4 21 Амуши-бо… 581 Амуши Бо… 550 Амуши бо… Avar ## 5 23 Амуши ма… 159 Амуши Ма… 137 Амуши ма… Avar ## 6 25 Андик (Х… 557 Андых (А… 595 Андых Avar ## # … with 8 more variables: census_1926 &lt;dbl&gt;, name_2010 &lt;chr&gt;, ## # census_2010 &lt;dbl&gt;, name_s2 &lt;chr&gt;, language_s2 &lt;chr&gt;, Lat &lt;dbl&gt;, Lon &lt;dbl&gt;, ## # elevation &lt;dbl&gt; Во-вторых, посчитайте, относительно скольких селений первый и второй источник согласуются относительно языка селения. В-третьих, посчитайте среднюю высоту над уровнем моря для языков из первого источника. Какой выше всех? В-четвертых, посчитайте количество населения, которое говорило на каждом из языков из второго датасета, согласно каждой переписи. Приведите значения для лакского языка (Lak). ## # A tibble: 25 x 5 ## language_s2 `s_1885 &lt;- sum(… `s_1895 &lt;- sum(… `s_1926 &lt;- sum(… ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Aghul 6577 6813 7886 ## 2 Akhvakh 3535 3229 2697 ## 3 Andi 4600 4543 4583 ## 4 Archi 804 765 126 ## 5 Avar 110191 123363 103565 ## 6 Bagvalal 2807 2625 3049 ## 7 Bezhta 2330 2546 1270 ## 8 Botlikh 1383 1323 1346 ## 9 Chamalal 3731 3742 2714 ## 10 Chechen 396 344 524 ## # … with 15 more rows, and 1 more variable: `s_2010 &lt;- sum(census_2010)` &lt;dbl&gt; 3.6 Полезные надстройки Существует достаточно много пакетов надстроек для tidyverse. tidylog – делает лог пайпов: library(tidylog) ## ## Attaching package: &#39;tidylog&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## add_count, add_tally, anti_join, count, distinct, distinct_all, ## distinct_at, distinct_if, filter, filter_all, filter_at, filter_if, ## full_join, group_by, group_by_all, group_by_at, group_by_if, ## inner_join, left_join, mutate, mutate_all, mutate_at, mutate_if, ## right_join, select, select_all, select_at, select_if, semi_join, ## summarise, summarise_all, summarise_at, summarise_if, summarize, ## summarize_all, summarize_at, summarize_if, tally, top_n, transmute, ## transmute_all, transmute_at, transmute_if ## The following objects are masked from &#39;package:tidyr&#39;: ## ## drop_na, fill, gather, replace_na, spread ## The following object is masked from &#39;package:stats&#39;: ## ## filter mtcars %&gt;% group_by(cyl, gear) %&gt;% summarise(mean_mpg = mean(mpg)) %&gt;% pivot_wider(names_from = gear, values_from = mean_mpg) ## group_by: 2 grouping variables (cyl, gear) ## summarise: now 8 rows and 3 columns, one group variable remaining (cyl) ## # A tibble: 3 x 4 ## # Groups: cyl [3] ## cyl `3` `4` `5` ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4 21.5 26.9 28.2 ## 2 6 19.8 19.8 19.7 ## 3 8 15.0 NA 15.4 dtplyr – позволяет вызывать функции dplyr, но используя data.table внутри. Это полезно для работы с большими датасетами. sparklyr – связывает R с Apache Spark (инструмент для кластерных вычислений) … "],
["viz-1.html", "4 Визуализация данных 4.1 Зачем визуализировать данные? 4.2 Основы ggplot2 4.3 Столбчатые диаграммы (barplots) 4.4 Факторы 4.5 Дотплот 4.6 Гистограммы 4.7 Функции плотности 4.8 Точки, джиттер (jitter), вайолинплот (violinplot), ящики с усами (boxplot), 4.9 Фасетизация 4.10 Визуализация комбинаций признаков", " 4 Визуализация данных library(&quot;tidyverse&quot;) 4.1 Зачем визуализировать данные? 4.1.1 Квартет Анскомба В работе Anscombe, F. J. (1973). “Graphs in Statistical Analysis” представлен следующий датасет: quartet &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/anscombe.csv&quot;) quartet ## # A tibble: 44 x 4 ## id dataset x y ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 10 8.04 ## 2 1 2 10 9.14 ## 3 1 3 10 7.46 ## 4 1 4 8 6.58 ## 5 2 1 8 6.95 ## 6 2 2 8 8.14 ## 7 2 3 8 6.77 ## 8 2 4 8 5.76 ## 9 3 1 13 7.58 ## 10 3 2 13 8.74 ## # … with 34 more rows quartet %&gt;% group_by(dataset) %&gt;% summarise(mean_X = mean(x), mean_Y = mean(y), sd_X = sd(x), sd_Y = sd(y), cor = cor(x, y), n_obs = n()) %&gt;% select(-dataset) %&gt;% round(2) ## # A tibble: 4 x 6 ## mean_X mean_Y sd_X sd_Y cor n_obs ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 9 7.5 3.32 2.03 0.82 11 ## 2 9 7.5 3.32 2.03 0.82 11 ## 3 9 7.5 3.32 2.03 0.82 11 ## 4 9 7.5 3.32 2.03 0.82 11 4.1.2 Датазаурус В работе Matejka and Fitzmaurice (2017) “Same Stats, Different Graphs” были представлены следующие датасеты: datasaurus &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/datasaurus.csv&quot;) datasaurus ## # A tibble: 1,846 x 3 ## dataset x y ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 dino 55.4 97.2 ## 2 dino 51.5 96.0 ## 3 dino 46.2 94.5 ## 4 dino 42.8 91.4 ## 5 dino 40.8 88.3 ## 6 dino 38.7 84.9 ## 7 dino 35.6 79.9 ## 8 dino 33.1 77.6 ## 9 dino 29.0 74.5 ## 10 dino 26.2 71.4 ## # … with 1,836 more rows datasaurus %&gt;% group_by(dataset) %&gt;% summarise(mean_X = mean(x), mean_Y = mean(y), sd_X = sd(x), sd_Y = sd(y), cor = cor(x, y), n_obs = n()) %&gt;% select(-dataset) %&gt;% round(1) ## # A tibble: 13 x 6 ## mean_X mean_Y sd_X sd_Y cor n_obs ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 54.3 47.8 16.8 26.9 -0.1 142 ## 2 54.3 47.8 16.8 26.9 -0.1 142 ## 3 54.3 47.8 16.8 26.9 -0.1 142 ## 4 54.3 47.8 16.8 26.9 -0.1 142 ## 5 54.3 47.8 16.8 26.9 -0.1 142 ## 6 54.3 47.8 16.8 26.9 -0.1 142 ## 7 54.3 47.8 16.8 26.9 -0.1 142 ## 8 54.3 47.8 16.8 26.9 -0.1 142 ## 9 54.3 47.8 16.8 26.9 -0.1 142 ## 10 54.3 47.8 16.8 26.9 -0.1 142 ## 11 54.3 47.8 16.8 26.9 -0.1 142 ## 12 54.3 47.8 16.8 26.9 -0.1 142 ## 13 54.3 47.8 16.8 26.9 -0.1 142 4.2 Основы ggplot2 Пакет ggplot2 – современный стандарт для создания графиков в R. Для этого пакета пишут массу расширений. В сжатом виде информация про ggplot2 содержиться здесь. 4.2.1 Диаграмма рассеяния (Scaterplot) ggplot2 ggplot(data = diamonds, aes(carat, price)) + geom_point() dplyr, ggplot2 diamonds %&gt;% ggplot(aes(carat, price))+ geom_point() 4.2.2 Слои diamonds %&gt;% ggplot(aes(carat, price))+ geom_point()+ geom_smooth() ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; diamonds %&gt;% ggplot(aes(carat, price))+ geom_smooth()+ geom_point() ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; 4.2.3 aes() diamonds %&gt;% ggplot(aes(carat, price, color = cut))+ geom_point() diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(color = &quot;green&quot;) diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(aes(color = cut)) diamonds %&gt;% ggplot(aes(carat, price, shape = cut))+ geom_point() diamonds %&gt;% ggplot(aes(carat, price, label = color))+ geom_text() diamonds %&gt;% slice(1:100) %&gt;% ggplot(aes(carat, price, label = color))+ geom_label() Иногда аннотации налезают друг на друга: library(ggrepel) diamonds %&gt;% slice(1:100) %&gt;% ggplot(aes(carat, price, label = color))+ geom_text_repel() diamonds %&gt;% slice(1:100) %&gt;% ggplot(aes(carat, price, label = color))+ geom_text_repel()+ geom_point() diamonds %&gt;% slice(1:100) %&gt;% ggplot(aes(carat, price, label = color, fill = cut))+ # fill отвечает за закрашивание geom_label_repel(alpha = 0.5)+ # alpha отвечает за прозрачность geom_point() 4.2.4 Оформление diamonds %&gt;% ggplot(aes(carat, price, color = cut))+ geom_point() + labs(x = &quot;вес (в каратах)&quot;, y = &quot;цена (в долларах)&quot;, title = &quot;Связь цены и веса бриллиантов&quot;, subtitle = &quot;Данные взяты из датасеты diamonds&quot;, caption = &quot;график сделан при помощи пакета ggplot2&quot;)+ theme(legend.position = &quot;bottom&quot;) # у функции theme() огромный функционал 4.2.5 Логарифмические шкалы Рассмотрим словарь [Ляшевской, Шарова 2011] freqdict &lt;- read_tsv(&quot;https://github.com/agricolamz/DS_for_DH/raw/master/data/freq_dict_2011.csv&quot;) ## Parsed with column specification: ## cols( ## lemma = col_character(), ## pos = col_character(), ## freq_ipm = col_double() ## ) freqdict %&gt;% arrange(desc(freq_ipm)) %&gt;% mutate(id = 1:n()) %&gt;% slice(1:150) %&gt;% ggplot(aes(id, freq_ipm))+ geom_point() freqdict %&gt;% arrange(desc(freq_ipm)) %&gt;% mutate(id = 1:n()) %&gt;% slice(1:150) %&gt;% ggplot(aes(id, freq_ipm, label = lemma))+ geom_point()+ geom_text_repel()+ scale_y_log10() 4.2.6 annotate() Функция annotate добавляет geom к графику. diamonds %&gt;% ggplot(aes(carat, price, color = cut))+ geom_point()+ annotate(geom = &quot;rect&quot;, xmin = 4.8, xmax = 5.2, ymin = 17500, ymax = 18500, fill = &quot;red&quot;, alpha = 0.2) + annotate(geom = &quot;text&quot;, x = 4.7, y = 16600, label = &quot;помогите...\\n я в розовом\\nквадратике&quot;) Скачайте вот этот датасет и постройте диаграмму рассеяния. 4.3 Столбчатые диаграммы (barplots) Одна и та же информация может быть представлена в агрегированном и не агрегированном варианте: misspelling &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/misspelling_dataset.csv&quot;) ## Parsed with column specification: ## cols( ## correct = col_character(), ## spelling = col_character(), ## count = col_double() ## ) misspelling ## # A tibble: 15,477 x 3 ## correct spelling count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel deschanel 18338 ## 2 deschanel dechanel 1550 ## 3 deschanel deschannel 934 ## 4 deschanel deschenel 404 ## 5 deschanel deshanel 364 ## 6 deschanel dechannel 359 ## 7 deschanel deschanelle 316 ## 8 deschanel dechanelle 192 ## 9 deschanel deschanell 174 ## 10 deschanel deschenal 165 ## # … with 15,467 more rows переменные spelling аггрегирована: для каждого значения представлено значение в столбце count, которое обозначает количество каждого из написаний переменные correct неаггрегированы: в этом столбце она повторяется, для того, чтобы сделать вывод, нужно отдельно посчитать количество вариантов Для аггрегированных данных используется geom_col() misspelling %&gt;% slice(1:20) %&gt;% ggplot(aes(spelling, count))+ geom_col() Перевернем оси: misspelling %&gt;% slice(1:20) %&gt;% ggplot(aes(spelling, count))+ geom_col()+ coord_flip() Для неаггрегированных данных используется geom_bar() misspelling %&gt;% ggplot(aes(correct))+ geom_bar() Перевернем оси: misspelling %&gt;% ggplot(aes(correct))+ geom_bar()+ coord_flip() Неаггрегированный вариант можно перевести в аггрегированный: diamonds %&gt;% count(cut) ## # A tibble: 5 x 2 ## cut n ## &lt;ord&gt; &lt;int&gt; ## 1 Fair 1610 ## 2 Good 4906 ## 3 Very Good 12082 ## 4 Premium 13791 ## 5 Ideal 21551 Аггрегированный вариант можно перевести в неаггрегированный: diamonds %&gt;% count(cut) %&gt;% uncount(n) ## # A tibble: 53,940 x 1 ## cut ## &lt;ord&gt; ## 1 Fair ## 2 Fair ## 3 Fair ## 4 Fair ## 5 Fair ## 6 Fair ## 7 Fair ## 8 Fair ## 9 Fair ## 10 Fair ## # … with 53,930 more rows 4.4 Факторы Как можно заметить по предыдущему разделу, переменные на графике упорядочены по алфавиту. Чтобы это исправить нужно обсудить факторы: my_factor &lt;- factor(misspelling$correct) head(my_factor) ## [1] deschanel deschanel deschanel deschanel deschanel deschanel ## 15 Levels: deschanel galifianakis johansson kaepernick labeouf ... shyamalan levels(my_factor) ## [1] &quot;deschanel&quot; &quot;galifianakis&quot; &quot;johansson&quot; &quot;kaepernick&quot; &quot;labeouf&quot; ## [6] &quot;macaulay&quot; &quot;mcconaughey&quot; &quot;mcgwire&quot; &quot;mclachlan&quot; &quot;minaj&quot; ## [11] &quot;morissette&quot; &quot;palahniuk&quot; &quot;picabo&quot; &quot;poehler&quot; &quot;shyamalan&quot; levels(my_factor) &lt;- rev(levels(my_factor)) head(my_factor) ## [1] shyamalan shyamalan shyamalan shyamalan shyamalan shyamalan ## 15 Levels: shyamalan poehler picabo palahniuk morissette minaj ... deschanel misspelling %&gt;% mutate(correct = factor(correct, levels = c(&quot;deschanel&quot;, &quot;galifianakis&quot;, &quot;johansson&quot;, &quot;kaepernick&quot;, &quot;labeouf&quot;, &quot;macaulay&quot;, &quot;mcgwire&quot;, &quot;mclachlan&quot;, &quot;minaj&quot;, &quot;morissette&quot;, &quot;palahniuk&quot;, &quot;picabo&quot;, &quot;poehler&quot;, &quot;shyamalan&quot;, &quot;mcconaughey&quot;))) %&gt;% ggplot(aes(correct))+ geom_bar()+ coord_flip() Для работы с факторами удобно использовать пакет forcats (входит в tidyverse, вот ссылка на cheatsheet). Иногда полезной бывает функция fct_reorder(): misspelling %&gt;% count(correct) ## # A tibble: 15 x 2 ## correct n ## &lt;chr&gt; &lt;int&gt; ## 1 deschanel 1015 ## 2 galifianakis 2633 ## 3 johansson 392 ## 4 kaepernick 779 ## 5 labeouf 449 ## 6 macaulay 1458 ## 7 mcconaughey 2897 ## 8 mcgwire 262 ## 9 mclachlan 1054 ## 10 minaj 200 ## 11 morissette 478 ## 12 palahniuk 1541 ## 13 picabo 460 ## 14 poehler 386 ## 15 shyamalan 1473 misspelling %&gt;% count(correct) %&gt;% ggplot(aes(fct_reorder(correct, n), n))+ geom_col()+ coord_flip() Кроме того, в функцию fct_reorder() можно добавит функцию, которая будет считаться на векторе, по которому группируют: diamonds %&gt;% mutate(cut = fct_reorder(cut, price, mean)) %&gt;% ggplot(aes(cut)) + geom_bar() В этом примере переменная cut упорядочена по средней mean цене price. Естественно, вместо mean можно использовать другие функции (median, min, max или даже собственные функции). Можно совмещать разные geom_...: misspelling %&gt;% count(correct) %&gt;% ggplot(aes(fct_reorder(correct, n), n, label = n))+ geom_col()+ geom_text(nudge_y = 150)+ coord_flip() На Pudding вышла статья про английские пабы. Здесь лежит немного обработанный датасет, которые они использовали. Визуализируйте 30 самых частотоных названий пабов в Великобритании. 📋 список подсказок ➡ 👁 Как получить нужный датафрейм, где все поссчитано? ➡ Этомо моо сделать функцией count. 👁 Стоп, а почему у меня нарисовалось так много значений? ➡ Может быть нужно было, как написано в задании, взять лишь 30 наблюдений? Полезная функция для этого slice(). 👁 Почему нарисовались лишь бары с частотностью 1?. ➡ По умолчанию count не сортирует вообще, так что в slice() попали бары с частотностью 1. Надо отсортировать от большего к меньшему, перед тем как делать slice(). Это можно сделать при помощи функции arrange() или использовать аргумент sort = TRUE в функции count() 👁 Кажется все? ➡ А Вы убрали подписи осей x и y? А подпись добавили? На новостном портале meduza.io недавно вышла новость о применения закона “о неуважении к власти в интернете”. Постройте графики из этой новости. При построении графиков я использовал цвет “tan3”. 📋 список подсказок ➡ 👁 А ссылка на датафрейм, где все посчитано? ➡ А ее нет. Вам надо самим создать датафрейм. Вспоммнайте функцию tibble() 👁 Не понятно, а что это за geom_ такой линия с точкой? ➡ Такого geom_-а нет. Нужно использовать три geom_-а: geom_point(), geom_text() и geom_line(). 👁 Почему все рисуется в алфавитном порядке? ➡ Здесь нужно использовать функцию factor(), чтобы задать эксплицитный порядок. 👁 Почему точки рисуются, а линия не хочет? Спойлер: самим тут не справиться. ➡ Действительно, здесь спрятана хитрость: ggplot не знает как ему соединить имеющиеся точки, поэтому чтобы все заработало нужно создать новую переменную в датафрейме (например, type = 1), а в функции aes() вставить аргумент group = type. Тогда ggplot объединит линией все, что имеет одно и то же значение в аргументе group. 👁 Ой, а как добавить белое окружение вокруг точек? ➡ Нужно пойти на военную хитрость: добавить еще один geom_point() белого цвета и большего размера, а потом уже наложить обычные точки. Тут и возникают проблемы с порядокм: сначала нужно нарисовать линию, потом белые точки, а потом уже коричневые. А где должен быть geom_text()? 👁 Кажется все? ➡ А Вы убрали подписи осей x и y? А подпись добавили? 4.5 Дотплот Иногда для случаев, когда мы исследуем числовую переменную подходит простой график, который отображает распределение наших наблюдений на одной соответствующей числовой шкале. mtcars %&gt;% ggplot(aes(mpg)) + geom_dotplot(method = &quot;histodot&quot;) ## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. По оси x отложена наша переменная, каждая точка – одно наблюдение, а отложенное по оси y стоит игнорировать – оно появляется из-за ограничений пакета ggplot2. Возможно чуть понятнее будет, если добавить geom_rug(), который непосредственно отображает каждое наблюдение. mtcars %&gt;% ggplot(aes(mpg)) + geom_rug()+ geom_dotplot(method = &quot;histodot&quot;) ## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. Больший смысл имеет раскрашенный вариант: mtcars %&gt;% mutate(cyl = factor(cyl)) %&gt;% ggplot(aes(mpg, fill = cyl)) + geom_rug()+ geom_dotplot(method = &quot;histodot&quot;)+ scale_y_continuous(NULL, breaks = NULL) # чтобы убрать ось y ## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. Как видно, на графике, одна синяя точка попала под одну зеленую: значит они имеют общее наблюдение. 4.6 Гистограммы Если наблюдений слишком много, дотплот не имеем много смысла: diamonds %&gt;% ggplot(aes(price)) + geom_dotplot(method = &quot;histodot&quot;)+ scale_y_continuous(NULL, breaks = NULL) # чтобы убрать ось y ## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. diamonds %&gt;% ggplot(aes(price)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Обсудим на предыдущем примере mtcars %&gt;% ggplot(aes(mpg))+ geom_rug()+ geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. По оси x отложена наша переменная, а высота столбца говорит, сколько наблюдений имеют такое же наблюдение. Однако многое зависит от того, что мы считаем одинаковым значением: mtcars %&gt;% ggplot(aes(mpg)) + geom_rug()+ geom_histogram(bins = 100) mtcars %&gt;% ggplot(aes(mpg)) + geom_rug()+ geom_histogram(bins = 5) Существует три алгоритма встроенные в R, которые можно использовать и снимать с себя ответственность: [Sturgers 1926] nclass.Sturges(mtcars$mpg) [Scott 1979] nclass.scott(mtcars$mpg) [Freedman, Diaconis 1981] nclass.FD(mtcars$mpg) mtcars %&gt;% ggplot(aes(mpg)) + geom_histogram(bins = nclass.FD(mtcars$mpg)) Какой из методов использовался при создании следующего графика на основе встроенного датасета iris? В этом типе графика точно так же можно раскрашивать на основании другой переменной: iris %&gt;% ggplot(aes(Petal.Length, fill = Species)) + geom_rug()+ geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 4.7 Функции плотности Кроме того, существует способ использовать не такой рубленный график, а его сглаженную вариант, который строиться при помощи функции плотности. Важное свойство, которое стоит понимать про функцию плотности — что кривая, получаемая ядерной оценкой плотности, не зависит от величины коробки гистограммы (хотя есть аргумент, который отвечает за степень “близости” функции плотности к гистограмме). iris %&gt;% ggplot(aes(Petal.Length)) + geom_rug()+ geom_density() Таким образом мы можем сравнивать распределения: iris %&gt;% ggplot(aes(Petal.Length, fill = Species)) + geom_rug()+ geom_density() Часто имеет смысл настроить прозрачность: iris %&gt;% ggplot(aes(Petal.Length, fill = Species)) + geom_rug()+ geom_density(alpha = 0.6) # значение прозрачности изменяется от 0 до 1 Кроме того, иногда удобно разделять группы на разные уровни: # install.packages(ggridges) library(ggridges) iris %&gt;% ggplot(aes(Petal.Length, Species, fill = Species)) + geom_density_ridges(alpha = 0.6) # значение прозрачности изменяется от 0 до 1 ## Picking joint bandwidth of 0.155 В длинный список “2015 Kantar Information is Beautiful Awards” попала визуализация Perceptions of Probability, сделанная пользователем zonination в ggplot2. Попробуйте воспроизвести ее с этими данными. 📋 список подсказок ➡ 👁 как преобразовать в нужный формат? ➡ Я делал это при помощи функции pivot_longer(). 👁 не получается обратиться к колонкам ➡ Да, если в названиях столбцов есть пробел или цифры, то к ним можно обратиться, воспользовавшись обратынми ковычками `. 👁 получается, но порядок неправильный… ➡ Ага, мы обсуждали факторы. Функция fct_reorder() позволяяет менять порядок и даже задавать функцию, вроде среднего или медианы, которая должна быть применена к каждой группе. 👁 а как убрать легенду? ➡ Легенду можно убрать добавив show.legend = FALSE в соответствующий geom_.... 4.8 Точки, джиттер (jitter), вайолинплот (violinplot), ящики с усами (boxplot), Вот другие способы показать распределение числовой переменной: iris %&gt;% ggplot(aes(Species, Petal.Length))+ geom_point() iris %&gt;% ggplot(aes(Species, Petal.Length))+ geom_jitter() iris %&gt;% ggplot(aes(Species, Petal.Length))+ geom_jitter(width = 0.3) library(&quot;ggbeeswarm&quot;) iris %&gt;% ggplot(aes(Species, Petal.Length))+ geom_quasirandom() diamonds %&gt;% ggplot(aes(cut, price))+ geom_violin() diamonds %&gt;% ggplot(aes(cut, price))+ geom_boxplot() 4.9 Фасетизация Достаточно мощным инструментом анализа данных является фасетизация, которая позволяет разбивать графики на основе какой-то переменной. diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_wrap(~cut) При этом иногда так бывает, что наличие какой-то одного значение в одном из фасетов, заставляет иметь одну и ту же шкалу для всех остальных. Это можно изменить при помощи аргумента scales: diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_wrap(~cut, scales = &quot;free&quot;) Кроме того, можно добавлять дополнительные аргументы: diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_wrap(~cut+color) Кроме того, можно создавать сетки переменных используя geom_grid(), они занимают меньше места, чем facet_wrap(): diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_grid(cut~color, scales = &quot;free&quot;) Кроме того facet_grid() позволяет делать обощающие поля, где представлены все данные по какой-то строчке или столбцу: diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_grid(cut~color, scales = &quot;free&quot;, margins = TRUE) 4.10 Визуализация комбинаций признаков 4.10.1 Потоковая Диаграмма (Sankey diagram) Один из способов визуализации отношений между признаками называется потоковая диаграмма. library(&quot;ggforce&quot;) zhadina &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/zhadina.csv&quot;) ## Parsed with column specification: ## cols( ## word_1 = col_character(), ## word_2 = col_character(), ## word_3 = col_character(), ## type = col_character(), ## n = col_double() ## ) zhadina %&gt;% gather_set_data(1:3) %&gt;% ggplot(aes(x, id = id, split = y, value = n))+ geom_parallel_sets(aes(fill = type), alpha = 0.6, axis.width = 0.5) + geom_parallel_sets_axes(axis.width = 0.5, color = &quot;lightgrey&quot;, fill = &quot;white&quot;) + geom_parallel_sets_labels(angle = 0) + theme_no_axes()+ theme(legend.position = &quot;bottom&quot;) А как поменять порядок? Снова факторы. zhadina %&gt;% gather_set_data(1:3) %&gt;% mutate(y = fct_reorder(y, n, mean)) %&gt;% ggplot(aes(x, id = id, split = y, value = n))+ geom_parallel_sets(aes(fill = type), alpha = 0.6, axis.width = 0.5) + geom_parallel_sets_axes(axis.width = 0.5, color = &quot;lightgrey&quot;, fill = &quot;white&quot;) + geom_parallel_sets_labels(angle = 0) + theme_no_axes()+ theme(legend.position = &quot;bottom&quot;) Можно донастроить, задав собственный порядок в аргументе levels функции factor(). 4.10.2 UpSet Plot Если диаграмма Sankey визуализирует попарные отношения между переменными, то график UpSet потенциально может визуализировать все возможные комбинации и является хорошей альтернативой диаграмме Вена, с большим количеством переменных (см. эту статью Лауры Эллис). library(UpSetR) movies &lt;- read.csv( system.file(&quot;extdata&quot;, &quot;movies.csv&quot;, package = &quot;UpSetR&quot;), header=TRUE, sep=&quot;;&quot; ) str(movies) ## &#39;data.frame&#39;: 3883 obs. of 21 variables: ## $ Name : Factor w/ 3883 levels &quot;...And Justice for All (1979)&quot;,..: 3576 1860 1485 3718 1179 1564 3012 3551 3364 1426 ... ## $ ReleaseDate: int 1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ... ## $ Action : int 0 0 0 0 0 1 0 0 1 1 ... ## $ Adventure : int 0 1 0 0 0 0 0 1 0 1 ... ## $ Children : int 1 1 0 0 0 0 0 1 0 0 ... ## $ Comedy : int 1 0 1 1 1 0 1 0 0 0 ... ## $ Crime : int 0 0 0 0 0 1 0 0 0 0 ... ## $ Documentary: int 0 0 0 0 0 0 0 0 0 0 ... ## $ Drama : int 0 0 0 1 0 0 0 0 0 0 ... ## $ Fantasy : int 0 1 0 0 0 0 0 0 0 0 ... ## $ Noir : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Horror : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Musical : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Mystery : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Romance : int 0 0 1 0 0 0 1 0 0 0 ... ## $ SciFi : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Thriller : int 0 0 0 0 0 1 0 0 0 1 ... ## $ War : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Western : int 0 0 0 0 0 0 0 0 0 0 ... ## $ AvgRating : num 4.15 3.2 3.02 2.73 3.01 3.88 3.41 3.01 2.66 3.54 ... ## $ Watches : int 2077 701 478 170 296 940 458 68 102 888 ... upset(movies[,3:19], nsets = 16, order.by = &quot;freq&quot;) "],
["strings.html", "5 Работа со строками 5.1 Работа со строками в R 5.2 Как получить строку? 5.3 Соединение и разделение строк 5.4 Количество символов 5.5 Сортировка 5.6 Поиск подстроки 5.7 Изменение строк 5.8 Определение языка 5.9 Расстояния между строками", " 5 Работа со строками 5.1 Работа со строками в R Для работы со строками можно использовать: базовый R пакет stringr (часть tidyverse) пакет stringi – отдельный пакет, так что не забудьте его установить: install.packages(&quot;stringi&quot;) library(tidyverse) library(stringi) Мы будем пользоваться в основном пакетами stingr и stringi, так как они в большинстве случаях удобнее. К счастью функции этих пакетов легко отличить от остальных: функции пакет stringr всегда начинаются с str_, а функции пакета stringi — c stri_. Существует cheat sheet по stringr. 5.2 Как получить строку? следите за кавычками &quot;the quick brown fox jumps over the lazy dog&quot; ## [1] &quot;the quick brown fox jumps over the lazy dog&quot; &#39;the quick brown fox jumps over the lazy dog&#39; ## [1] &quot;the quick brown fox jumps over the lazy dog&quot; &quot;the quick &#39;brown&#39; fox jumps over the lazy dog&quot; ## [1] &quot;the quick &#39;brown&#39; fox jumps over the lazy dog&quot; &#39;the quick &quot;brown&quot; fox jumps over the lazy dog&#39; ## [1] &quot;the quick \\&quot;brown\\&quot; fox jumps over the lazy dog&quot; пустая строка &quot;&quot; ## [1] &quot;&quot; &#39;&#39; ## [1] &quot;&quot; character(3) ## [1] &quot;&quot; &quot;&quot; &quot;&quot; преобразование typeof(4:7) ## [1] &quot;integer&quot; as.character(4:7) ## [1] &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; встроенные векторы letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; помните, что функции data.frame(), read.csv(), read.csv2(), read.table() из базового R всегда по-умолчанию преобразуют строки в факторы, и чтобы это предотвратить нужно использовать аргумент stringsAsFactors. Это много обсуждалось в сообществе R, можно, например, почитать про это вот этот блог пост Роджера Пенга. str(data.frame(letters[6:10], LETTERS[4:8])) ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ letters.6.10.: Factor w/ 5 levels &quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,..: 1 2 3 4 5 ## $ LETTERS.4.8. : Factor w/ 5 levels &quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,..: 1 2 3 4 5 str(data.frame(letters[6:10], LETTERS[4:8], stringsAsFactors = FALSE)) ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ letters.6.10.: chr &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; ... ## $ LETTERS.4.8. : chr &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; ... Но этом курсе мы учим использовать сразу tibble(), read_csv(), read_csv2(), read_tsv(), read_delim() из пакета readr (входит в tidyverse). Создание рандомных строк set.seed(42) stri_rand_strings(n = 10, length = 5:14) ## [1] &quot;uwHpd&quot; &quot;Wj8ehS&quot; &quot;ivFSwy7&quot; &quot;TYu8zw5V&quot; ## [5] &quot;OuRpjoOg0&quot; &quot;p0CubNR2yQ&quot; &quot;xtdycKLOm2k&quot; &quot;fAGVfylZqBGp&quot; ## [9] &quot;gE28DTCi0NV0a&quot; &quot;9MemYE55If0Cvv&quot; Перемешивает символы внутри строки stri_rand_shuffle(&quot;любя, съешь щипцы, — вздохнёт мэр, — кайф жгуч&quot;) ## [1] &quot;,цо м,пюзгу сл аиъ—в кжряд,ыщьчебэн х—штё фй&quot; stri_rand_shuffle(month.name) ## [1] &quot;aJayunr&quot; &quot;eyrbraFu&quot; &quot;achMr&quot; &quot;Aplri&quot; &quot;ayM&quot; &quot;Jnue&quot; ## [7] &quot;uJly&quot; &quot;usuAgt&quot; &quot;tpebermSe&quot; &quot;tOecrbo&quot; &quot;oeNembvr&quot; &quot;Dmceerbe&quot; Генерирует псевдорандомный текст1 stri_rand_lipsum(nparagraphs = 2) ## [1] &quot;Lorem ipsum dolor sit amet, donec sit nunc urna sed ultricies ac pharetra orci luctus iaculis, ac tincidunt cum. Neque eu semper at sociosqu hendrerit. Eu aliquet lacus, eu hendrerit donec aliquam eros. Risus nibh, quam in sit facilisi ipsum. Amet sem sed donec sed molestie scelerisque tincidunt. Nisl donec et facilisis interdum non sed dolor purus. In ipsum dignissim torquent velit nec aliquam pellentesque. Ac, adipiscing, neque et at torquent, vestibulum ullamcorper. Ad dictumst enim velit non nulla felis habitant. Egestas placerat consectetur, dictum nostra sed nec. Erat phasellus dolor libero aliquam viverra. Vestibulum leo et. Suscipit egestas in in montes, sapien gravida? Conubia purus varius ut nec feugiat.&quot; ## [2] &quot;Risus eleifend magnis neque diam, suspendisse ullamcorper nulla adipiscing malesuada massa, nisi sociosqu velit id et. Aliquam facilisis et aenean. Parturient vel ac in convallis, massa diam nibh. Nulla interdum cursus et. Natoque amet, ut praesent. Tortor ultrices a consectetur, augue natoque class faucibus? Ut sed arcu elementum magna. Dignissim ac facilisi quis ut nisl eu, massa.&quot; 5.3 Соединение и разделение строк Соединенить строки можно используя функцию str_c(), в которую, как и в функции с(), можно перечислять элементы через запятую: tibble(upper = rev(LETTERS), smaller = letters) %&gt;% mutate(merge = str_c(upper, smaller)) ## # A tibble: 26 x 3 ## upper smaller merge ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Z a Za ## 2 Y b Yb ## 3 X c Xc ## 4 W d Wd ## 5 V e Ve ## 6 U f Uf ## 7 T g Tg ## 8 S h Sh ## 9 R i Ri ## 10 Q j Qj ## # … with 16 more rows Кроме того, если хочется, можно использовать особенный разделитель, указав его в аргументе sep: tibble(upper = rev(LETTERS), smaller = letters) %&gt;% mutate(merge = str_c(upper, smaller, sep = &quot;_&quot;)) ## # A tibble: 26 x 3 ## upper smaller merge ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Z a Z_a ## 2 Y b Y_b ## 3 X c X_c ## 4 W d W_d ## 5 V e V_e ## 6 U f U_f ## 7 T g T_g ## 8 S h S_h ## 9 R i R_i ## 10 Q j Q_j ## # … with 16 more rows Аналогичным образом, для разделение строки на подстроки можно использовать функцию separate(). Это функция разносит разделенные элементы строки в соответствующие столбцы. У функции три обязательных аргумента: col — колонка, которую следует разделить, into — вектор названий новых столбец, sep — разделитель. tibble(upper = rev(LETTERS), smaller = letters) %&gt;% mutate(merge = str_c(upper, smaller, sep = &quot;_&quot;)) %&gt;% separate(col = merge, into = c(&quot;column_1&quot;, &quot;column_2&quot;), sep = &quot;_&quot;) ## # A tibble: 26 x 4 ## upper smaller column_1 column_2 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Z a Z a ## 2 Y b Y b ## 3 X c X c ## 4 W d W d ## 5 V e V e ## 6 U f U f ## 7 T g T g ## 8 S h S h ## 9 R i R i ## 10 Q j Q j ## # … with 16 more rows Кроме того, есть инструмент str_split(), которая позволяет разбивать строки на подстроки, но возвращает список. str_split(month.name, &quot;r&quot;) ## [[1]] ## [1] &quot;Janua&quot; &quot;y&quot; ## ## [[2]] ## [1] &quot;Feb&quot; &quot;ua&quot; &quot;y&quot; ## ## [[3]] ## [1] &quot;Ma&quot; &quot;ch&quot; ## ## [[4]] ## [1] &quot;Ap&quot; &quot;il&quot; ## ## [[5]] ## [1] &quot;May&quot; ## ## [[6]] ## [1] &quot;June&quot; ## ## [[7]] ## [1] &quot;July&quot; ## ## [[8]] ## [1] &quot;August&quot; ## ## [[9]] ## [1] &quot;Septembe&quot; &quot;&quot; ## ## [[10]] ## [1] &quot;Octobe&quot; &quot;&quot; ## ## [[11]] ## [1] &quot;Novembe&quot; &quot;&quot; ## ## [[12]] ## [1] &quot;Decembe&quot; &quot;&quot; 5.4 Количество символов 5.4.1 Подсчет количества символов tibble(mn = month.name) %&gt;% mutate(n_charactars = str_count(mn)) ## # A tibble: 12 x 2 ## mn n_charactars ## &lt;chr&gt; &lt;int&gt; ## 1 January 7 ## 2 February 8 ## 3 March 5 ## 4 April 5 ## 5 May 3 ## 6 June 4 ## 7 July 4 ## 8 August 6 ## 9 September 9 ## 10 October 7 ## 11 November 8 ## 12 December 8 5.4.2 Подгонка количества символов Можно обрезать строки, используя функцию str_trunc(): tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 6)) ## # A tibble: 12 x 2 ## mn mn_new ## &lt;chr&gt; &lt;chr&gt; ## 1 January Jan... ## 2 February Feb... ## 3 March March ## 4 April April ## 5 May May ## 6 June June ## 7 July July ## 8 August August ## 9 September Sep... ## 10 October Oct... ## 11 November Nov... ## 12 December Dec... Можно решить с какой стороны обрезать, используя аргумент side: tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 6, side = &quot;left&quot;)) ## # A tibble: 12 x 2 ## mn mn_new ## &lt;chr&gt; &lt;chr&gt; ## 1 January ...ary ## 2 February ...ary ## 3 March March ## 4 April April ## 5 May May ## 6 June June ## 7 July July ## 8 August August ## 9 September ...ber ## 10 October ...ber ## 11 November ...ber ## 12 December ...ber tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 6, side = &quot;center&quot;)) ## # A tibble: 12 x 2 ## mn mn_new ## &lt;chr&gt; &lt;chr&gt; ## 1 January Ja...y ## 2 February Fe...y ## 3 March March ## 4 April April ## 5 May May ## 6 June June ## 7 July July ## 8 August August ## 9 September Se...r ## 10 October Oc...r ## 11 November No...r ## 12 December De...r Можно заменить многоточие, используя аргумент ellipsis: tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 3, ellipsis = &quot;&quot;)) ## # A tibble: 12 x 2 ## mn mn_new ## &lt;chr&gt; &lt;chr&gt; ## 1 January Jan ## 2 February Feb ## 3 March Mar ## 4 April Apr ## 5 May May ## 6 June Jun ## 7 July Jul ## 8 August Aug ## 9 September Sep ## 10 October Oct ## 11 November Nov ## 12 December Dec Можно наоборот “раздуть” строку: tibble(mn = month.name) %&gt;% mutate(mn_new = str_pad(mn, 10)) ## # A tibble: 12 x 2 ## mn mn_new ## &lt;chr&gt; &lt;chr&gt; ## 1 January &quot; January&quot; ## 2 February &quot; February&quot; ## 3 March &quot; March&quot; ## 4 April &quot; April&quot; ## 5 May &quot; May&quot; ## 6 June &quot; June&quot; ## 7 July &quot; July&quot; ## 8 August &quot; August&quot; ## 9 September &quot; September&quot; ## 10 October &quot; October&quot; ## 11 November &quot; November&quot; ## 12 December &quot; December&quot; Опять же есть аргумент side: tibble(mn = month.name) %&gt;% mutate(mn_new = str_pad(mn, 10, side = &quot;right&quot;)) ## # A tibble: 12 x 2 ## mn mn_new ## &lt;chr&gt; &lt;chr&gt; ## 1 January &quot;January &quot; ## 2 February &quot;February &quot; ## 3 March &quot;March &quot; ## 4 April &quot;April &quot; ## 5 May &quot;May &quot; ## 6 June &quot;June &quot; ## 7 July &quot;July &quot; ## 8 August &quot;August &quot; ## 9 September &quot;September &quot; ## 10 October &quot;October &quot; ## 11 November &quot;November &quot; ## 12 December &quot;December &quot; Также можно выбрать, чем “раздувать строку”: tibble(mn = month.name) %&gt;% mutate(mn_new = str_pad(mn, 10, pad = &quot;.&quot;)) ## # A tibble: 12 x 2 ## mn mn_new ## &lt;chr&gt; &lt;chr&gt; ## 1 January ...January ## 2 February ..February ## 3 March .....March ## 4 April .....April ## 5 May .......May ## 6 June ......June ## 7 July ......July ## 8 August ....August ## 9 September .September ## 10 October ...October ## 11 November ..November ## 12 December ..December На Pudding вышла статья про английские пабы. Здесь лежит немного обработанный датасет, которые они использовали. Визуализируйте 40 самых частотоных названий пабов в Великобритании, отложив по оси x количество символов, а по оси y – количество баров с таким названием. 📋 список подсказок ➡ 👁 Датасет скачался, что дальше? ➡ Перво-наперво следует создать переменную, в которой бы хранилось количество каждого из баров. 👁 А как посчитать количество баров? ➡ Это можно сделать при помощи функции count(). 👁 Бары пересчитали, что дальше? ➡ Теперь нужно создать новую переменную, где бы хранилась информация о количестве символов. 👁 Все переменные есть, теперь рисуем? ➡ Не совсем. Перед тем как рисовать нужно отфильтровать 50 самых популярных. 👁 Так, все готово, а какие geom_()? ➡ На графике geom_point() и geom_text_repel() из пакета ggrepel. 👁 А-а-а-а! could not find function \"geom_text_repel\" ➡ А вы включили библиотеку ggrepel? Если не включили, то функция, естественно будет недоступна. 👁 А-а-а-а! geom_text_repel requires the following missing aesthetics: label\" ➡ Все, как написала программа: чтобы писать какой-то текст в функции aes() нужно добавить аргумент label = pub_name. Иначе откуда он узнает, что ему писать? 👁 Фуф! Все готово! ➡ А оси подписаны? А заголовок? А подпись про источник данных? 5.5 Сортировка Для сортировки существует базовая функция sort() и функция из stringr str_sort(): unsorted_latin &lt;- c(&quot;I&quot;, &quot;♥&quot;, &quot;N&quot;, &quot;Y&quot;) sort(unsorted_latin) ## [1] &quot;♥&quot; &quot;I&quot; &quot;N&quot; &quot;Y&quot; str_sort(unsorted_latin) ## [1] &quot;♥&quot; &quot;I&quot; &quot;N&quot; &quot;Y&quot; str_sort(unsorted_latin, locale = &quot;lt&quot;) ## [1] &quot;♥&quot; &quot;I&quot; &quot;Y&quot; &quot;N&quot; unsorted_cyrillic &lt;- c(&quot;я&quot;, &quot;i&quot;, &quot;ж&quot;) str_sort(unsorted_cyrillic) ## [1] &quot;i&quot; &quot;ж&quot; &quot;я&quot; str_sort(unsorted_cyrillic, locale = &quot;ru_UA&quot;) ## [1] &quot;ж&quot; &quot;я&quot; &quot;i&quot; Список локалей на копмьютере можно посмотреть командой stringi::stri_locale_list(). Список всех локалей вообще приведен на этой странице. Еще полезные команды: stringi::stri_locale_info и stringi::stri_locale_set. Не углубляясь в разнообразие алгоритмов сортировки, отмечу, что алгоритм по-умолчанию хуже работает с большими данными: set.seed(42) huge &lt;- sample(letters, 1e7, replace = TRUE) head(huge) ## [1] &quot;q&quot; &quot;e&quot; &quot;a&quot; &quot;y&quot; &quot;j&quot; &quot;d&quot; system.time( sort(huge) ) ## user system elapsed ## 6.623 0.024 6.649 system.time( sort(huge, method = &quot;radix&quot;) ) ## user system elapsed ## 0.250 0.016 0.267 system.time( str_sort(huge) ) ## user system elapsed ## 5.914 0.064 5.978 huge_tbl &lt;- tibble(huge) system.time( huge_tbl %&gt;% arrange(huge) ) ## user system elapsed ## 3.441 0.072 3.514 Предварительный вывод: для больших данных – sort(..., method = \"radix\"). 5.6 Поиск подстроки Можно использовать функцию str_detect(): tibble(mn = month.name) %&gt;% mutate(has_r = str_detect(mn, &quot;r&quot;)) ## # A tibble: 12 x 2 ## mn has_r ## &lt;chr&gt; &lt;lgl&gt; ## 1 January TRUE ## 2 February TRUE ## 3 March TRUE ## 4 April TRUE ## 5 May FALSE ## 6 June FALSE ## 7 July FALSE ## 8 August FALSE ## 9 September TRUE ## 10 October TRUE ## 11 November TRUE ## 12 December TRUE Кроме того, существует функция, которая возвращает индексы, а не значения TRUE/FALSE: tibble(mn = month.name) %&gt;% slice(str_which(month.name, &quot;r&quot;)) ## # A tibble: 8 x 1 ## mn ## &lt;chr&gt; ## 1 January ## 2 February ## 3 March ## 4 April ## 5 September ## 6 October ## 7 November ## 8 December Также можно посчитать количество вхождений какой-то подстроки: tibble(mn = month.name) %&gt;% mutate(has_r = str_count(mn, &quot;r&quot;)) ## # A tibble: 12 x 2 ## mn has_r ## &lt;chr&gt; &lt;int&gt; ## 1 January 1 ## 2 February 2 ## 3 March 1 ## 4 April 1 ## 5 May 0 ## 6 June 0 ## 7 July 0 ## 8 August 0 ## 9 September 1 ## 10 October 1 ## 11 November 1 ## 12 December 1 5.7 Изменение строк 5.7.1 Изменение регистра latin &lt;- &quot;tHe QuIcK BrOwN fOx JuMpS OvEr ThE lAzY dOg&quot; cyrillic &lt;- &quot;лЮбЯ, сЪеШь ЩиПцЫ, — вЗдОхНёТ мЭр, — кАйФ жГуЧ&quot; str_to_upper(latin) ## [1] &quot;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&quot; str_to_lower(cyrillic) ## [1] &quot;любя, съешь щипцы, — вздохнёт мэр, — кайф жгуч&quot; str_to_title(latin) ## [1] &quot;The Quick Brown Fox Jumps Over The Lazy Dog&quot; 5.7.2 Выделение подстроки Подстроку в строке можно выделить двумя способами: по индексам функцией str_sub(), и по подстроке функцией str_png(). tibble(mn = month.name) %&gt;% mutate(mutate = str_sub(mn, start = 1, end = 2)) ## # A tibble: 12 x 2 ## mn mutate ## &lt;chr&gt; &lt;chr&gt; ## 1 January Ja ## 2 February Fe ## 3 March Ma ## 4 April Ap ## 5 May Ma ## 6 June Ju ## 7 July Ju ## 8 August Au ## 9 September Se ## 10 October Oc ## 11 November No ## 12 December De tibble(mn = month.name) %&gt;% mutate(mutate = str_extract(mn, &quot;r&quot;)) ## # A tibble: 12 x 2 ## mn mutate ## &lt;chr&gt; &lt;chr&gt; ## 1 January r ## 2 February r ## 3 March r ## 4 April r ## 5 May &lt;NA&gt; ## 6 June &lt;NA&gt; ## 7 July &lt;NA&gt; ## 8 August &lt;NA&gt; ## 9 September r ## 10 October r ## 11 November r ## 12 December r По умолчанию функция str_extract() возвращает первое вхождение подстроки, соответствующей шаблону. Также существует функция str_extract_all(), которая возвращает все вхождения подстрок, соответствующих шаблону, однако возвращает объект типа список. str_extract_all(month.name, &quot;r&quot;) ## [[1]] ## [1] &quot;r&quot; ## ## [[2]] ## [1] &quot;r&quot; &quot;r&quot; ## ## [[3]] ## [1] &quot;r&quot; ## ## [[4]] ## [1] &quot;r&quot; ## ## [[5]] ## character(0) ## ## [[6]] ## character(0) ## ## [[7]] ## character(0) ## ## [[8]] ## character(0) ## ## [[9]] ## [1] &quot;r&quot; ## ## [[10]] ## [1] &quot;r&quot; ## ## [[11]] ## [1] &quot;r&quot; ## ## [[12]] ## [1] &quot;r&quot; 5.7.3 Замена подстроки Существует функция str_replace(), которая позволяет заменить одну подстроку в строке на другую: tibble(mn = month.name) %&gt;% mutate(mutate = str_replace(mn, &quot;r&quot;, &quot;R&quot;)) ## # A tibble: 12 x 2 ## mn mutate ## &lt;chr&gt; &lt;chr&gt; ## 1 January JanuaRy ## 2 February FebRuary ## 3 March MaRch ## 4 April ApRil ## 5 May May ## 6 June June ## 7 July July ## 8 August August ## 9 September SeptembeR ## 10 October OctobeR ## 11 November NovembeR ## 12 December DecembeR Как и другие функции str_replace() делает лишь одну замену, чтобы заменить все вхождения подстроки следует использовать функцию str_replace_all(): tibble(mn = month.name) %&gt;% mutate(mutate = str_replace_all(mn, &quot;r&quot;, &quot;R&quot;)) ## # A tibble: 12 x 2 ## mn mutate ## &lt;chr&gt; &lt;chr&gt; ## 1 January JanuaRy ## 2 February FebRuaRy ## 3 March MaRch ## 4 April ApRil ## 5 May May ## 6 June June ## 7 July July ## 8 August August ## 9 September SeptembeR ## 10 October OctobeR ## 11 November NovembeR ## 12 December DecembeR 5.7.4 Удаление подстроки Для удаления подстроки на основе шаблона, используется функция str_remove() и str_remove_all() tibble(month.name) %&gt;% mutate(mutate = str_remove(month.name, &quot;r&quot;)) ## # A tibble: 12 x 2 ## month.name mutate ## &lt;chr&gt; &lt;chr&gt; ## 1 January Januay ## 2 February Febuary ## 3 March Mach ## 4 April Apil ## 5 May May ## 6 June June ## 7 July July ## 8 August August ## 9 September Septembe ## 10 October Octobe ## 11 November Novembe ## 12 December Decembe tibble(month.name) %&gt;% mutate(mutate = str_remove_all(month.name, &quot;r&quot;)) ## # A tibble: 12 x 2 ## month.name mutate ## &lt;chr&gt; &lt;chr&gt; ## 1 January Januay ## 2 February Febuay ## 3 March Mach ## 4 April Apil ## 5 May May ## 6 June June ## 7 July July ## 8 August August ## 9 September Septembe ## 10 October Octobe ## 11 November Novembe ## 12 December Decembe 5.7.5 Транслитерация строк В пакете stringi сууществует достаточно много методов транслитераций строк, которые можно вывести командой stri_trans_list(). Вот пример использования некоторых из них: stri_trans_general(&quot;stringi&quot;, &quot;latin-cyrillic&quot;) ## [1] &quot;стринги&quot; stri_trans_general(&quot;сырники&quot;, &quot;cyrillic-latin&quot;) ## [1] &quot;syrniki&quot; stri_trans_general(&quot;stringi&quot;, &quot;latin-greek&quot;) ## [1] &quot;στριγγι&quot; stri_trans_general(&quot;stringi&quot;, &quot;latin-armenian&quot;) ## [1] &quot;ստրինգի&quot; Вот два датасета: список городов России частотный словарь русского языка [Шаров, Ляшевская 2011] Определите сколько городов называется обычным словом русского языка (например, город Орёл)? Не забудьте поменять ё на е. ```{r, cache=TRUE, include=Feval=FALSE, echoead_csv(“https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/cities_of_russia.csv”) %&gt;% mutate(city = str_to_lower(city), city = str_replace_all(city, “ё”, “е”)) -&gt; cities dict &lt;- read_tsv(“https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/freq_dict_2011.csv”) %&gt;% inner_join(cities, by = c(“lemma” = “city”)) %&gt;% count(town) # 66 &lt;details&gt; &lt;summary&gt; 📋 список подсказок ➡ &lt;/summary&gt; &lt;details&gt; &lt;summary&gt; 👁 Датасеты скачались, что дальше? ➡ &lt;/summary&gt; Надо их преобразовать к нужному виду и объединить. &lt;br&gt; &lt;/details&gt; &lt;details&gt; &lt;summary&gt; 👁 А как их соединить? Что у них общего? ➡ &lt;/summary&gt; В одном датасете есть переменная `city`, в другом -- переменная `lemma`. Все города начинаются с большой буквы, все леммы с маленькой буквы. Я бы уменьшил букву в датасете с городами, сделал бы новый столбец в датасете с городами (например, `town`), соединил бы датасеты и посчитал бы сколько в результирующем датасете значений `town`. &lt;br&gt; &lt;/details&gt; &lt;details&gt; &lt;summary&gt; 👁 А как соеднить? ➡ &lt;/summary&gt; Я бы использовал `dict %&gt;% ... %&gt;% inner_join(cities)`. Если в датасетах разные названия столбцов, то следует указывать какие столбцы, каким соответствуют:`dict %&gt;% ... %&gt;% inner_join(cities, by = c(&quot;lemma&quot; = &quot;city&quot;))` &lt;br&gt; &lt;/details&gt; &lt;details&gt; &lt;summary&gt; 👁 Соединилось вроде... А как посчитать? ➡ &lt;/summary&gt; Я бы, как обычно, использовал функцию `count()`. &lt;br&gt; &lt;/details&gt; &lt;/details&gt; ## Регулярные выражения Большинство функций из раздела об операциях над векторами (`str_detect()`, `str_extract()`, `str_remove()` и т. п.) имеют следующую структуру: * строка, с которой работает функция * образец (pattern) Дальше мы будем использовать функцию `str_view_all()`, которая позволяет показывать, выделенное образцом в исходной строке. ```r str_view_all(&quot;Я всегда путаю с и c&quot;, &quot;c&quot;) # я ищу латинскую c 5.7.6 Экранирование метасимволов a &lt;- &quot;Всем известно, что 4$\\\\2 + 3$ * 5 = 17$? Да? Ну хорошо (а то я не был уверен). [|}^{|]&quot; str_view_all(a, &quot;$&quot;) str_view_all(a, &quot;\\\\$&quot;) str_view_all(a, &quot;\\\\.&quot;) str_view_all(a, &quot;\\\\*&quot;) str_view_all(a, &quot;\\\\+&quot;) str_view_all(a, &quot;\\\\?&quot;) str_view_all(a, &quot;\\\\(&quot;) str_view_all(a, &quot;\\\\)&quot;) str_view_all(a, &quot;\\\\|&quot;) str_view_all(a, &quot;\\\\^&quot;) str_view_all(a, &quot;\\\\[&quot;) str_view_all(a, &quot;\\\\]&quot;) str_view_all(a, &quot;\\\\{&quot;) str_view_all(a, &quot;\\\\}&quot;) str_view_all(a, &quot;\\\\\\\\&quot;) 5.7.7 Классы знаков \\\\d – цифры. \\\\D – не цифры. str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\d&quot;) str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\D&quot;) \\\\s – пробелы. \\\\S – не пробелы. str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\s&quot;) str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\S&quot;) \\\\w – не пробелы и не знаки препинания. \\\\W – пробелы и знаки препинания. str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\w&quot;) str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\W&quot;) произвольная группа символов и обратная к ней str_view_all(&quot;Умей мечтать, не став рабом мечтанья&quot;, &quot;[оауиыэёеяю]&quot;) str_view_all(&quot;И мыслить, мысли не обожествив&quot;, &quot;[^оауиыэёеяю]&quot;) встроенные группы символов str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;[0-9]&quot;) str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;[а-я]&quot;) str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;[А-Я]&quot;) str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;[А-я]&quot;) str_view_all(&quot;The quick brown Fox jumps over the lazy Dog&quot;, &quot;[a-z]&quot;) str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;[^0-9]&quot;) выбор из нескольких групп str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;лар|рал|арл&quot;) произвольный символ str_view_all(&quot;Везет Сенька Саньку с Сонькой на санках. Санки скок, Сеньку с ног, Соньку в лоб, все — в сугроб&quot;, &quot;[Сс].н&quot;) знак начала и конца строки str_view_all(&quot;от топота копыт пыль по полю летит.&quot;, &quot;^о&quot;) str_view_all(&quot;У ежа — ежата, у ужа — ужата&quot;, &quot;жата$&quot;) есть еще другие группы и другие обозначения уже приведенных групп, см. ?regex 5.7.8 Квантификация ? – ноль или один раз str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;еее?&quot;) * – ноль и более раз str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;ее*&quot;) + – один и более раз str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;е+&quot;) {n} – n раз str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;е{2}&quot;) {n,} – n раз и более str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;е{1,}&quot;) {n,m} – от n до m. Отсутствие пробела важно: {1,2} – правильно, {1,␣2} – неправильно. str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;е{2,3}&quot;) группировка символов str_view_all(&quot;Пушкиновед, Лермонтовед, Лермонтововед&quot;, &quot;(ов)+&quot;) str_view_all(&quot;беловатый, розоватый, розововатый&quot;, &quot;(ов)+&quot;) жадный vs. нежадный алоритмы str_view_all(&quot;Пушкиновед, Лермонтовед, Лермонтововед&quot;, &quot;в.*ед&quot;) str_view_all(&quot;Пушкиновед, Лермонтовед, Лермонтововед&quot;, &quot;в.*?ед&quot;) 5.7.9 Позиционная проверка (look arounds) Позиционная проверка – выглядит достаточно непоследовательно даже в свете остальных регулярных выражений. Давайте найдем все а перед р: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;а(?=р)&quot;) А теперь все а перед р или л: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;а(?=[рл])&quot;) Давайте найдем все а после р str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;(?&lt;=р)а&quot;) А теперь все а после р или л: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;(?&lt;=[рл])а&quot;) Также у этих выражений есть формы с отрицанием. Давайте найдем все р не перед а: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;р(?!а)&quot;) А теперь все р не после а: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;(?&lt;!а)р&quot;) Запомнить с ходу это достаточно сложно, так что подсматривайте сюда: Вот отсюда можно скачать файл с текстом стихотворения Н. Заболоцкого “Меркнут знаки задиака”. Посчитайте долю женских (ударение падает на предпоследний слог рифмующихся слов) и мужских (ударение падает на последний слог рифмующихся слов) рифм в стихотворении. 📋 список подсказок ➡ 👁 Датасеты скачивается с ошибкой, почему? ➡ Дело в том, что исходный файл в формате .txt, а не .csv. Его нужно скачивать, например, командой read_lines() 👁 Ошибка: ...applied to an object of class \"character\" ➡ Скачав файл Вы получили вектор со строками, где каждая элимент вектора – строка стихотворения. Создайте tibble(), тогда можно будет применять стандартные инструменты tidyverse. 👁 Хорошо, tibble() создан, что дальше? ➡ Дальше нужно создать переменную, из которой будет понятно, мужская в каждой строке рифма, или женская. 👁 А как определить, какая рифма? Нужно с словарем сравнивать? ➡ Формально говоря, определять рифму можно по косвенным признакам. Все стихотворение написано четырехстопным хореем, значит в нем либо 7, либо 8 слогов. Значит, посчитав количество слогов, мы поймем, какая перед нами рифма. 👁 А как посчитать гласные? ➡ Нужно написать регулярное выражение… вроде бы это тема нашего занятия… 👁 Гласные посчитаны. А что дальше? ➡ Ну теперь нужно посчитать, сколько каких длин (в количестве слогов) бывает в стихотворении. Это можно сделать при помощи функции count(). 👁 А почему у меня есть строки длины 0 слогов ➡ Ну, видимо, в стихотворении были пустые строки. Они использовались для разделения строф. 👁 А почему у меня есть строки длины 6 слогов ➡ Ну, видимо, Вы написали регулярное выражение, которое не учитывает, что гласные буквы могут быть еще и в начале строки, а значит написаны с большой буквы. В ходе анализа данных чаще всего бороться со строками и регулярными выражениями приходится в процессе обработки неаккуратнособранных анкет. Предлагаю обработать переменные sex и age такой вот неудачно собранной анкеты и построить следующий график: 📋 список подсказок ➡ 👁 А что это за geom_...()? ➡ Это geom_dotplot() с аргументом method = \"histodot\" и с удаленной осью y при помощи команды scale_y_continuous(NULL, breaks = NULL) 👁 Почему на графике рисутеся каждое значение возраста? ➡ Если Вы все правильно преобразовали, должно помочь преобразование строковой переменной age в числовую при помощи функции as.integer(). 5.8 Определение языка Для определения языка существует два пакета cld2 (вероятностный) и cld3 (нейросеть). udhr_24 &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/article_24_from_UDHR.csv&quot;) ## Parsed with column specification: ## cols( ## article_text = col_character() ## ) udhr_24 ## # A tibble: 6 x 1 ## article_text ## &lt;chr&gt; ## 1 Каждый человек имеет право на отдых и досуг, включая право на разумное ограни… ## 2 Everyone has the right to rest and leisure, including reasonable limitation o… ## 3 Toute personne a droit au repos et aux loisirs et notamment à une limitation … ## 4 Toda persona tiene derecho al descanso, al disfrute del tiempo libre, a una l… ## 5 لكلِّ شخص حقٌّ في الراحة وأوقات الفراغ، وخصوصًا في تحديد معقول لساعات العمل و… ## 6 人人有享有休息和闲暇的权利，包括工作时间有合理限制和定期给薪休假的权利。 cld2::detect_language(udhr_24$article_text) ## [1] &quot;ru&quot; &quot;en&quot; &quot;fr&quot; &quot;es&quot; &quot;ar&quot; &quot;zh&quot; cld2::detect_language(udhr_24$article_text, lang_code = FALSE) ## [1] &quot;RUSSIAN&quot; &quot;ENGLISH&quot; &quot;FRENCH&quot; &quot;SPANISH&quot; &quot;ARABIC&quot; &quot;CHINESE&quot; cld3::detect_language(udhr_24$article_text) ## [1] &quot;ru&quot; &quot;en&quot; &quot;fr&quot; &quot;es&quot; &quot;ar&quot; &quot;zh&quot; cld2::detect_language(&quot;Ты женат? Говорите ли по-английски?&quot;) ## [1] &quot;bg&quot; cld3::detect_language(&quot;Ты женат? Говорите ли по-английски?&quot;) ## [1] NA cld2::detect_language(&quot;Варкалось. Хливкие шорьки пырялись по наве, и хрюкотали зелюки, как мюмзики в мове.&quot;) ## [1] &quot;ru&quot; cld3::detect_language(&quot;Варкалось. Хливкие шорьки пырялись по наве, и хрюкотали зелюки, как мюмзики в мове.&quot;) ## [1] &quot;ru&quot; cld2::detect_language(&quot;Варчилось… Хлив&#39;язкі тхурки викрули, свербчись навкрузі, жасумновілі худоки гривіли зехряки в чузі.&quot;) ## [1] &quot;uk&quot; cld3::detect_language(&quot;Варчилось… Хлив&#39;язкі тхурки викрули, свербчись навкрузі, жасумновілі худоки гривіли зехряки в чузі.&quot;) ## [1] &quot;uk&quot; cld2::detect_language_mixed(&quot;Многие в нашей команде OpenDataScience занимаются state-of-the-art технологиями машинного обучения: DL-фреймворками, байесовскими методами машинного обучения, вероятностным программированием и не только.&quot;) ## $classificaton ## language code latin proportion ## 1 RUSSIAN ru FALSE 0.87 ## 2 ENGLISH en TRUE 0.11 ## 3 UNKNOWN un TRUE 0.00 ## ## $bytes ## [1] 353 ## ## $reliabale ## [1] TRUE cld3::detect_language_mixed(&quot;Многие в нашей команде OpenDataScience занимаются state-of-the-art технологиями машинного обучения: DL-фреймворками, байесовскими методами машинного обучения, вероятностным программированием и не только.&quot;) ## language probability reliable proportion ## 1 ru 0.9983915 TRUE 0.88951844 ## 2 en 0.9992564 TRUE 0.05099150 ## 3 sr 0.4266235 FALSE 0.04815864 5.9 Расстояния между строками Существует много разных метрик для измерения расстояния между строками (см. ?`stringdist-metrics`), в примерах используется расстояние Дамерау — Левенштейна. Данное расстояние получается при подсчете количества операций, которые нужно сделать, чтобы перевести одну строку в другую. вставка ab → aNb удаление aOb → ab замена символа aOb → aNb перестановка символов ab → ba library(stringdist) stringdist(&quot;корова&quot;,&quot;корова&quot;) ## [1] 0 stringdist(&quot;коровы&quot;, c(&quot;курица&quot;, &quot;бык&quot;, &quot;утка&quot;, &quot;корова&quot;, &quot;осел&quot;)) ## [1] 4 6 6 1 5 amatch(c(&quot;быки&quot;, &quot;коровы&quot;), c(&quot;курица&quot;, &quot;бык&quot;, &quot;утка&quot;, &quot;корова&quot;, &quot;осел&quot;), maxDist = 2) ## [1] 2 4 Lorem ipsum — классический текст-заполнитель на основе трактата Марка Туллия Цицерона “О пределах добра и зла”. Его используют, чтобы посмотреть, как страница смотриться, когда заполнена текстом↩︎ "],
["lists.html", "6 Работа со списками 6.1 Что такое списки? 6.2 Пакет purrr", " 6 Работа со списками library(tidyverse) 6.1 Что такое списки? Мы обсуждали в разделе @ref{list} тип данных список, и все особенности их синтаксиса: x &lt;- list(m = &quot;a&quot;, n = c(2, 4), o = c(&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;)) x ## $m ## [1] &quot;a&quot; ## ## $n ## [1] 2 4 ## ## $o ## [1] &quot;blue&quot; &quot;green&quot; &quot;red&quot; x$m ## [1] &quot;a&quot; x[1] ## $m ## [1] &quot;a&quot; x[[2]] ## [1] 2 4 x[[2]][2] ## [1] 4 Списки вне R обычно хранят в файлах типа .json (по-английски говорят с ударением на первый слог, а вот по-русски прижился вариант с ударением на второй слог: джейсо́н) или .xml. 6.1.1 Превращение JSON в список и обратно Самое важное, что нужно знать, про .json, это то, что там могут хранится: пары ключ и значение, заключенные в фигурные скобки {\"ключ\":\"значение\"} упорядочные множества значений, заключенные в квадратные скобки [\"значение_1\",\"значение_2\",...] некоторые другие типы данных Чтение и запись .json файлов осуществляется при помощи пакета jsonlite (не входит в tidyverse). Для примера скачаем датасет 30 героев Игры престолов, который Дж. Р. Р. Мартин достал с ресурса An API of Ice And Fire. got_chars &lt;- jsonlite::read_json(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/got_chars.json&quot;) got_chars[1] ## [[1]] ## [[1]]$url ## [1] &quot;https://www.anapioficeandfire.com/api/characters/1022&quot; ## ## [[1]]$id ## [1] 1022 ## ## [[1]]$name ## [1] &quot;Theon Greyjoy&quot; ## ## [[1]]$gender ## [1] &quot;Male&quot; ## ## [[1]]$culture ## [1] &quot;Ironborn&quot; ## ## [[1]]$born ## [1] &quot;In 278 AC or 279 AC, at Pyke&quot; ## ## [[1]]$died ## [1] &quot;&quot; ## ## [[1]]$alive ## [1] TRUE ## ## [[1]]$titles ## [[1]]$titles[[1]] ## [1] &quot;Prince of Winterfell&quot; ## ## [[1]]$titles[[2]] ## [1] &quot;Captain of Sea Bitch&quot; ## ## [[1]]$titles[[3]] ## [1] &quot;Lord of the Iron Islands (by law of the green lands)&quot; ## ## ## [[1]]$aliases ## [[1]]$aliases[[1]] ## [1] &quot;Prince of Fools&quot; ## ## [[1]]$aliases[[2]] ## [1] &quot;Theon Turncloak&quot; ## ## [[1]]$aliases[[3]] ## [1] &quot;Reek&quot; ## ## [[1]]$aliases[[4]] ## [1] &quot;Theon Kinslayer&quot; ## ## ## [[1]]$father ## [1] &quot;&quot; ## ## [[1]]$mother ## [1] &quot;&quot; ## ## [[1]]$spouse ## [1] &quot;&quot; ## ## [[1]]$allegiances ## [1] &quot;House Greyjoy of Pyke&quot; ## ## [[1]]$books ## [[1]]$books[[1]] ## [1] &quot;A Game of Thrones&quot; ## ## [[1]]$books[[2]] ## [1] &quot;A Storm of Swords&quot; ## ## [[1]]$books[[3]] ## [1] &quot;A Feast for Crows&quot; ## ## ## [[1]]$povBooks ## [[1]]$povBooks[[1]] ## [1] &quot;A Clash of Kings&quot; ## ## [[1]]$povBooks[[2]] ## [1] &quot;A Dance with Dragons&quot; ## ## ## [[1]]$tvSeries ## [[1]]$tvSeries[[1]] ## [1] &quot;Season 1&quot; ## ## [[1]]$tvSeries[[2]] ## [1] &quot;Season 2&quot; ## ## [[1]]$tvSeries[[3]] ## [1] &quot;Season 3&quot; ## ## [[1]]$tvSeries[[4]] ## [1] &quot;Season 4&quot; ## ## [[1]]$tvSeries[[5]] ## [1] &quot;Season 5&quot; ## ## [[1]]$tvSeries[[6]] ## [1] &quot;Season 6&quot; ## ## ## [[1]]$playedBy ## [1] &quot;Alfie Allen&quot; Так как jsonlite конфликтует в одной функции с tidyverse, я не загружаю библиотеку полностью при помощи команды library(jsonlite), а обращаюсь к функциям пакета при помощи выражения jsonlite::...(). Пакет jsonlite позволяет записывать .json файлы при помощи функции write_json(): jsonlite::write_json(got_chars, &quot;got_chars.json&quot;, auto_unbox = TRUE) # аргумент auto_unbox позволяет сохранять структуру, которую мы видим в R 6.1.2 Превращение .xml в список и обратно Самое важное, что нужно знать, про .xml, это то, что этот формат представляет собой набор некоторых сущностей, которые кодируются при помощи двух тегов: открывающего &lt;...&gt; и закрывающего &lt;/...&gt;. &lt;blablabla&gt;Hello, world!&lt;/blablabla&gt; Набор сущностей может быть любым, а главное, нет фиксированного набора сущностей — пользователи могут сочинять свои стандарты, используя .xml. Кроме того, у сущностей, могут быть свои атрибуты, которые перечисляются в открывающем теге: &lt;ingredient amount=&quot;3&quot; unit=&quot;стакан&quot;&gt;Мука&lt;/ingredient&gt; &lt;ingredient amount=&quot;0.25&quot; unit=&quot;грамм&quot;&gt;Дрожжи&lt;/ingredient&gt; &lt;ingredient amount=&quot;1.5&quot; unit=&quot;стакан&quot;&gt;Тёплая вода&lt;/ingredient&gt; Чтение и запись .xml файла осущетсвляется при помощи функций read_xml() и write_xml() из пакета xml2: library(&quot;xml2&quot;) xml_example &lt;- read_xml(&#39;&lt;body&gt; &lt;ingredient amount=&quot;3&quot; unit=&quot;стакан&quot;&gt;Мука&lt;/ingredient&gt; &lt;ingredient amount=&quot;0.25&quot; unit=&quot;грамм&quot;&gt;Дрожжи&lt;/ingredient&gt; &lt;ingredient amount=&quot;1.5&quot; unit=&quot;стакан&quot;&gt;Тёплая вода&lt;/ingredient&gt; &lt;/body&gt;&#39;) xml_example ## {xml_document} ## &lt;body&gt; ## [1] &lt;ingredient amount=&quot;3&quot; unit=&quot;стакан&quot;&gt;Мука&lt;/ingredient&gt; ## [2] &lt;ingredient amount=&quot;0.25&quot; unit=&quot;грамм&quot;&gt;Дрожжи&lt;/ingredient&gt; ## [3] &lt;ingredient amount=&quot;1.5&quot; unit=&quot;стакан&quot;&gt;Тёплая вода&lt;/ingredient&gt; write_xml(xml_example, &quot;path/to/the/file.xml&quot;) Чтобы избавиться от тегов и превратить прочитанное в список используется команда xml_example &lt;- as_list(xml_example) xml_example ## $body ## $body$ingredient ## $body$ingredient[[1]] ## [1] &quot;Мука&quot; ## ## attr(,&quot;amount&quot;) ## [1] &quot;3&quot; ## attr(,&quot;unit&quot;) ## [1] &quot;стакан&quot; ## ## $body$ingredient ## $body$ingredient[[1]] ## [1] &quot;Дрожжи&quot; ## ## attr(,&quot;amount&quot;) ## [1] &quot;0.25&quot; ## attr(,&quot;unit&quot;) ## [1] &quot;грамм&quot; ## ## $body$ingredient ## $body$ingredient[[1]] ## [1] &quot;Тёплая вода&quot; ## ## attr(,&quot;amount&quot;) ## [1] &quot;1.5&quot; ## attr(,&quot;unit&quot;) ## [1] &quot;стакан&quot; Теперь полученная переменная уже является списком: xml_example$body[[2]] ## [[1]] ## [1] &quot;Дрожжи&quot; ## ## attr(,&quot;amount&quot;) ## [1] &quot;0.25&quot; ## attr(,&quot;unit&quot;) ## [1] &quot;грамм&quot; Здесь также нужно отметить, некоторое важное отличие .xml и .json, которое видно в рассматриваемом примере: атрибуты, которые прописываются в открывающем теге, передаются и в список в R. Функция attributes() возвращает список атрибутов и их значений: xml_example$body[[2]] %&gt;% attributes() ## $amount ## [1] &quot;0.25&quot; ## ## $unit ## [1] &quot;грамм&quot; Если нужен конкретный аттрибут, то нужно использовать функцию attr(): xml_example$body[[2]] %&gt;% attr(&quot;amount&quot;) ## [1] &quot;0.25&quot; Также на данном примере видна самая большая проблема при работе с .xml: в нашем списке есть три узла под названием ingredient, так что хоть эти узлы и имеют имя, к ним все равно нужно обращаться по индексу. 6.1.3 Просмотр списков в R Просмоторщик списков встроен в RStudio. Его можно увидеть, если ткнуть в объект в R или написать команду View(got_chars). Альтернативой может стать функция jsonedit() из пакета listviewer. Кроме того, что-то можно попробовать выяснить, используя функцию str(). str(got_chars[1]) ## List of 1 ## $ :List of 18 ## ..$ url : chr &quot;https://www.anapioficeandfire.com/api/characters/1022&quot; ## ..$ id : int 1022 ## ..$ name : chr &quot;Theon Greyjoy&quot; ## ..$ gender : chr &quot;Male&quot; ## ..$ culture : chr &quot;Ironborn&quot; ## ..$ born : chr &quot;In 278 AC or 279 AC, at Pyke&quot; ## ..$ died : chr &quot;&quot; ## ..$ alive : logi TRUE ## ..$ titles :List of 3 ## .. ..$ : chr &quot;Prince of Winterfell&quot; ## .. ..$ : chr &quot;Captain of Sea Bitch&quot; ## .. ..$ : chr &quot;Lord of the Iron Islands (by law of the green lands)&quot; ## ..$ aliases :List of 4 ## .. ..$ : chr &quot;Prince of Fools&quot; ## .. ..$ : chr &quot;Theon Turncloak&quot; ## .. ..$ : chr &quot;Reek&quot; ## .. ..$ : chr &quot;Theon Kinslayer&quot; ## ..$ father : chr &quot;&quot; ## ..$ mother : chr &quot;&quot; ## ..$ spouse : chr &quot;&quot; ## ..$ allegiances: chr &quot;House Greyjoy of Pyke&quot; ## ..$ books :List of 3 ## .. ..$ : chr &quot;A Game of Thrones&quot; ## .. ..$ : chr &quot;A Storm of Swords&quot; ## .. ..$ : chr &quot;A Feast for Crows&quot; ## ..$ povBooks :List of 2 ## .. ..$ : chr &quot;A Clash of Kings&quot; ## .. ..$ : chr &quot;A Dance with Dragons&quot; ## ..$ tvSeries :List of 6 ## .. ..$ : chr &quot;Season 1&quot; ## .. ..$ : chr &quot;Season 2&quot; ## .. ..$ : chr &quot;Season 3&quot; ## .. ..$ : chr &quot;Season 4&quot; ## .. ..$ : chr &quot;Season 5&quot; ## .. ..$ : chr &quot;Season 6&quot; ## ..$ playedBy : chr &quot;Alfie Allen&quot; str(got_chars[1], max.level = 2) ## List of 1 ## $ :List of 18 ## ..$ url : chr &quot;https://www.anapioficeandfire.com/api/characters/1022&quot; ## ..$ id : int 1022 ## ..$ name : chr &quot;Theon Greyjoy&quot; ## ..$ gender : chr &quot;Male&quot; ## ..$ culture : chr &quot;Ironborn&quot; ## ..$ born : chr &quot;In 278 AC or 279 AC, at Pyke&quot; ## ..$ died : chr &quot;&quot; ## ..$ alive : logi TRUE ## ..$ titles :List of 3 ## ..$ aliases :List of 4 ## ..$ father : chr &quot;&quot; ## ..$ mother : chr &quot;&quot; ## ..$ spouse : chr &quot;&quot; ## ..$ allegiances: chr &quot;House Greyjoy of Pyke&quot; ## ..$ books :List of 3 ## ..$ povBooks :List of 2 ## ..$ tvSeries :List of 6 ## ..$ playedBy : chr &quot;Alfie Allen&quot; str(xml_example) ## List of 1 ## $ body:List of 3 ## ..$ ingredient:List of 1 ## .. ..$ : chr &quot;Мука&quot; ## .. ..- attr(*, &quot;amount&quot;)= chr &quot;3&quot; ## .. ..- attr(*, &quot;unit&quot;)= chr &quot;стакан&quot; ## ..$ ingredient:List of 1 ## .. ..$ : chr &quot;Дрожжи&quot; ## .. ..- attr(*, &quot;amount&quot;)= chr &quot;0.25&quot; ## .. ..- attr(*, &quot;unit&quot;)= chr &quot;грамм&quot; ## ..$ ingredient:List of 1 ## .. ..$ : chr &quot;Тёплая вода&quot; ## .. ..- attr(*, &quot;amount&quot;)= chr &quot;1.5&quot; ## .. ..- attr(*, &quot;unit&quot;)= chr &quot;стакан&quot; 6.2 Пакет purrr В tidyverse встроен пакет purrr, который среди прочего позволяет работать со списками. Существует cheat sheet по purrr. 6.2.1 Функция map() и map...() Можно выводить значения в списке на основе имени: got_chars %&gt;% map(&quot;name&quot;) ## [[1]] ## [1] &quot;Theon Greyjoy&quot; ## ## [[2]] ## [1] &quot;Tyrion Lannister&quot; ## ## [[3]] ## [1] &quot;Victarion Greyjoy&quot; ## ## [[4]] ## [1] &quot;Will&quot; ## ## [[5]] ## [1] &quot;Areo Hotah&quot; ## ## [[6]] ## [1] &quot;Chett&quot; ## ## [[7]] ## [1] &quot;Cressen&quot; ## ## [[8]] ## [1] &quot;Arianne Martell&quot; ## ## [[9]] ## [1] &quot;Daenerys Targaryen&quot; ## ## [[10]] ## [1] &quot;Davos Seaworth&quot; ## ## [[11]] ## [1] &quot;Arya Stark&quot; ## ## [[12]] ## [1] &quot;Arys Oakheart&quot; ## ## [[13]] ## [1] &quot;Asha Greyjoy&quot; ## ## [[14]] ## [1] &quot;Barristan Selmy&quot; ## ## [[15]] ## [1] &quot;Varamyr&quot; ## ## [[16]] ## [1] &quot;Brandon Stark&quot; ## ## [[17]] ## [1] &quot;Brienne of Tarth&quot; ## ## [[18]] ## [1] &quot;Catelyn Stark&quot; ## ## [[19]] ## [1] &quot;Cersei Lannister&quot; ## ## [[20]] ## [1] &quot;Eddard Stark&quot; ## ## [[21]] ## [1] &quot;Jaime Lannister&quot; ## ## [[22]] ## [1] &quot;Jon Connington&quot; ## ## [[23]] ## [1] &quot;Jon Snow&quot; ## ## [[24]] ## [1] &quot;Aeron Greyjoy&quot; ## ## [[25]] ## [1] &quot;Kevan Lannister&quot; ## ## [[26]] ## [1] &quot;Melisandre&quot; ## ## [[27]] ## [1] &quot;Merrett Frey&quot; ## ## [[28]] ## [1] &quot;Quentyn Martell&quot; ## ## [[29]] ## [1] &quot;Samwell Tarly&quot; ## ## [[30]] ## [1] &quot;Sansa Stark&quot; Можно выводить значения в списке на основе индекса: got_chars %&gt;% map(3) ## [[1]] ## [1] &quot;Theon Greyjoy&quot; ## ## [[2]] ## [1] &quot;Tyrion Lannister&quot; ## ## [[3]] ## [1] &quot;Victarion Greyjoy&quot; ## ## [[4]] ## [1] &quot;Will&quot; ## ## [[5]] ## [1] &quot;Areo Hotah&quot; ## ## [[6]] ## [1] &quot;Chett&quot; ## ## [[7]] ## [1] &quot;Cressen&quot; ## ## [[8]] ## [1] &quot;Arianne Martell&quot; ## ## [[9]] ## [1] &quot;Daenerys Targaryen&quot; ## ## [[10]] ## [1] &quot;Davos Seaworth&quot; ## ## [[11]] ## [1] &quot;Arya Stark&quot; ## ## [[12]] ## [1] &quot;Arys Oakheart&quot; ## ## [[13]] ## [1] &quot;Asha Greyjoy&quot; ## ## [[14]] ## [1] &quot;Barristan Selmy&quot; ## ## [[15]] ## [1] &quot;Varamyr&quot; ## ## [[16]] ## [1] &quot;Brandon Stark&quot; ## ## [[17]] ## [1] &quot;Brienne of Tarth&quot; ## ## [[18]] ## [1] &quot;Catelyn Stark&quot; ## ## [[19]] ## [1] &quot;Cersei Lannister&quot; ## ## [[20]] ## [1] &quot;Eddard Stark&quot; ## ## [[21]] ## [1] &quot;Jaime Lannister&quot; ## ## [[22]] ## [1] &quot;Jon Connington&quot; ## ## [[23]] ## [1] &quot;Jon Snow&quot; ## ## [[24]] ## [1] &quot;Aeron Greyjoy&quot; ## ## [[25]] ## [1] &quot;Kevan Lannister&quot; ## ## [[26]] ## [1] &quot;Melisandre&quot; ## ## [[27]] ## [1] &quot;Merrett Frey&quot; ## ## [[28]] ## [1] &quot;Quentyn Martell&quot; ## ## [[29]] ## [1] &quot;Samwell Tarly&quot; ## ## [[30]] ## [1] &quot;Sansa Stark&quot; Достаточно полезно знать о функции unlist(), которая “убивает” все сложную структуру: got_chars %&gt;% map(&quot;name&quot;) %&gt;% unlist() ## [1] &quot;Theon Greyjoy&quot; &quot;Tyrion Lannister&quot; &quot;Victarion Greyjoy&quot; ## [4] &quot;Will&quot; &quot;Areo Hotah&quot; &quot;Chett&quot; ## [7] &quot;Cressen&quot; &quot;Arianne Martell&quot; &quot;Daenerys Targaryen&quot; ## [10] &quot;Davos Seaworth&quot; &quot;Arya Stark&quot; &quot;Arys Oakheart&quot; ## [13] &quot;Asha Greyjoy&quot; &quot;Barristan Selmy&quot; &quot;Varamyr&quot; ## [16] &quot;Brandon Stark&quot; &quot;Brienne of Tarth&quot; &quot;Catelyn Stark&quot; ## [19] &quot;Cersei Lannister&quot; &quot;Eddard Stark&quot; &quot;Jaime Lannister&quot; ## [22] &quot;Jon Connington&quot; &quot;Jon Snow&quot; &quot;Aeron Greyjoy&quot; ## [25] &quot;Kevan Lannister&quot; &quot;Melisandre&quot; &quot;Merrett Frey&quot; ## [28] &quot;Quentyn Martell&quot; &quot;Samwell Tarly&quot; &quot;Sansa Stark&quot; Для этого есть и отдельные функции, которые позволяют превратить все в вектор заданного типа: got_chars %&gt;% map_chr(&quot;name&quot;) ## [1] &quot;Theon Greyjoy&quot; &quot;Tyrion Lannister&quot; &quot;Victarion Greyjoy&quot; ## [4] &quot;Will&quot; &quot;Areo Hotah&quot; &quot;Chett&quot; ## [7] &quot;Cressen&quot; &quot;Arianne Martell&quot; &quot;Daenerys Targaryen&quot; ## [10] &quot;Davos Seaworth&quot; &quot;Arya Stark&quot; &quot;Arys Oakheart&quot; ## [13] &quot;Asha Greyjoy&quot; &quot;Barristan Selmy&quot; &quot;Varamyr&quot; ## [16] &quot;Brandon Stark&quot; &quot;Brienne of Tarth&quot; &quot;Catelyn Stark&quot; ## [19] &quot;Cersei Lannister&quot; &quot;Eddard Stark&quot; &quot;Jaime Lannister&quot; ## [22] &quot;Jon Connington&quot; &quot;Jon Snow&quot; &quot;Aeron Greyjoy&quot; ## [25] &quot;Kevan Lannister&quot; &quot;Melisandre&quot; &quot;Merrett Frey&quot; ## [28] &quot;Quentyn Martell&quot; &quot;Samwell Tarly&quot; &quot;Sansa Stark&quot; got_chars %&gt;% map_int(&quot;id&quot;) ## [1] 1022 1052 1074 1109 1166 1267 1295 130 1303 1319 148 149 150 168 2066 ## [16] 208 216 232 238 339 529 576 583 60 605 743 751 844 954 957 got_chars %&gt;% map_lgl(&quot;alive&quot;) ## [1] TRUE TRUE TRUE FALSE TRUE FALSE FALSE TRUE TRUE TRUE TRUE FALSE ## [13] TRUE TRUE FALSE TRUE TRUE FALSE TRUE FALSE TRUE TRUE TRUE TRUE ## [25] FALSE TRUE FALSE FALSE TRUE TRUE Можно даже создать новый датафрейм: got_chars %&gt;% tibble(name = map_chr(., &quot;name&quot;), # точка обозначает, в какой аргумент должно все пайпиться id = map_dbl(., &quot;id&quot;), alive = map_lgl(., &quot;alive&quot;)) ## # A tibble: 30 x 4 ## . name id alive ## &lt;list&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 &lt;named list [18]&gt; Theon Greyjoy 1022 TRUE ## 2 &lt;named list [18]&gt; Tyrion Lannister 1052 TRUE ## 3 &lt;named list [18]&gt; Victarion Greyjoy 1074 TRUE ## 4 &lt;named list [18]&gt; Will 1109 FALSE ## 5 &lt;named list [18]&gt; Areo Hotah 1166 TRUE ## 6 &lt;named list [18]&gt; Chett 1267 FALSE ## 7 &lt;named list [18]&gt; Cressen 1295 FALSE ## 8 &lt;named list [18]&gt; Arianne Martell 130 TRUE ## 9 &lt;named list [18]&gt; Daenerys Targaryen 1303 TRUE ## 10 &lt;named list [18]&gt; Davos Seaworth 1319 TRUE ## # … with 20 more rows Также существует способ создание датафреймов на основе вектора значений при помощи функции enframe(): got_chars %&gt;% map_chr(&quot;name&quot;) %&gt;% enframe() ## # A tibble: 30 x 2 ## name value ## &lt;int&gt; &lt;chr&gt; ## 1 1 Theon Greyjoy ## 2 2 Tyrion Lannister ## 3 3 Victarion Greyjoy ## 4 4 Will ## 5 5 Areo Hotah ## 6 6 Chett ## 7 7 Cressen ## 8 8 Arianne Martell ## 9 9 Daenerys Targaryen ## 10 10 Davos Seaworth ## # … with 20 more rows Скачайте частотный словарь русского языка [Шаров, Ляшевская 2011], разбейте столбец lemma на буквы при помощи функции str_split(dict$lemma, \"\"), а на основе полученного списка постройте график, на котором изображено, сколько раз встретилась какая буква: Также можно использовать комбинацию функции map() и attr_getter() чтобы доставать все значения аттрибутов: xml_example$body %&gt;% map(attr_getter(&quot;amount&quot;)) ## $ingredient ## [1] &quot;3&quot; ## ## $ingredient ## [1] &quot;0.25&quot; ## ## $ingredient ## [1] &quot;1.5&quot; 6.2.2 Фильтрация списков Если в списке есть логические выражения, их можно использовать как фильтры. Например, вот так мы оставим только живых героев: got_chars %&gt;% keep(&quot;alive&quot;) %&gt;% map_chr(&quot;name&quot;) ## [1] &quot;Theon Greyjoy&quot; &quot;Tyrion Lannister&quot; &quot;Victarion Greyjoy&quot; ## [4] &quot;Areo Hotah&quot; &quot;Arianne Martell&quot; &quot;Daenerys Targaryen&quot; ## [7] &quot;Davos Seaworth&quot; &quot;Arya Stark&quot; &quot;Asha Greyjoy&quot; ## [10] &quot;Barristan Selmy&quot; &quot;Brandon Stark&quot; &quot;Brienne of Tarth&quot; ## [13] &quot;Cersei Lannister&quot; &quot;Jaime Lannister&quot; &quot;Jon Connington&quot; ## [16] &quot;Jon Snow&quot; &quot;Aeron Greyjoy&quot; &quot;Melisandre&quot; ## [19] &quot;Samwell Tarly&quot; &quot;Sansa Stark&quot; А так – только мертвых: got_chars %&gt;% discard(&quot;alive&quot;) %&gt;% map_chr(&quot;name&quot;) ## [1] &quot;Will&quot; &quot;Chett&quot; &quot;Cressen&quot; &quot;Arys Oakheart&quot; ## [5] &quot;Varamyr&quot; &quot;Catelyn Stark&quot; &quot;Eddard Stark&quot; &quot;Kevan Lannister&quot; ## [9] &quot;Merrett Frey&quot; &quot;Quentyn Martell&quot; Также есть особый фильтр head_while() и tail_while(), который выделяет единицы (с начала и конца) до первого FALSE. got_chars %&gt;% head_while(&quot;alive&quot;) %&gt;% map_chr(&quot;name&quot;) ## [1] &quot;Theon Greyjoy&quot; &quot;Tyrion Lannister&quot; &quot;Victarion Greyjoy&quot; got_chars %&gt;% tail_while(&quot;alive&quot;) %&gt;% map_chr(&quot;name&quot;) ## [1] &quot;Samwell Tarly&quot; &quot;Sansa Stark&quot; Если все еще не понятно, взгляните на нашу таблицу: got_chars %&gt;% tibble(name = map_chr(., &quot;name&quot;), # точка обозначает, в какой аргумент должно все пайпиться alive = map_lgl(., &quot;alive&quot;)) ## # A tibble: 30 x 3 ## . name alive ## &lt;list&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 &lt;named list [18]&gt; Theon Greyjoy TRUE ## 2 &lt;named list [18]&gt; Tyrion Lannister TRUE ## 3 &lt;named list [18]&gt; Victarion Greyjoy TRUE ## 4 &lt;named list [18]&gt; Will FALSE ## 5 &lt;named list [18]&gt; Areo Hotah TRUE ## 6 &lt;named list [18]&gt; Chett FALSE ## 7 &lt;named list [18]&gt; Cressen FALSE ## 8 &lt;named list [18]&gt; Arianne Martell TRUE ## 9 &lt;named list [18]&gt; Daenerys Targaryen TRUE ## 10 &lt;named list [18]&gt; Davos Seaworth TRUE ## # … with 20 more rows 6.2.3 Операции со списками Рассмотрим простой пример: my_l &lt;- list(a = 1:3, b = c(&quot;a&quot;, &quot;b&quot;), c = list(&quot;z&quot;, c(8, 9))) my_l ## $a ## [1] 1 2 3 ## ## $b ## [1] &quot;a&quot; &quot;b&quot; ## ## $c ## $c[[1]] ## [1] &quot;z&quot; ## ## $c[[2]] ## [1] 8 9 Как уже говорилось выше, функция unlist() линеаризует списки, превращая их в векторы: my_l %&gt;% unlist() ## a1 a2 a3 b1 b2 c1 c2 c3 ## &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;a&quot; &quot;b&quot; &quot;z&quot; &quot;8&quot; &quot;9&quot; Получился поименнованный вектор, если этого недостаточно, можно уничтожить и имена при помощи функции unname(): my_l %&gt;% unlist() %&gt;% unname() ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;a&quot; &quot;b&quot; &quot;z&quot; &quot;8&quot; &quot;9&quot; Функция flatten позволяет уничтожить лишь один, верхний,, уровень иерархии: my_l %&gt;% flatten() ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] &quot;a&quot; ## ## [[5]] ## [1] &quot;b&quot; ## ## [[6]] ## [1] &quot;z&quot; ## ## [[7]] ## [1] 8 9 Как видно из этого примера, первый элемент списка my_l превратился в три первых элемента списка, а вот подсписок c = list(\"z\", c(8, 9)) превратился в элемент z и вектор c(8, 9). Существуют также функции append() и prepend(), которые позволяют добавлять новый посписок после (или до) старого: list(c(1, 2), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) %&gt;% append(list(new = c(TRUE, FALSE))) ## [[1]] ## [1] 1 2 ## ## [[2]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## $new ## [1] TRUE FALSE list(c(1, 2), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) %&gt;% prepend(list(new = c(TRUE, FALSE))) ## $new ## [1] TRUE FALSE ## ## [[2]] ## [1] 1 2 ## ## [[3]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; Существует также функции cross() и cross2(), которые позволяют получить уникальные комбинации объектов из двух списков: list(c(&quot;a&quot;, &quot;b&quot;), 1:3) %&gt;% cross() %&gt;% str() ## List of 6 ## $ :List of 2 ## ..$ : chr &quot;a&quot; ## ..$ : int 1 ## $ :List of 2 ## ..$ : chr &quot;b&quot; ## ..$ : int 1 ## $ :List of 2 ## ..$ : chr &quot;a&quot; ## ..$ : int 2 ## $ :List of 2 ## ..$ : chr &quot;b&quot; ## ..$ : int 2 ## $ :List of 2 ## ..$ : chr &quot;a&quot; ## ..$ : int 3 ## $ :List of 2 ## ..$ : chr &quot;b&quot; ## ..$ : int 3 list(&quot;a&quot;, &quot;b&quot;) %&gt;% cross2(1:3) %&gt;% str() ## List of 6 ## $ :List of 2 ## ..$ : chr &quot;a&quot; ## ..$ : int 1 ## $ :List of 2 ## ..$ : chr &quot;b&quot; ## ..$ : int 1 ## $ :List of 2 ## ..$ : chr &quot;a&quot; ## ..$ : int 2 ## $ :List of 2 ## ..$ : chr &quot;b&quot; ## ..$ : int 2 ## $ :List of 2 ## ..$ : chr &quot;a&quot; ## ..$ : int 3 ## $ :List of 2 ## ..$ : chr &quot;b&quot; ## ..$ : int 3 Скачайте пьесу “Ревизор”, размеченную в TEI формате и постройте представленный ниже график, на котором изображено количество реплик для каждого персонажа. Превратив данные в список, лучше начинать работать с переменной revizor$TEI$text$body: "],
["data-presentation.html", "7 Представление данных: rmarkdown, shiny 7.1 rmarkdown 7.2 Бывают и другие способы представления данных", " 7 Представление данных: rmarkdown, shiny Достаточно важной частью работы с данными является их представление. Мы рассмотрим наиболее распространенный варианты: rmarkdown, flexdashboard и shiny. Смотрите книжку (Xie, Allaire, and Grolemund 2019)(https://bookdown.org/yihui/rmarkdown/) или cheatsheet. 7.1 rmarkdown rmarkdown – это пакет, который позволяет соединять R команды и их исполнения в один документ. В результате можно комбинировать текст и исполняемый код, что в свою очередь позволяет делать: * докумунты в формате .html, .pdf (используя , мы почти не будем это обсуждать), .docx * презентации в формате .html, .pdf (используя пакет beamer) .pptx-презентации * набор связанных .html документов (полноценный сайт или книга) 7.1.1 Установка Как и все пакеты rmarkdown можно установить из CRAN install.packages(&quot;rmarkdown&quot;) 7.1.2 Составляющие rmarkdown-документа yaml шапка (факультативна) обычный текст с markdown форматированием (расширенный при помощи Pandoc) блоки кода (не обязательно на языке R), оформленные с двух сторон тройным бэктиком ``` (у меня на клавиатуре этот знак на букве ё). 7.1.3 Пример rmarkdown-документа Создайте файл .Rmd в какой-нибудь папке (в RStudio, это можно сделать File &gt; New file &gt; R Markdown). Скомпелировать файл можно командой: rmarkdown::render(&quot;ваш_файл.Rmd&quot;) или кнопкой . Вот пример кода: --- output: html_document --- ## Данные В документе можно вставлять R код ```{r} summary(iris) ``` ## График И строить графики ```{r} library(tidyverse) iris %&gt;% ggplot(aes(Sepal.Length, Sepal.Width))+ geom_point() ``` Результат. Создайте и скомпелируйте свой rmarkdown-документ с заголовком, текстом и кодом. 7.1.4 Markdown Универсальны язык разметки, работает во многих современных он-лайн системах создания текста. 7.1.4.1 Заголовки ## Заголовок уровня 2 #### Заголовок уровня 4 7.1.4.2 Форматирование _италик_ или *другой италик* __жирный__ или **другой жирный** ~~зачеркивание~~ италик или другой италик жирный или другой жирный зачеркивание 7.1.4.3 Списки * кролик * заяц * заяц серый 1. машины 1. автобус 2. самолеты + можно еще ставить плюс - и минус кролик заяц заяц серый машины автобус самолеты можно еще ставить плюс и минус 7.1.4.4 Ссылки и картинки [Ссылка 1](https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html) &lt;https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html&gt; [Можно вставить ссылку потом, а пока отсавить метку][1] Или даже просто голую [метку]. ![](https://raw.githubusercontent.com/agricolamz/2018_ANDAN_course_winter/master/rmarkdown.png) Опять же можно вставить только метку ![][2] [1]: https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html [метку]: https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html [2]: https://raw.githubusercontent.com/agricolamz/2018_ANDAN_course_winter/master/rmarkdown.png Ссылка 1 https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html Можно вставить ссылку потом, а пока отсавить метку Или даже просто голую метку. Опять же можно вставить только метку 7.1.4.5 Код Код нужно оформалять вот так `rmarkdown::render()` Код нужно оформалять вот так rmarkdown::render() ```{python} friends = [&#39;john&#39;, &#39;pat&#39;, &#39;gary&#39;, &#39;michael&#39;] for i, name in enumerate(friends): print &quot;iteration {iteration} is {name}&quot;.format(iteration=i, name=name) ``` friends = [&#39;john&#39;, &#39;pat&#39;, &#39;gary&#39;, &#39;michael&#39;] for i, name in enumerate(friends): print &quot;iteration {iteration} is {name}&quot;.format(iteration=i, name=name) iteration 0 is john iteration 1 is pat iteration 2 is gary iteration 3 is michael Если хочется использовать результат работы кода в тексте, нужно в начале поставить язык, который будет исполнять код, например, в Фигурные скобки не обязательны, но тогда RStudio подсветит. 7.1.4.6 Цитаты &gt; Цитаты нужно офрмлять так. &gt; Это попадет в тот же фрагмент. &gt; А вот тут произошел разрыв. Кстати, здесь тоже можно использовать *markdown*. Цитаты нужно офрмлять так. Это попадет в тот же фрагмент. А вот тут произошел разрыв. Кстати, здесь тоже можно использовать markdown. 7.1.4.7 Разрыв страницы *** 7.1.4.8 HTML &lt;dl&gt; &lt;dt&gt;Чистый HTML&lt;/dt&gt; &lt;dd&gt;Еще можно писать в HTML.&lt;/dd&gt; &lt;dt&gt;и Markdown в HTML &lt;/dt&gt; &lt;dd&gt; даже работает **правильно**. Но можно использовать и &lt;em&gt;теги&lt;/em&gt;.&lt;/dd&gt; &lt;/dl&gt; Чистый HTML Еще можно писать в HTML. и Markdown в HTML даже работает правильно. Но можно использовать и теги. 7.1.4.9 Таблицы Еще есть целая наука как делать таблицы в Markdown, но я предпочитаю использовать он-лайн генератор. 7.1.5 Pandoc Pandoc это программа, созданная Дж. МакФарлэйном (J. MacFarlane), которая позволяет переходить из разных текстовых форматов в другие, а также смешивать их. Я покожу лишь несколько полезных расширений. 7.1.5.1 Верхние и нижние индексы 2^10^ C~n~^k^ 210 Cnk 7.1.5.2 Нумерованные примеры (@) Славный пример номер раз. (@) Славный пример номер два. (@three) Славный пример номер три, у которого есть *имя*. Я могу сослаться на пример (@three)! Славный пример номер раз. Славный пример номер два. Славный пример номер три, у которого есть имя. Я могу сослаться на пример (3)! 7.1.5.3 Сноски Вот и сноска[^1] [^1]: Сноска, сноска, сноска. Вот и сноска2 7.1.5.4 Математика: \\(\\LaTeX\\) $\\LaTeX$ код может быть в тексте $\\frac{\\pi}{\\sum{n+1}}$ или отдельной строчкой: $$\\frac{\\pi}{\\sum{n+1}}$$ \\(\\LaTeX\\) код может быть в тексте \\(\\frac{\\pi}{\\sum{n+1}}\\) или отдельной строчкой: \\[\\frac{\\pi}{\\sum{n+1}}\\] 7.1.6 Code chunks Фрагменты кода имеют свои наборы свойств, который можно записывать в фигурных скобках. 7.1.6.1 Язык программирования ```{r} summary(cars) ``` ```{python} x = &quot;my string&quot; print(x.split(&quot; &quot;)) ``` summary(cars) speed dist Min. : 4.0 Min. : 2.00 1st Qu.:12.0 1st Qu.: 26.00 Median :15.0 Median : 36.00 Mean :15.4 Mean : 42.98 3rd Qu.:19.0 3rd Qu.: 56.00 Max. :25.0 Max. :120.00 x = &quot;my string&quot; print(x.split(&quot; &quot;)) [&#39;my&#39;, &#39;string&#39;] 7.1.6.2 Появление и исполнение кода И код, и результат ```{r} plot(mtcars$mpg) ``` Только результат ```{r, echo = FALSE} plot(mtcars$mpg) ``` Только код ```{r, eval = FALSE} plot(mtcars$mpg) ``` Исполняется, но не показывается ни код, ни результат ```{r, include = FALSE} a &lt;- mtcars$mpg ``` Обратимся к переменной, созданной в фрагменте с аргументом `include = FALSE` ```{r} a ``` 7.1.6.3 Другие полезные аргументы Существует достаточно много аргументов, которые можно перечислить в фигурных скобках в фрагменте кода, вот некоторые из них: error: показывать ли ошибки. warning: показывать ли предупреждения. message: показывать ли сообщения (например, при подключении пакетов). comment: по умолчанию, результат работы кода предваряется знаком ##, используйте NA, чтобы их не было, или любую другую строку. cache: сохранить ли результат работы фрагмента кода. Очень полезно, если происходят какие-то операции, занимающая много времени. Сохранив результат, не нужно будет тратить время, на пересчет, при каждой новой компиляции. fig.width, fig.height (по умолчанию, 7) Все эти аргументы можно перечислить в функции knitr::opts_chunk$set(...): 7.1.6.4 Pets or livestock? В RMarkdown каждому фрагменту кода можно дать имя (но избегайте пробелов и точек): ```{r my_beautiful_graph, eval = FALSE} library(tidyverse) diamonds %&gt;% count(carat, color) %&gt;% ggplot(aes(carat, n, color = color))+ geom_point() ``` Maëlle Salmon написал отличный пост, почему полезно именовать фрагменты кода: проще ориентироваться код более читаемый ошибки при компеляции показывают имя, а не номер если фрагмент кэшировался, то добавление одного фрагменты перед ним, не заставит все пересчитываться в blogdown можно ссылаться 7.1.7 YAML шапка Факультативная YAML шапка обычно содержит метаданные документа, и аргументы, необходимые для работы некоторых дополнений. --- title: &quot;Мой RMarkdown&quot; author: Славный Автор date: 20 ноября 2019 --- 7.1.7.1 Тип получившегося файла output: html_document (по умолчанию) output: word_document output: pdf_document (но нужно договориться с \\(\\LaTeX\\)ом на вашем компьютере) output: ioslides_presentation output: slidy_presentation output: slidy_presentation output: beamer_presentation и др. 7.1.7.2 Библиография Существует несколько сопособов вставлять библиографию в RMarkdown. Я раскажу, как использовать пакет Bibtex (как видно из названия, сделанный для \\(\\LaTeX\\)). Для начала нужно создать файл с раширением .bib, в который записать все источники, которые будут использоваться (библиографию в формате BibTeX выдает, например, GoogleScholar): @book{ladefoged96, title={The sounds of the world&#39;s languages}, author={Ladefoged, P. and Maddieson, I.}, year={1996}, publisher={Oxford Publishers} } @article{gordon02, title={A cross-linguistic acoustic study of voiceless fricatives}, author={Gordon, M. and Barthmaier, P. and Sands, K.}, journal={Journal of the International Phonetic Association}, volume={32}, number={2}, pages={141--174}, year={2002}, publisher={Cambridge University Press} } На следующем шаге нужно добавить название файла с раширением .bib в YAML шапку: --- bibliography: bibliography.bib --- После этого, можно использовать сслыки в тексте В своей работе @gordon02 раскрыл... В своей работе Gordon, Barthmaier, and Sands (2002) раскрыл… Об этом можно узнать из [@ladefoged96; @gordon02], но ... Об этом можно узнать из (Ladefoged and Maddieson 1996; Gordon, Barthmaier, and Sands 2002), но … В своей работе [@gordon02] раскрыл... В своей работе (Gordon, Barthmaier, and Sands 2002) раскрыл… Об этом можно узнать из [см. @gordon02, с. 33--35; а также @ladefoged96, гл. 1]... Об этом можно узнать из (см. Gordon, Barthmaier, and Sands 2002, с. 33–35; а также Ladefoged and Maddieson 1996, гл. 1)… Список литературы автоматически появляется в конце. 7.1.7.3 Оглавление и пр. Существует сразу несколько аргументов, отвечающих за оглавление. toc вставлять ли оглавление toc_depth глубина иерархии, которую отражать в огловлении toc_float должно ли оглавление все время следовать за текстом collapsed должно ли оглавление быть все время полностью раскрыто collapsed должно ли оглавление быть все время полностью раскрыто number_sections автоматическая нумерация секций code_folding (hide) — делать ли кнопочку, показывающую/скрывающую весь код theme одна из Bootstrap тем highlight: “default”, “tango”, “pygments”, “kate”, “monochrome”, “espresso”, “zenburn”, “haddock” или “textmate” --- html_document: theme: spacelab highlight: pygments toc: yes toc_position: right toc_depth: 3 toc_float: yes smooth_scroll: false --- 7.1.7.4 Отображение датафреймов df_print: default df_print: kable df_print: tibble df_print: paged --- output: html_document: df_print: paged --- 7.1.8 Где хостить .html? Полученные .html можно разместить в интернете: на каком-то вашем хосте опубликовать на бесплатном хостинке Rpubs опубликовать на гитхабе и включить Github Pages Теперь создайте документ index.Rmd, в котором напишите код на R и на Python, вставьте картинку, сноску, ссылку на литературу, таблицу и оглавление. Скомпелируйте .html документ и опубликуйте его на Github, пройдя по этой ссылке. 7.2 Бывают и другие способы представления данных flexdashboard – динамические дэшборды shiny – динамические сайты, которые позволяют взаимодействовать с пользователем posterdown – постеры в RMarkdown pagedown – содержит много шаблонов: для книги, статьи, постера, резюме, визитки… да хоть приглашение на свадьбу можно сделать. Ссылки на литературу "],
["tidytext.html", "8 Работа с текстами: guttenbergr, tidytext, udpipe, corpus", " 8 Работа с текстами: guttenbergr, tidytext, udpipe, corpus "],
["rvest.html", "9 Сбор данных из интернета: rvest", " 9 Сбор данных из интернета: rvest "],
["non-standard-data.html", "10 Нестандартные данные: время, OCR, карты", " 10 Нестандартные данные: время, OCR, карты Задания можно брать с сайта Левада центра "],
["distributions.html", "11 Distributions", " 11 Distributions https://ben18785.shinyapps.io/distribution-zoo/ "],
["tasks.html", "12 Задания 12.1 Вектор 12.2 Вектор. Операции с векторами 12.3 Вектор. Индексирование 12.4 Списки 12.5 Матрицы 12.6 Датафрейм", " 12 Задания 12.1 Вектор Посчитайте логарифм от 8912162342 по основанию 6 [1] 12.7867 Теперь натуральный логарифм 10 и умножьте его на 5 [1] 11.51293 Создайте вектор от 1 до 20 [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Создайте вектор от 20 до 1 [1] 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 Создайте вектор от 1 до 20 и снова до 1. Число 20 должно присутствовать только один раз! [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 19 18 17 16 15 [26] 14 13 12 11 10 9 8 7 6 5 4 3 2 1 Создайте вектор 2, 4, 6, … , 18, 20 [1] 2 4 6 8 10 12 14 16 18 20 Создайте вектор из одной единицы, двух двоек, трех троек, …. , девяти девяток [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 6 6 6 6 6 6 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 9 9 [39] 9 9 9 9 9 9 9 Сделайте вектор vec, в котором соедините 3, а также значения \"Мой\" и \"вектор\". [1] &quot;3&quot; &quot;Мой&quot; &quot;вектор&quot; Вычесть TRUE из 10 [1] 9 Соедините значение 10 и TRUE в вектор vec [1] 10 1 Соедините вектор vec и значение \"r\": [1] &quot;10&quot; &quot;1&quot; &quot;r&quot; Соедините значения 10, TRUE, \"r\" в вектор. [1] &quot;10&quot; &quot;TRUE&quot; &quot;r&quot; 12.2 Вектор. Операции с векторами Создайте вектор p, состоящий из значений 4, 5, 6, 7, и вектор q, состоящий из 0, 1, 2, 3. [1] 4 5 6 7 [1] 0 1 2 3 Посчитайте поэлементную сумму векторов p и q: [1] 4 6 8 10 Посчитайте поэлементную разницу p и q: [1] 4 4 4 4 Поделите каждый элемент вектора p на соответствующий ему элемент вектора q: О, да, Вам нужно делить на 0! [1] Inf 5.000000 3.000000 2.333333 Возведите каждый элемент вектора p в степень соответствующего ему элемента вектора q: [1] 1 5 36 343 Создайте вектор квадратов чисел от 1 до 10: [1] 1 4 9 16 25 36 49 64 81 100 Создайте вектор 0, 2, 0, 4, … , 18, 0, 20 [1] 0 2 0 4 0 6 0 8 0 10 0 12 0 14 0 16 0 18 0 20 12.3 Вектор. Индексирование Создайте вектор vec1: vec1 &lt;- c(3, 5, 2, 1, 8, 4, 9, 10, 3, 15, 1, 11) Найдите второй элемент вектора vec1: [1] 5 Найдите последний элемент вектора vec1 [1] 11 Найдите все значения вектора vec1, которые больше 4 [1] 5 8 9 10 15 11 Найдите все значения вектора vec1, которые больше 4, но меньше 10 [1] 5 8 9 Возведите в квадрат каждое значение вектора vec1 [1] 9 25 4 1 64 16 81 100 9 225 1 121 Возведите в квадрат каждое нечетное значение вектора и извлеките корень каждого четного значения vec1 [1] 9.000000 2.236068 4.000000 1.000000 64.000000 2.000000 81.000000 [8] 3.162278 9.000000 3.872983 1.000000 3.316625 Создайте вектор vec2, в котором будут значения все значения vec1, которые меньше 10 будут заменены на NA. [1] NA NA NA NA NA NA NA 10 NA 15 NA 11 Посчитайте сумму vec2 с помощью функции sum(). Ответ NA не считается! [1] 36 Создайте вектор 2, 4, 6, … , 18, 20 как минимум 2 новыми способами Знаю, это задание может показаться бессмысленным, но это очень базовая операция, с помощью которой можно, например, разделить данные на две части. Чем больше способов Вы знаете, тем лучше! integer(0) 12.4 Списки Дан список list_1: list_1 = list(numbers = 1:5, letters = letters, logic = TRUE) list_1 $numbers [1] 1 2 3 4 5 $letters [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; $logic [1] TRUE Найдите первый элемент списка. Ответ должен быть списком. $numbers [1] 1 2 3 4 5 Теперь найдите содержание первого элемента списка двумя разными способами. Ответ должен быть вектором. [1] 1 2 3 4 5 [1] 1 2 3 4 5 Теперь возьмите первый элемент содержания первого элемента списка. Ответ должен быть вектором. [1] 1 Создайте список list_2, содержащий в себе два списка list_1 с именами pupa и lupa. $pupa $pupa$numbers [1] 1 2 3 4 5 $pupa$letters [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; $pupa$logic [1] TRUE $lupa $lupa$numbers [1] 1 2 3 4 5 $lupa$letters [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; $lupa$logic [1] TRUE Извлеките первый элемент списка, из него - второй полэлемент, а из него - третье значение [1] &quot;c&quot; 12.5 Матрицы Создайте матрицу 4х4, состоящую из единиц. Назовите ее M [,1] [,2] [,3] [,4] [1,] 1 1 1 1 [2,] 1 1 1 1 [3,] 1 1 1 1 [4,] 1 1 1 1 Поменяйте все некрайние значения матрицы M (то есть значения на позициях [2,2], [2,3], [3,2] и [3,3]) на число 2. [,1] [,2] [,3] [,4] [1,] 1 1 1 1 [2,] 1 2 2 1 [3,] 1 2 2 1 [4,] 1 1 1 1 Выделите второй и третий столбик из матрицы M [,1] [,2] [1,] 1 1 [2,] 2 2 [3,] 2 2 [4,] 1 1 Сравните (==) вторую колонку и вторую строчку матрицы M [1] TRUE TRUE TRUE TRUE Создайте таблицу умножения (9х9) в виде матрицы. Сохраните ее в переменную tab: [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [1,] 1 2 3 4 5 6 7 8 9 [2,] 2 4 6 8 10 12 14 16 18 [3,] 3 6 9 12 15 18 21 24 27 [4,] 4 8 12 16 20 24 28 32 36 [5,] 5 10 15 20 25 30 35 40 45 [6,] 6 12 18 24 30 36 42 48 54 [7,] 7 14 21 28 35 42 49 56 63 [8,] 8 16 24 32 40 48 56 64 72 [9,] 9 18 27 36 45 54 63 72 81 Из матрицы tab выделите подматрицу, включающую в себя только строчки с 6 по 8 и столбцы с 3 по 7. [,1] [,2] [,3] [,4] [,5] [1,] 18 24 30 36 42 [2,] 21 28 35 42 49 [3,] 24 32 40 48 56 Создайте матрицу с логическими значениями, где TRUE, если в этом месте в таблице умножения (tab) двузначное число и FALSE, если однозначное. Матрица - это почти вектор. К нему можно обращаться с единственным индексом. [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [1,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [2,] FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE [3,] FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE [4,] FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [5,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [6,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [7,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [8,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [9,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE Создайте матрицу tab2, в которой все значения tab меньше 10 заменены на 0. [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [1,] 0 0 0 0 0 0 0 0 0 [2,] 0 0 0 0 10 12 14 16 18 [3,] 0 0 0 12 15 18 21 24 27 [4,] 0 0 12 16 20 24 28 32 36 [5,] 0 10 15 20 25 30 35 40 45 [6,] 0 12 18 24 30 36 42 48 54 [7,] 0 14 21 28 35 42 49 56 63 [8,] 0 16 24 32 40 48 56 64 72 [9,] 0 18 27 36 45 54 63 72 81 12.6 Датафрейм Кто является 274ым персонажем в got датафрейме? Из какого он дома? Name Allegiances 274 Gendry None Найдите имена всех персонажей из дома (Allegiances) \"Tyrell\" и \"House Tyrell\". [1] &quot;Alerie Hightower&quot; &quot;Alla Tyrell&quot; &quot;Alyn Ambrose&quot; [4] &quot;Arryk (Guard)&quot; &quot;Arwyn Oakheart&quot; &quot;Bayard Norcross&quot; [7] &quot;Blue Bard&quot; &quot;Butterbumps&quot; &quot;Elinor Tyrell&quot; [10] &quot;Erryk (Guard)&quot; &quot;Garlan Tyrell&quot; &quot;Hobber Redwyne&quot; [13] &quot;Horas Redwyne&quot; &quot;Janna Tyrell&quot; &quot;Kerwin&quot; [16] &quot;Leo Tyrell&quot; &quot;Leonette Fossoway&quot; &quot;Loras Tyrell&quot; [19] &quot;Mace Tyrell&quot; &quot;Margaery Tyrell&quot; &quot;Megga Tyrell&quot; [22] &quot;Meredyth Crane&quot; &quot;Olenna Redwyne&quot; &quot;Paxter Redwyne&quot; [25] &quot;Randyll Tarly&quot; &quot;Talbert Serry&quot; Создайте новый датафрейм greyjoy_women, который будет включать в себя только женщин Грейджоев (\"Greyjoy\", \"House Greyjoy\") Name Allegiances Death.Year Book.of.Death Death.Chapter 58 Asha Greyjoy House Greyjoy NA NA NA 248 Falia Flowers Greyjoy NA NA NA 313 Gwin Goodbrother Greyjoy NA NA NA 319 Gysella Goodbrother Greyjoy NA NA NA 806 Three-Tooth Greyjoy NA NA NA Book.Intro.Chapter Gender Nobility GoT CoK SoS FfC DwD Is.Alive 58 11 0 1 0 1 0 1 1 TRUE 248 29 0 0 0 0 0 1 0 TRUE 313 1 0 1 0 0 0 1 0 TRUE 319 1 0 1 0 0 0 1 0 TRUE 806 11 0 0 0 0 0 1 0 TRUE Сколько всего женских персонажей в книгах “Песни льда и пламени”? [1] 157 Сколько всего женских персонажей дворянского происхождения в книгах “Песни льда и пламени”? [1] 84 Поcчитатйе процентную (!) долю знати от общего числа персонажей (Nobility) в Night's Watch. [1] 9.482759 Поcчитатйе процентную (!) долю знати от общего числа персонажей (Nobility) у Lannister. [1] 71.60494 Какая из книг цикла самая кровавая? Для ответа на этот вопрос подсчитайте таблицу частот для колонки got$Book.of.Death: Это можно сделать с помощью функции table(), но в дальнейшем Вы узнаете и другие способы - подобная задача возникает достаточно часто. 1 2 3 4 5 49 73 97 27 61 "],
["solutions.html", "13 Решения_заданий 13.1 Вектор 13.2 Вектор. Операции с векторами 13.3 Вектор. Индексирование 13.4 Списки 13.5 Матрицы 13.6 Датафрейм", " 13 Решения_заданий 13.1 Вектор Посчитайте логарифм от 8912162342 по основанию 6 log(8912162342, 6) [1] 12.7867 Теперь натуральный логарифм 10 и умножьте его на 5 log(10)*5 [1] 11.51293 Создайте вектор от 1 до 20 1:20 [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Создайте вектор от 20 до 1 20:1 [1] 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 Создайте вектор от 1 до 20 и снова до 1. Число 20 должно присутствовать только один раз! c(1:20, 19:1) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 19 18 17 16 15 [26] 14 13 12 11 10 9 8 7 6 5 4 3 2 1 Создайте вектор 2, 4, 6, … , 18, 20 seq(2,20, 2) [1] 2 4 6 8 10 12 14 16 18 20 Создайте вектор из одной единицы, двух двоек, трех троек, …. , девяти девяток rep(1:9, 1:9) [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 6 6 6 6 6 6 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 9 9 [39] 9 9 9 9 9 9 9 Сделайте вектор vec, в котором соедините 3, а также значения \"Мой\" и \"вектор\". vec &lt;- c(3, &quot;Мой&quot;, &quot;вектор&quot;) vec [1] &quot;3&quot; &quot;Мой&quot; &quot;вектор&quot; Вычесть TRUE из 10 10 - TRUE [1] 9 Соедините значение 10 и TRUE в вектор vec vec &lt;- c(10, TRUE) vec [1] 10 1 Соедините вектор vec и значение \"r\": c(vec, &quot;r&quot;) [1] &quot;10&quot; &quot;1&quot; &quot;r&quot; Соедините значения 10, TRUE, \"r\" в вектор. c(10, TRUE, &quot;r&quot;) [1] &quot;10&quot; &quot;TRUE&quot; &quot;r&quot; 13.2 Вектор. Операции с векторами Создайте вектор p, состоящий из значений 4, 5, 6, 7, и вектор q, состоящий из 0, 1, 2, 3. p &lt;- 4:7 p [1] 4 5 6 7 q &lt;- 0:3 q [1] 0 1 2 3 Посчитайте поэлементную сумму векторов p и q: p + q [1] 4 6 8 10 Посчитайте поэлементную разницу p и q: p - q [1] 4 4 4 4 Поделите каждый элемент вектора p на соответствующий ему элемент вектора q: О, да, Вам нужно делить на 0! p/q [1] Inf 5.000000 3.000000 2.333333 Возведите каждый элемент вектора p в степень соответствующего ему элемента вектора q: p^q [1] 1 5 36 343 Создайте вектор квадратов чисел от 1 до 10: (1:10)^2 [1] 1 4 9 16 25 36 49 64 81 100 Создайте вектор 0, 2, 0, 4, … , 18, 0, 20 1:20 * 0:1 [1] 0 2 0 4 0 6 0 8 0 10 0 12 0 14 0 16 0 18 0 20 13.3 Вектор. Индексирование Создайте вектор vec1: vec1 &lt;- c(3, 5, 2, 1, 8, 4, 9, 10, 3, 15, 1, 11) Найдите второй элемент вектора vec1: vec1[2] [1] 5 Найдите последний элемент вектора vec1 vec1[length(vec1)] [1] 11 Найдите все значения вектора vec1, которые больше 4 vec1[vec1&gt;4] [1] 5 8 9 10 15 11 Найдите все значения вектора vec1, которые больше 4, но меньше 10 vec1[vec1&gt;4 &amp; vec1&lt;10] [1] 5 8 9 Возведите в квадрат каждое значение вектора vec1 vec1^2 [1] 9 25 4 1 64 16 81 100 9 225 1 121 Возведите в квадрат каждое нечетное значение вектора и извлеките корень каждого четного значения vec1 vec1 ^ c(2, 0.5) [1] 9.000000 2.236068 4.000000 1.000000 64.000000 2.000000 81.000000 [8] 3.162278 9.000000 3.872983 1.000000 3.316625 Создайте вектор vec2, в котором будут значения все значения vec1, которые меньше 10 будут заменены на NA. vec2 &lt;- vec1 vec2[vec2&lt;10] &lt;- NA vec2 [1] NA NA NA NA NA NA NA 10 NA 15 NA 11 Посчитайте сумму vec2 с помощью функции sum(). Ответ NA не считается! sum(vec2, na.rm = TRUE) [1] 36 Создайте вектор 2, 4, 6, … , 18, 20 как минимум 2 новыми способами Знаю, это задание может показаться бессмысленным, но это очень базовая операция, с помощью которой можно, например, разделить данные на две части. Чем больше способов Вы знаете, тем лучше! (1:20)[c(F,T)] integer(0) #(1:10)*2 13.4 Списки Дан список list_1: list_1 = list(numbers = 1:5, letters = letters, logic = TRUE) list_1 $numbers [1] 1 2 3 4 5 $letters [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; $logic [1] TRUE Найдите первый элемент списка. Ответ должен быть списком. list_1[1] $numbers [1] 1 2 3 4 5 Теперь найдите содержание первого элемента списка двумя разными способами. Ответ должен быть вектором. list_1[[1]] [1] 1 2 3 4 5 list_1$numbers [1] 1 2 3 4 5 Теперь возьмите первый элемент содержания первого элемента списка. Ответ должен быть вектором. list_1[[1]][1] [1] 1 Создайте список list_2, содержащий в себе два списка list_1 с именами pupa и lupa. list_2 = list(pupa = list_1, lupa = list_1) list_2 $pupa $pupa$numbers [1] 1 2 3 4 5 $pupa$letters [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; $pupa$logic [1] TRUE $lupa $lupa$numbers [1] 1 2 3 4 5 $lupa$letters [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; $lupa$logic [1] TRUE Извлеките первый элемент списка, из него - второй полэлемент, а из него - третье значение list_2[[1]][[2]][3] [1] &quot;c&quot; 13.5 Матрицы Создайте матрицу 4х4, состоящую из единиц. Назовите ее M M &lt;- matrix(rep(1, 16), ncol = 4) M [,1] [,2] [,3] [,4] [1,] 1 1 1 1 [2,] 1 1 1 1 [3,] 1 1 1 1 [4,] 1 1 1 1 Поменяйте все некрайние значения матрицы M (то есть значения на позициях [2,2], [2,3], [3,2] и [3,3]) на число 2. M[2:3, 2:3] &lt;- 2 M [,1] [,2] [,3] [,4] [1,] 1 1 1 1 [2,] 1 2 2 1 [3,] 1 2 2 1 [4,] 1 1 1 1 Выделите второй и третий столбик из матрицы M M[,2:3] [,1] [,2] [1,] 1 1 [2,] 2 2 [3,] 2 2 [4,] 1 1 Сравните (==) вторую колонку и вторую строчку матрицы M M[,2] == M[2,] [1] TRUE TRUE TRUE TRUE Создайте таблицу умножения (9х9) в виде матрицы. Сохраните ее в переменную tab: tab &lt;- matrix(rep(1:9, rep(9,9))*(1:9), nrow = 9) tab [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [1,] 1 2 3 4 5 6 7 8 9 [2,] 2 4 6 8 10 12 14 16 18 [3,] 3 6 9 12 15 18 21 24 27 [4,] 4 8 12 16 20 24 28 32 36 [5,] 5 10 15 20 25 30 35 40 45 [6,] 6 12 18 24 30 36 42 48 54 [7,] 7 14 21 28 35 42 49 56 63 [8,] 8 16 24 32 40 48 56 64 72 [9,] 9 18 27 36 45 54 63 72 81 #Еще #outer(1:9, 1:9, &quot;*&quot;) #1:9 %o% 1:9 Из матрицы tab выделите подматрицу, включающую в себя только строчки с 6 по 8 и столбцы с 3 по 7. tab[6:8, 3:7] [,1] [,2] [,3] [,4] [,5] [1,] 18 24 30 36 42 [2,] 21 28 35 42 49 [3,] 24 32 40 48 56 Создайте матрицу с логическими значениями, где TRUE, если в этом месте в таблице умножения (tab) двузначное число и FALSE, если однозначное. Матрица - это почти вектор. К нему можно обращаться с единственным индексом. tab&gt;=10 [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [1,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [2,] FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE [3,] FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE [4,] FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [5,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [6,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [7,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [8,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [9,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE Создайте матрицу tab2, в которой все значения tab меньше 10 заменены на 0. tab2 &lt;- tab tab2[tab&lt;10] &lt;- 0 tab2 [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [1,] 0 0 0 0 0 0 0 0 0 [2,] 0 0 0 0 10 12 14 16 18 [3,] 0 0 0 12 15 18 21 24 27 [4,] 0 0 12 16 20 24 28 32 36 [5,] 0 10 15 20 25 30 35 40 45 [6,] 0 12 18 24 30 36 42 48 54 [7,] 0 14 21 28 35 42 49 56 63 [8,] 0 16 24 32 40 48 56 64 72 [9,] 0 18 27 36 45 54 63 72 81 13.6 Датафрейм Кто является 274ым персонажем в got датафрейме? Из какого он дома? got[274, 1:2] Name Allegiances 274 Gendry None Найдите имена всех персонажей из дома (Allegiances) \"Tyrell\" и \"House Tyrell\". got[got$Allegiances %in% c(&quot;Tyrell&quot;, &quot;House Tyrell&quot;), &quot;Name&quot;] [1] &quot;Alerie Hightower&quot; &quot;Alla Tyrell&quot; &quot;Alyn Ambrose&quot; [4] &quot;Arryk (Guard)&quot; &quot;Arwyn Oakheart&quot; &quot;Bayard Norcross&quot; [7] &quot;Blue Bard&quot; &quot;Butterbumps&quot; &quot;Elinor Tyrell&quot; [10] &quot;Erryk (Guard)&quot; &quot;Garlan Tyrell&quot; &quot;Hobber Redwyne&quot; [13] &quot;Horas Redwyne&quot; &quot;Janna Tyrell&quot; &quot;Kerwin&quot; [16] &quot;Leo Tyrell&quot; &quot;Leonette Fossoway&quot; &quot;Loras Tyrell&quot; [19] &quot;Mace Tyrell&quot; &quot;Margaery Tyrell&quot; &quot;Megga Tyrell&quot; [22] &quot;Meredyth Crane&quot; &quot;Olenna Redwyne&quot; &quot;Paxter Redwyne&quot; [25] &quot;Randyll Tarly&quot; &quot;Talbert Serry&quot; Создайте новый датафрейм greyjoy_women, который будет включать в себя только женщин Грейджоев (\"Greyjoy\", \"House Greyjoy\") greyjoy_women &lt;- got[got$Allegiances %in% c(&quot;Greyjoy&quot;, &quot;House Greyjoy&quot;) &amp; got$Gender == 0, ] greyjoy_women Name Allegiances Death.Year Book.of.Death Death.Chapter 58 Asha Greyjoy House Greyjoy NA NA NA 248 Falia Flowers Greyjoy NA NA NA 313 Gwin Goodbrother Greyjoy NA NA NA 319 Gysella Goodbrother Greyjoy NA NA NA 806 Three-Tooth Greyjoy NA NA NA Book.Intro.Chapter Gender Nobility GoT CoK SoS FfC DwD Is.Alive 58 11 0 1 0 1 0 1 1 TRUE 248 29 0 0 0 0 0 1 0 TRUE 313 1 0 1 0 0 0 1 0 TRUE 319 1 0 1 0 0 0 1 0 TRUE 806 11 0 0 0 0 0 1 0 TRUE Сколько всего женских персонажей в книгах “Песни льда и пламени”? sum(got$Gender == 0) [1] 157 Сколько всего женских персонажей дворянского происхождения в книгах “Песни льда и пламени”? sum((got$Gender == 0) &amp; (got$Nobility == 1)) [1] 84 Поcчитатйе процентную (!) долю знати от общего числа персонажей (Nobility) в Night's Watch. mean(got[got$Allegiances == &quot;Night&#39;s Watch&quot;, &quot;Nobility&quot;])*100 [1] 9.482759 Поcчитатйе процентную (!) долю знати от общего числа персонажей (Nobility) у Lannister. mean(got[got$Allegiances == &quot;Lannister&quot;, &quot;Nobility&quot;])*100 [1] 71.60494 Какая из книг цикла самая кровавая? Для ответа на этот вопрос подсчитайте таблицу частот для колонки got$Book.of.Death: Это можно сделать с помощью функции table(), но в дальнейшем Вы узнаете и другие способы - подобная задача возникает достаточно часто. table(got$Book.of.Death) 1 2 3 4 5 49 73 97 27 61 "],
["ссылки-на-литературу.html", "Ссылки на литературу", " Ссылки на литературу "]
]
