[
["tidy-dplyr.html", "3 tidyverse: Загрузка и трансформация данных 3.1 Загрузка данных 3.2 tibble 3.3 dplyr 3.4 Соединение датафреймов 3.5 tidyr package 3.6 Полезные надстройки", " 3 tidyverse: Загрузка и трансформация данных tidyverse — это набор пакетов: ggplot2, для визуализации tibble, для работы с тибблами, современный вариант датафрейма tidyr, для формата tidy data readr, для чтения файлов в R purrr, для функционального программирования dplyr, для преобразованиия данных stringr, для работы со строковыми переменными forcats, для работы с переменными-факторами Полезно также знать о следующих: readxl, для чтения .xls и .xlsx jsonlite, для работы с JSON rvest, для веб-скреппинга lubridate, для работы с временем tidytext, для работы с текстами и корпусами broom, для перевода в tidy формат статистические модели library(&quot;tidyverse&quot;) ## ── Attaching packages ───────────────────────────────────────────── tidyverse 1.2.1 ── ## ✔ ggplot2 3.2.1 ✔ purrr 0.3.2 ## ✔ tibble 2.1.3 ✔ dplyr 0.8.3 ## ✔ tidyr 1.0.0 ✔ stringr 1.4.0 ## ✔ readr 1.3.1 ✔ forcats 0.4.0 ## ── Conflicts ──────────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() 3.1 Загрузка данных 3.1.1 Рабочая директория Все в R происходит где-то. Нужно загружать файлы с данными, нужно их куда-то сохранять. Желательно иметь для каждого проекта некоторую отдельную папку на компьютере, куда складывать все, отнсящееся к этому проекту. Две команды позволят опредить текущую рабочую дерикторию (getwd()) и (setwd(.../path/to/your/directory)). 3.1.2 Форматы данных: .csv Существет много форматов данных, которые придумали люди. Большинство из них можно загрузить в R. Так как центральный объект в R – таблица \\(n \\times k\\), то и работать мы большую часть времени будем с таблицами. Наиболее распространенные способы хранить данные сейчас это .csv (разберем в данном разделе) и .json (разберем в разделе 5). .csv (comma separated values) – является обычным текстовым файлом, в котором перечислены значения с некоторым фиксированным разделителем: запятой, табуляцией, точка с запятой, пробел и др. Такие файлы обычно легко открывает LibreOffice, а в Microsoft Excel нужны некоторые трюки. 3.1.3 Загрузка данных: readr, readxl Стандартной функцией для чтения .csv файлов в R является функция read.csv(), но мы будем использовать функцию read_csv() из пакета readr. read_csv(&quot;...&quot;) Вместо многоточия может стоять: название файла (если он, есть в текущей рабочей дериктории) read_csv(&quot;my_file.csv&quot;) относительный путь к файлу (если он, верен для текущей рабочей дериктории) read_csv(&quot;data/my_file.csv&quot;) полный путь к файлу (если он, верен для текущей рабочей дериктории) read_csv(&quot;/home/user_name/work/data/my_file.csv&quot;) интернет ссылка (тогда, компьютер должен быть подключен к интернету) read_csv(&quot;https://my_host/my_file.csv&quot;) Для чтения других форматов .csv файлов используются другие функции: read_tsv() – для файлов с табуляцией в качестве разделителя read_csv2() – для файлов с точкой с запятой в качестве разделителя read_delim(file = \"...\", delim = \"...\") – для файлов с любым разделителем, задаваемым аргументом delim Стандартной практикой является создавать первой строкой .csv файлов названия столбцов, поэтому по умолчанию функции read_...() будут создавать таблицу, считая первую строку названием столбцов. Чтобы изменить это поведение следует использовать аргумент col_names = FALSE. Другая проблема при чтении файлов – кодировка и локаль. На разных компьютерах разные локали и дефолтные кодировки, так что имеет смысл знать про аргумент locale(encoding = \"UTF-8\"). Попробуйте корректно считать в R файл по этой ссылке. ## # A tibble: 3 x 3 ## cyrillic ipa_symbols greek ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 а ʁ α ## 2 б ʔ β ## 3 в ʃ γ Благодаря readxl пакету Также данные можно скачать напрямую из файлов .xls (функция read_xls) и .xlsx (функция read_xlsx), однако эти функции не умеют читать из интернета. library(&quot;readxl&quot;) xlsx_example &lt;- read_xlsx(&quot;...&quot;) Существует еще один экстравагантный способ хранить данные: это формат файлов R .RData. Создадим data.frame: my_df &lt;- data.frame(letters = c(&quot;a&quot;, &quot;b&quot;), numbers = 1:2) my_df ## letters numbers ## 1 a 1 ## 2 b 2 Теперь можно сохранить файл… save(my_df, file = &quot;data/my_df.RData&quot;) удалить переменную… rm(my_df) my_df ## Error in eval(expr, envir, enclos): object &#39;my_df&#39; not found и загрузить все снова: load(&quot;data/my_df.RData&quot;) my_df ## letters numbers ## 1 a 1 ## 2 b 2 3.1.3.1 Misspelling dataset Этот датасет я переработал из данных, собранных для статьи The Gyllenhaal Experiment, написанной Расселом Гольденбергом и Мэттом Дэниэлсом для издания pudding. Они анализировали ошибки в правописании при поиске имен и фамилий звезд. misspellings &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/misspelling_dataset.csv&quot;) ## Parsed with column specification: ## cols( ## correct = col_character(), ## spelling = col_character(), ## count = col_double() ## ) misspellings ## # A tibble: 15,477 x 3 ## correct spelling count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel deschanel 18338 ## 2 deschanel dechanel 1550 ## 3 deschanel deschannel 934 ## 4 deschanel deschenel 404 ## 5 deschanel deshanel 364 ## 6 deschanel dechannel 359 ## 7 deschanel deschanelle 316 ## 8 deschanel dechanelle 192 ## 9 deschanel deschanell 174 ## 10 deschanel deschenal 165 ## # … with 15,467 more rows В датасете следующие переменные: correct – корректное написание фамилии spelling – написание, которое сделали пользователи count – количество случаев такого написания 3.1.3.2 diamonds diamonds ## # A tibble: 53,940 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 ## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 ## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 ## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49 ## 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39 ## # … with 53,930 more rows ?diamonds 3.2 tibble Пакет tibble – является альтернативой штатного датафрейма в R. Существует встроенная переменная month.name: month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; ## [6] &quot;June&quot; &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; ## [11] &quot;November&quot; &quot;December&quot; Можно создать датафрейм таким образом: data.frame(id = 1:12, months = month.name, n_letters = nchar(months)) ## Error in nchar(months): cannot coerce type &#39;closure&#39; to vector of type &#39;character&#39; Однако переменная months не создана пользователем, так что данный код выдает ошибку. Корректный способ сделать это базовыми средствами: data.frame(id = 1:12, months = month.name, n_letters = nchar(month.name)) ## id months n_letters ## 1 1 January 7 ## 2 2 February 8 ## 3 3 March 5 ## 4 4 April 5 ## 5 5 May 3 ## 6 6 June 4 ## 7 7 July 4 ## 8 8 August 6 ## 9 9 September 9 ## 10 10 October 7 ## 11 11 November 8 ## 12 12 December 8 Одно из отличий tibble от базового датафрейма – возможность использовать создаваемые “по ходу пьесы переменные” tibble(id = 1:12, months = month.name, n_letters = nchar(months)) ## # A tibble: 12 x 3 ## id months n_letters ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 1 January 7 ## 2 2 February 8 ## 3 3 March 5 ## 4 4 April 5 ## 5 5 May 3 ## 6 6 June 4 ## 7 7 July 4 ## 8 8 August 6 ## 9 9 September 9 ## 10 10 October 7 ## 11 11 November 8 ## 12 12 December 8 Если в окружении пользователя уже есть переменная с датафреймом, его легко можно переделать в tibble при помощи функции as_tibble(): df &lt;- data.frame(id = 1:12, months = month.name) df ## id months ## 1 1 January ## 2 2 February ## 3 3 March ## 4 4 April ## 5 5 May ## 6 6 June ## 7 7 July ## 8 8 August ## 9 9 September ## 10 10 October ## 11 11 November ## 12 12 December as_tibble(df) ## # A tibble: 12 x 2 ## id months ## &lt;int&gt; &lt;fct&gt; ## 1 1 January ## 2 2 February ## 3 3 March ## 4 4 April ## 5 5 May ## 6 6 June ## 7 7 July ## 8 8 August ## 9 9 September ## 10 10 October ## 11 11 November ## 12 12 December Функицонально tibble от data.frame ничем не отличается, однако существует ряд несущественных отличий. Кроме того стоит помнить, что многие функции из tidyverse возвращают именно tibble, а не data.frame. 3.3 dplyr В сжатом виде содержание этого раздела хранится вот здесь или здесь. 3.3.1 dplyr::filter() Эта функция фильтрует строчки по условиям, основанным на столбцах. Сколько неправильных произношений, которые написали меньше 10 юзеров? misspellings %&gt;% filter(count &lt; 10) ## # A tibble: 14,279 x 3 ## correct spelling count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel deshanael 9 ## 2 deschanel daychanel 9 ## 3 deschanel deschaneles 9 ## 4 deschanel dashenel 9 ## 5 deschanel deschenael 9 ## 6 deschanel deechanel 9 ## 7 deschanel deichanel 9 ## 8 deschanel dechantel 9 ## 9 deschanel deychanel 9 ## 10 deschanel daschenell 9 ## # … with 14,269 more rows %&gt;% — конвеер (pipe) отправляет результат работы одной функции в другую. sort(sqrt(abs(sin(1:22))), decreasing = TRUE) ## [1] 0.9999951 0.9952926 0.9946649 0.9805088 0.9792468 0.9554817 0.9535709 ## [8] 0.9173173 0.9146888 0.8699440 0.8665952 0.8105471 0.8064043 0.7375779 ## [15] 0.7325114 0.6482029 0.6419646 0.5365662 0.5285977 0.3871398 0.3756594 ## [22] 0.0940814 1:22 %&gt;% sin() %&gt;% abs() %&gt;% sqrt() %&gt;% sort(., decreasing = TRUE) # зачем здесь точка? ## [1] 0.9999951 0.9952926 0.9946649 0.9805088 0.9792468 0.9554817 0.9535709 ## [8] 0.9173173 0.9146888 0.8699440 0.8665952 0.8105471 0.8064043 0.7375779 ## [15] 0.7325114 0.6482029 0.6419646 0.5365662 0.5285977 0.3871398 0.3756594 ## [22] 0.0940814 Конвееры в tidyverse пришли из пакета magrittr. Иногда они работают не корректно с функциями не из tidyverse. 3.3.2 dplyr::slice() Эта функция фильтрует строчки по индексу. misspellings %&gt;% slice(3:7) ## # A tibble: 5 x 3 ## correct spelling count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel deschannel 934 ## 2 deschanel deschenel 404 ## 3 deschanel deshanel 364 ## 4 deschanel dechannel 359 ## 5 deschanel deschanelle 316 3.3.3 dplyr::select() Эта функция позволяет выбрать столбцы. diamonds %&gt;% select(8:10) ## # A tibble: 53,940 x 3 ## x y z ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3.95 3.98 2.43 ## 2 3.89 3.84 2.31 ## 3 4.05 4.07 2.31 ## 4 4.2 4.23 2.63 ## 5 4.34 4.35 2.75 ## 6 3.94 3.96 2.48 ## 7 3.95 3.98 2.47 ## 8 4.07 4.11 2.53 ## 9 3.87 3.78 2.49 ## 10 4 4.05 2.39 ## # … with 53,930 more rows diamonds %&gt;% select(color:price) ## # A tibble: 53,940 x 5 ## color clarity depth table price ## &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 E SI2 61.5 55 326 ## 2 E SI1 59.8 61 326 ## 3 E VS1 56.9 65 327 ## 4 I VS2 62.4 58 334 ## 5 J SI2 63.3 58 335 ## 6 J VVS2 62.8 57 336 ## 7 I VVS1 62.3 57 336 ## 8 H SI1 61.9 55 337 ## 9 E VS2 65.1 61 337 ## 10 H VS1 59.4 61 338 ## # … with 53,930 more rows diamonds %&gt;% select(-carat) ## # A tibble: 53,940 x 9 ## cut color clarity depth table price x y z ## &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 ## 7 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 ## 8 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 ## 9 Fair E VS2 65.1 61 337 3.87 3.78 2.49 ## 10 Very Good H VS1 59.4 61 338 4 4.05 2.39 ## # … with 53,930 more rows diamonds %&gt;% select(-c(carat, cut, x, y, z)) ## # A tibble: 53,940 x 5 ## color clarity depth table price ## &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 E SI2 61.5 55 326 ## 2 E SI1 59.8 61 326 ## 3 E VS1 56.9 65 327 ## 4 I VS2 62.4 58 334 ## 5 J SI2 63.3 58 335 ## 6 J VVS2 62.8 57 336 ## 7 I VVS1 62.3 57 336 ## 8 H SI1 61.9 55 337 ## 9 E VS2 65.1 61 337 ## 10 H VS1 59.4 61 338 ## # … with 53,930 more rows diamonds %&gt;% select(cut, depth, price) ## # A tibble: 53,940 x 3 ## cut depth price ## &lt;ord&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Ideal 61.5 326 ## 2 Premium 59.8 326 ## 3 Good 56.9 327 ## 4 Premium 62.4 334 ## 5 Good 63.3 335 ## 6 Very Good 62.8 336 ## 7 Very Good 62.3 336 ## 8 Very Good 61.9 337 ## 9 Fair 65.1 337 ## 10 Very Good 59.4 338 ## # … with 53,930 more rows 3.3.4 dplyr::arrange() Эта функция сортирует (строки по алфавиту, а числа по порядку). misspellings %&gt;% arrange(count) ## # A tibble: 15,477 x 3 ## correct spelling count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel deschil 1 ## 2 deschanel deshauneil 1 ## 3 deschanel deschmuel 1 ## 4 deschanel deshannle 1 ## 5 deschanel deslanges 1 ## 6 deschanel deshoenel 1 ## 7 deschanel dechadel 1 ## 8 deschanel dooschaney 1 ## 9 deschanel dishana 1 ## 10 deschanel deshaneil 1 ## # … with 15,467 more rows diamonds %&gt;% arrange(desc(carat), price) ## # A tibble: 53,940 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5.01 Fair J I1 65.5 59 18018 10.7 10.5 6.98 ## 2 4.5 Fair J I1 65.8 58 18531 10.2 10.2 6.72 ## 3 4.13 Fair H I1 64.8 61 17329 10 9.85 6.43 ## 4 4.01 Premium I I1 61 61 15223 10.1 10.1 6.17 ## 5 4.01 Premium J I1 62.5 62 15223 10.0 9.94 6.24 ## 6 4 Very Good I I1 63.3 58 15984 10.0 9.94 6.31 ## 7 3.67 Premium I I1 62.4 56 16193 9.86 9.81 6.13 ## 8 3.65 Fair H I1 67.1 53 11668 9.53 9.48 6.38 ## 9 3.51 Premium J VS2 62.5 59 18701 9.66 9.63 6.03 ## 10 3.5 Ideal H I1 62.8 57 12587 9.65 9.59 6.03 ## # … with 53,930 more rows 3.3.5 dplyr::distinct() Эта функция возращает уникальные значения в столбце или комбинации столбцов. misspellings %&gt;% distinct(correct) ## # A tibble: 15 x 1 ## correct ## &lt;chr&gt; ## 1 deschanel ## 2 mclachlan ## 3 galifianakis ## 4 labeouf ## 5 macaulay ## 6 mcconaughey ## 7 minaj ## 8 morissette ## 9 poehler ## 10 shyamalan ## 11 kaepernick ## 12 mcgwire ## 13 palahniuk ## 14 picabo ## 15 johansson misspellings %&gt;% distinct(spelling) ## # A tibble: 15,462 x 1 ## spelling ## &lt;chr&gt; ## 1 deschanel ## 2 dechanel ## 3 deschannel ## 4 deschenel ## 5 deshanel ## 6 dechannel ## 7 deschanelle ## 8 dechanelle ## 9 deschanell ## 10 deschenal ## # … with 15,452 more rows diamonds %&gt;% distinct(color, cut) ## # A tibble: 35 x 2 ## color cut ## &lt;ord&gt; &lt;ord&gt; ## 1 E Ideal ## 2 E Premium ## 3 E Good ## 4 I Premium ## 5 J Good ## 6 J Very Good ## 7 I Very Good ## 8 H Very Good ## 9 E Fair ## 10 J Ideal ## # … with 25 more rows Во встроенном в tidyverse датасете starwars отфильтруйте существ выше 180 (height) и весом меньше 80 (mass) и выведите уникальные значений мест, откуда они происходят (homeworld). 3.3.6 dplyr::mutate() Эта функция позволяет создать новые переменные. misspellings %&gt;% mutate(misspelling_length = nchar(spelling), id = 1:n()) ## # A tibble: 15,477 x 5 ## correct spelling count misspelling_length id ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 deschanel deschanel 18338 9 1 ## 2 deschanel dechanel 1550 8 2 ## 3 deschanel deschannel 934 10 3 ## 4 deschanel deschenel 404 9 4 ## 5 deschanel deshanel 364 8 5 ## 6 deschanel dechannel 359 9 6 ## 7 deschanel deschanelle 316 11 7 ## 8 deschanel dechanelle 192 10 8 ## 9 deschanel deschanell 174 10 9 ## 10 deschanel deschenal 165 9 10 ## # … with 15,467 more rows Создайте переменную с индексом Кетле: \\(\\frac{mass}{height^2}\\) для всех существ датасета starwars. Сколько героев страдают ожирением (т. е. имеют индекс массы тела больше 30)? (Не забудьте перевести рост из сантиметров в метры). 3.3.7 dplyr::group_by(...) %&gt;% summarise(...) Эта функция позволяет сгруппировать переменные по какому-то из столбцов и получить какой-нибудь вывод из описательной статистики (максимум, минимум, последний, первый, среднее, медиану и т. п.). misspellings %&gt;% summarise(min(count), mean(count)) ## # A tibble: 1 x 2 ## `min(count)` `mean(count)` ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 21.8 misspellings %&gt;% group_by(correct) %&gt;% summarise(mean(count)) ## # A tibble: 15 x 2 ## correct `mean(count)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel 25.9 ## 2 galifianakis 8.64 ## 3 johansson 74.8 ## 4 kaepernick 29.1 ## 5 labeouf 61.2 ## 6 macaulay 17.6 ## 7 mcconaughey 7.74 ## 8 mcgwire 55.3 ## 9 mclachlan 14.8 ## 10 minaj 140. ## 11 morissette 55.2 ## 12 palahniuk 10.2 ## 13 picabo 23.2 ## 14 poehler 65.3 ## 15 shyamalan 16.9 misspellings %&gt;% group_by(correct) %&gt;% summarise(my_mean = mean(count)) ## # A tibble: 15 x 2 ## correct my_mean ## &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel 25.9 ## 2 galifianakis 8.64 ## 3 johansson 74.8 ## 4 kaepernick 29.1 ## 5 labeouf 61.2 ## 6 macaulay 17.6 ## 7 mcconaughey 7.74 ## 8 mcgwire 55.3 ## 9 mclachlan 14.8 ## 10 minaj 140. ## 11 morissette 55.2 ## 12 palahniuk 10.2 ## 13 picabo 23.2 ## 14 poehler 65.3 ## 15 shyamalan 16.9 Если нужно посчитать количество вхождений, то можно использовать функцию n() в summarise() или же функцию count(): misspellings %&gt;% group_by(correct) %&gt;% summarise(n = n()) ## # A tibble: 15 x 2 ## correct n ## &lt;chr&gt; &lt;int&gt; ## 1 deschanel 1015 ## 2 galifianakis 2633 ## 3 johansson 392 ## 4 kaepernick 779 ## 5 labeouf 449 ## 6 macaulay 1458 ## 7 mcconaughey 2897 ## 8 mcgwire 262 ## 9 mclachlan 1054 ## 10 minaj 200 ## 11 morissette 478 ## 12 palahniuk 1541 ## 13 picabo 460 ## 14 poehler 386 ## 15 shyamalan 1473 misspellings %&gt;% count(correct) ## # A tibble: 15 x 2 ## correct n ## &lt;chr&gt; &lt;int&gt; ## 1 deschanel 1015 ## 2 galifianakis 2633 ## 3 johansson 392 ## 4 kaepernick 779 ## 5 labeouf 449 ## 6 macaulay 1458 ## 7 mcconaughey 2897 ## 8 mcgwire 262 ## 9 mclachlan 1054 ## 10 minaj 200 ## 11 morissette 478 ## 12 palahniuk 1541 ## 13 picabo 460 ## 14 poehler 386 ## 15 shyamalan 1473 А что будет, если в датасете misspellings создать переменную n и зоставить отсортировать по переменным correct и n? Можно даже отсортировать результат: misspellings %&gt;% count(correct, sort = TRUE) ## # A tibble: 15 x 2 ## correct n ## &lt;chr&gt; &lt;int&gt; ## 1 mcconaughey 2897 ## 2 galifianakis 2633 ## 3 palahniuk 1541 ## 4 shyamalan 1473 ## 5 macaulay 1458 ## 6 mclachlan 1054 ## 7 deschanel 1015 ## 8 kaepernick 779 ## 9 morissette 478 ## 10 picabo 460 ## 11 labeouf 449 ## 12 johansson 392 ## 13 poehler 386 ## 14 mcgwire 262 ## 15 minaj 200 Если вы хотите создать не какое-то саммари, а целый дополнительный столбец с этим саммари вместо функции summarise() нужно использовать функцию mutate(): misspellings %&gt;% group_by(correct) %&gt;% mutate(my_mean = mean(count)) ## # A tibble: 15,477 x 4 ## # Groups: correct [15] ## correct spelling count my_mean ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 deschanel deschanel 18338 25.9 ## 2 deschanel dechanel 1550 25.9 ## 3 deschanel deschannel 934 25.9 ## 4 deschanel deschenel 404 25.9 ## 5 deschanel deshanel 364 25.9 ## 6 deschanel dechannel 359 25.9 ## 7 deschanel deschanelle 316 25.9 ## 8 deschanel dechanelle 192 25.9 ## 9 deschanel deschanell 174 25.9 ## 10 deschanel deschenal 165 25.9 ## # … with 15,467 more rows Схематически это выглядит так: В датасете starwars запишите в отдельную переменную среднее значение роста (height) по каждой расе (species). 3.4 Соединение датафреймов 3.4.1 bind_... Это семейство функций позволяет соединять разные датафреймы: my_tbl &lt;- tibble(a = c(1, 5, 2), b = c(&quot;e&quot;, &quot;g&quot;, &quot;s&quot;)) Чтобы соединить строчки датафреймов с одинаковым набором колонок: my_tbl %&gt;% bind_rows(my_tbl) ## # A tibble: 6 x 2 ## a b ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 e ## 2 5 g ## 3 2 s ## 4 1 e ## 5 5 g ## 6 2 s Вместо отсутствующих колонок появятся NA: my_tbl %&gt;% bind_rows(my_tbl[,-1]) ## # A tibble: 6 x 2 ## a b ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 e ## 2 5 g ## 3 2 s ## 4 NA e ## 5 NA g ## 6 NA s Чтобы соединить строчки датафреймов с одинаковым набором строчек (если названия столбцов будут пересекаться, то они будут пронумерованы): my_tbl %&gt;% bind_cols(my_tbl) # соединяет колонки ## # A tibble: 3 x 4 ## a b a1 b1 ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 e 1 e ## 2 5 g 5 g ## 3 2 s 2 s Соединяя датафреймы с разным количеством строк my_tbl %&gt;% bind_cols(my_tbl[-1,]) ## Error: Argument 2 must be length 3, not 2 3.4.2 dplyr::.._join() Эти функции позволяют соединять датафреймы. languages &lt;- data_frame( languages = c(&quot;Selkup&quot;, &quot;French&quot;, &quot;Chukchi&quot;, &quot;Polish&quot;), countries = c(&quot;Russia&quot;, &quot;France&quot;, &quot;Russia&quot;, &quot;Poland&quot;), iso = c(&quot;sel&quot;, &quot;fra&quot;, &quot;ckt&quot;, &quot;pol&quot;) ) ## Warning: `data_frame()` is deprecated, use `tibble()`. ## This warning is displayed once per session. languages ## # A tibble: 4 x 3 ## languages countries iso ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Selkup Russia sel ## 2 French France fra ## 3 Chukchi Russia ckt ## 4 Polish Poland pol country_population &lt;- data_frame( countries = c(&quot;Russia&quot;, &quot;Poland&quot;, &quot;Finland&quot;), population_mln = c(143, 38, 5)) country_population ## # A tibble: 3 x 2 ## countries population_mln ## &lt;chr&gt; &lt;dbl&gt; ## 1 Russia 143 ## 2 Poland 38 ## 3 Finland 5 inner_join(languages, country_population) ## Joining, by = &quot;countries&quot; ## # A tibble: 3 x 4 ## languages countries iso population_mln ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Selkup Russia sel 143 ## 2 Chukchi Russia ckt 143 ## 3 Polish Poland pol 38 left_join(languages, country_population) ## Joining, by = &quot;countries&quot; ## # A tibble: 4 x 4 ## languages countries iso population_mln ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Selkup Russia sel 143 ## 2 French France fra NA ## 3 Chukchi Russia ckt 143 ## 4 Polish Poland pol 38 right_join(languages, country_population) ## Joining, by = &quot;countries&quot; ## # A tibble: 4 x 4 ## languages countries iso population_mln ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Selkup Russia sel 143 ## 2 Chukchi Russia ckt 143 ## 3 Polish Poland pol 38 ## 4 &lt;NA&gt; Finland &lt;NA&gt; 5 anti_join(languages, country_population) ## Joining, by = &quot;countries&quot; ## # A tibble: 1 x 3 ## languages countries iso ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 French France fra anti_join(country_population, languages) ## Joining, by = &quot;countries&quot; ## # A tibble: 1 x 2 ## countries population_mln ## &lt;chr&gt; &lt;dbl&gt; ## 1 Finland 5 full_join(country_population, languages) ## Joining, by = &quot;countries&quot; ## # A tibble: 5 x 4 ## countries population_mln languages iso ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Russia 143 Selkup sel ## 2 Russia 143 Chukchi ckt ## 3 Poland 38 Polish pol ## 4 Finland 5 &lt;NA&gt; &lt;NA&gt; ## 5 France NA French fra 3.5 tidyr package Давайте посмотрим на датасет с количеством носителей разных языков в Индии согласно переписи 2001 года (данные из Википедии): langs_in_india_short &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/languages_in_india.csv&quot;) ## Parsed with column specification: ## cols( ## language = col_character(), ## n_L1_sp = col_double(), ## n_L2_sp = col_double(), ## n_L3_sp = col_double(), ## n_all_sp = col_double() ## ) Short format langs_in_india_short ## # A tibble: 12 x 5 ## language n_L1_sp n_L2_sp n_L3_sp n_all_sp ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hindi 422048642 98207180 31160696 551416518 ## 2 English 226449 86125221 38993066 125344736 ## 3 Bengali 83369769 6637222 1108088 91115079 ## 4 Telugu 74002856 9723626 1266019 84992501 ## 5 Marathi 71936894 9546414 2701498 84184806 ## 6 Tamil 60793814 4992253 956335 66742402 ## 7 Urdu 51536111 6535489 1007912 59079512 ## 8 Kannada 37924011 11455287 1396428 50775726 ## 9 Gujarati 46091617 3476355 703989 50271961 ## 10 Odia 33017446 3272151 319525 36609122 ## 11 Malayalam 33066392 499188 195885 33761465 ## 12 Sanskrit 14135 1234931 3742223 4991289 Long format ## # A tibble: 48 x 3 ## language type n_speakers ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Hindi n_L1_sp 422048642 ## 2 Hindi n_L2_sp 98207180 ## 3 Hindi n_L3_sp 31160696 ## 4 Hindi n_all_sp 551416518 ## 5 English n_L1_sp 226449 ## 6 English n_L2_sp 86125221 ## 7 English n_L3_sp 38993066 ## 8 English n_all_sp 125344736 ## 9 Bengali n_L1_sp 83369769 ## 10 Bengali n_L2_sp 6637222 ## # … with 38 more rows Short format → Long format: tidyr::pivot_longer() langs_in_india_short %&gt;% pivot_longer(names_to = &quot;type&quot;, values_to = &quot;n_speakers&quot;, n_L1_sp:n_all_sp)-&gt; langs_in_india_long langs_in_india_long ## # A tibble: 48 x 3 ## language type n_speakers ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Hindi n_L1_sp 422048642 ## 2 Hindi n_L2_sp 98207180 ## 3 Hindi n_L3_sp 31160696 ## 4 Hindi n_all_sp 551416518 ## 5 English n_L1_sp 226449 ## 6 English n_L2_sp 86125221 ## 7 English n_L3_sp 38993066 ## 8 English n_all_sp 125344736 ## 9 Bengali n_L1_sp 83369769 ## 10 Bengali n_L2_sp 6637222 ## # … with 38 more rows Long format → Short format: tidyr::pivot_wider() langs_in_india_long %&gt;% pivot_wider(names_from = &quot;type&quot;, values_from = &quot;n_speakers&quot;)-&gt; langs_in_india_short langs_in_india_short ## # A tibble: 12 x 5 ## language n_L1_sp n_L2_sp n_L3_sp n_all_sp ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hindi 422048642 98207180 31160696 551416518 ## 2 English 226449 86125221 38993066 125344736 ## 3 Bengali 83369769 6637222 1108088 91115079 ## 4 Telugu 74002856 9723626 1266019 84992501 ## 5 Marathi 71936894 9546414 2701498 84184806 ## 6 Tamil 60793814 4992253 956335 66742402 ## 7 Urdu 51536111 6535489 1007912 59079512 ## 8 Kannada 37924011 11455287 1396428 50775726 ## 9 Gujarati 46091617 3476355 703989 50271961 ## 10 Odia 33017446 3272151 319525 36609122 ## 11 Malayalam 33066392 499188 195885 33761465 ## 12 Sanskrit 14135 1234931 3742223 4991289 Вот здесь лежит датасет, который содержит информацию о селах в Дагестане в формате .xlsx. Данные разделены по разным листам и содержат следующие переменные (данные получены из разных источников, поэтому имеют суффикс _s1 – первый источник и _s2 – второй источник): id_s1 – (s1) идентификационный номер из первого источника; name_1885 – (s1) название селения из переписи 1885 census_1885 – (s1) число людей из переписи 1885 name_1895 – (s1) название селения из переписи 1895 census_1895 – (s1) число людей из переписи 1895 name_1926 – (s1) название селения из переписи 1926 language_s1 – (s1) язык данного селения согласно первому источнику census_1926 – (s1) число людей из переписи 1926 name_2010 – (s1) название селения из переписи 2010 census_2010 – (s1) число людей из переписи 2010 name_s2 – (s2) название селения согласно второму источнику language_s2 – (s2) язык данного селения согласно первому источнику Lat – (s2) широта селения Lon – (s2) долгота селения elevation – (s2) высота селения над уровнем моря Во-первых, объедините все листы .xlsx воедино: ## # A tibble: 6 x 15 ## id_s1 name_1885 census_1885 name_1895 census_1895 name_1926 language_s1 ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 15 Амишта (… 122 Амишта (… 141 Амишта Avar ## 2 17 Джалатлу… 169 Джалатру… 190 Джалатлу… Avar ## 3 19 Цалкита 102 Цалкита 97 Цалкита Avar ## 4 21 Амуши-бо… 581 Амуши Бо… 550 Амуши бо… Avar ## 5 23 Амуши ма… 159 Амуши Ма… 137 Амуши ма… Avar ## 6 25 Андик (Х… 557 Андых (А… 595 Андых Avar ## # … with 8 more variables: census_1926 &lt;dbl&gt;, name_2010 &lt;chr&gt;, ## # census_2010 &lt;dbl&gt;, name_s2 &lt;chr&gt;, language_s2 &lt;chr&gt;, Lat &lt;dbl&gt;, ## # Lon &lt;dbl&gt;, elevation &lt;dbl&gt; Во-вторых, посчитайте, относительно скольких селений первый и второй источник согласуются относительно языка селения. В-третьих, посчитайте среднюю высоту над уровнем моря для языков из первого источника. Какой выше всех? В-четвертых, посчитайте количество населения, которое говорило на каждом из языков из второго датасета, согласно каждой переписи. Приведите значения для лакского языка (Lak). ## # A tibble: 25 x 5 ## language_s2 `s_1885 &lt;- sum(… `s_1895 &lt;- sum(… `s_1926 &lt;- sum(… ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Aghul 6577 6813 7886 ## 2 Akhvakh 3535 3229 2697 ## 3 Andi 4600 4543 4583 ## 4 Archi 804 765 126 ## 5 Avar 110191 123363 103565 ## 6 Bagvalal 2807 2625 3049 ## 7 Bezhta 2330 2546 1270 ## 8 Botlikh 1383 1323 1346 ## 9 Chamalal 3731 3742 2714 ## 10 Chechen 396 344 524 ## # … with 15 more rows, and 1 more variable: `s_2010 &lt;- ## # sum(census_2010)` &lt;dbl&gt; 3.6 Полезные надстройки Существует достаточно много пакетов надстроек для tidyverse. tidylog – делает лог пайпов: library(tidylog) ## ## Attaching package: &#39;tidylog&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## add_count, add_tally, anti_join, count, distinct, ## distinct_all, distinct_at, distinct_if, filter, filter_all, ## filter_at, filter_if, full_join, group_by, group_by_all, ## group_by_at, group_by_if, inner_join, left_join, mutate, ## mutate_all, mutate_at, mutate_if, right_join, select, ## select_all, select_at, select_if, semi_join, summarise, ## summarise_all, summarise_at, summarise_if, summarize, ## summarize_all, summarize_at, summarize_if, tally, top_n, ## transmute, transmute_all, transmute_at, transmute_if ## The following objects are masked from &#39;package:tidyr&#39;: ## ## drop_na, fill, gather, replace_na, spread ## The following object is masked from &#39;package:stats&#39;: ## ## filter mtcars %&gt;% group_by(cyl, gear) %&gt;% summarise(mean_mpg = mean(mpg)) %&gt;% pivot_wider(names_from = gear, values_from = mean_mpg) ## group_by: 2 grouping variables (cyl, gear) ## summarise: now 8 rows and 3 columns, one group variable remaining (cyl) ## # A tibble: 3 x 4 ## # Groups: cyl [3] ## cyl `3` `4` `5` ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4 21.5 26.9 28.2 ## 2 6 19.8 19.8 19.7 ## 3 8 15.0 NA 15.4 dtplyr – позволяет вызывать функции dplyr, но используя data.table внутри. Это полезно для работы с большими датасетами. sparklyr – связывает R с Apache Spark (инструмент для кластерных вычислений) … "]
]
