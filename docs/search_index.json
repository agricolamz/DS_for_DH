[
["сбор-данных-из-интернета-rvest.html", "12 Сбор данных из интернета: rvest 12.1 Введение 12.2 Работа с пакетом rvest 12.3 Использование атрибута class", " 12 Сбор данных из интернета: rvest library(tidyverse) Достаточно часто данные не ходят упакованные в готовые файлы .csv или .json. Иногда данные лежат в открытом доступе на какой-нибудь странице в интернете (например, таблицы Левада-центра из предыдущего занятия). А иногда никто и не думал, что что-то станет данными: заголовки и тексты новостей, комментарии, твиты и т. п. В этом разделе мы обсудим основы извлечения данных из вебстраниц. 12.1 Введение Любая html-документ — это обычный xml файл. Обычно самый верхний узел называется html, который имеет два дочерних узла head и body. Каждый html-документ является инструкцией для браузера, в которой говориться что и в каком порядке нужно отображать, но одновременно эта инструкция является кодом, который мы можем посмотреть. В большинстве браузеров это можно сделать при помощи горячих клавиш Ctrl+U, в Apple Safari — Cmd+Option+U. Кроме того есть режим разработчика, который позволяет делать много всего, в том числе наводить на какой-то объект в браузере и узнавать какой фрагмент кода ему соответствует (этот режим можно вызвать, нажав F12 или Ctrl+Shift+I, в Apple Safari вроде нет горячих клавиш и нужно вызывать как-то из меню). Большинство узлов html-документа состоят из тег узла, например, p значения узла, например, Жили-были три медведя. id (уникальные объекты в html-документе), class (неуникальные объекты в html-документе) и другием атрибуты узла Например: &lt;p class=&quot;story&quot; some_atribute = 42&gt;Жили-были три медведя.&lt;/p&gt; Некоторые html-документ не являются статическими и изменяются после того, как страница была открыта при помощи JavaScript’а. Это динамичность может быть скрытой, когда пользователь лишь видит, как открывается страница, а иногда может быть завязана на некоторые действия пользователя. Информацию со статических страниц собирать достаточно просто и для этого нам хватит пакета rvest. C динамическими сайтами все иногда несколько сложнее. Иногда на диномических страницах можно отследить источник данных, посмотрев вкладку Network в режиме разработчика (ведь откуда-то эти данные появляются в браузере, правда?). Иногда необходимо делать POST и GET запросы, хранить cookies, и т. п. — все это можно сделать при помощи пакета httr, а в самых сложных случаях (когда JavaScript JavaScript погоняет) поможет пакет RSelenium. 12.2 Работа с пакетом rvest Пакет rvest позволяет скачивать страницы и потом их обрабатывать. Включим библиотеку: library(rvest) ## Loading required package: xml2 ## ## Attaching package: &#39;rvest&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## pluck ## The following object is masked from &#39;package:readr&#39;: ## ## guess_encoding 12.2.1 Простой случай В качестве примера рассмотрим сайт Центра цифровых гуманитарных исследований НИУ ВШЭ: source &lt;- read_html(&quot;https://hum.hse.ru/digital&quot;) Объект source является списком, который содержит html-страницу. Давайте допустим, что мы хотем скачать все заголовки новостей, т. е. нам нужны значения всех узло h2. Функция html_nodes() позволяет вычленить исключительно узлы с каким-то тегом из всего xml-файла. source %&gt;% html_nodes(&quot;h2&quot;) ## {xml_nodeset (10)} ## [1] &lt;h2 class=&quot;first_child &quot;&gt;&lt;a title=&quot;Где кутил Чайковский? Мастер-класс по ... ## [2] &lt;h2 class=&quot;first_child &quot;&gt;&lt;a title=&quot;К полету готовы: школа по Digital Hum ... ## [3] &lt;h2 class=&quot;first_child &quot;&gt;&lt;a title=&quot;Terra Oblita: открытая карта памяти з ... ## [4] &lt;h2 class=&quot;first_child &quot;&gt;&lt;a title=&quot;Мир до вас дорастет: запущена первая ... ## [5] &lt;h2 class=&quot;first_child &quot;&gt;&lt;a title=&quot;Лес, сосиски, (не)работающий код: вто ... ## [6] &lt;h2 class=&quot;first_child &quot;&gt;&lt;a title=&quot;Цифровые гуманитарии из Вышки выступи ... ## [7] &lt;h2 class=&quot;first_child &quot;&gt;&lt;a title=&quot;Новая книга Бориса Орехова&quot; href=&quot;htt ... ## [8] &lt;h2 class=&quot;first_child &quot;&gt;&lt;a title=&quot;«12-часовой хакатон промелькнул на од ... ## [9] &lt;h2 class=&quot;first_child &quot;&gt;&lt;a title=&quot;Эротический корпус, статистика и рок- ... ## [10] &lt;h2 class=&quot;first_child &quot;&gt;&lt;a title=&quot;Корочун — это когда? О переводе «внут ... Теперь если мы хотим обратиться к значениям этих узлов, мы можем использовать функцию html_text() source %&gt;% html_nodes(&quot;h2&quot;) %&gt;% html_text() ## [1] &quot;Где кутил Чайковский? Мастер-класс по культурным GIS от St.Retrospect&quot; ## [2] &quot;К полету готовы: школа по Digital Humanities как предчувствие гуманитарного космоса&quot; ## [3] &quot;Terra Oblita: открытая карта памяти забытых жертв нацизма&quot; ## [4] &quot;Мир до вас дорастет: запущена первая DH-ма­ги­стра­ту­ра в Москве&quot; ## [5] &quot;Лес, сосиски, (не)работающий код: второй хакатон по Digital Humanities&quot; ## [6] &quot;Цифровые гуманитарии из Вышки выступили в Принстоне&quot; ## [7] &quot;Новая книга Бориса Орехова&quot; ## [8] &quot;«12-часовой хакатон промелькнул на одном дыхании»&quot; ## [9] &quot;Эротический корпус, статистика и рок-н-ролл!&quot; ## [10] &quot;Корочун — это когда? О переводе «внутренней механики» древнерусского календаря на электронные рельсы&quot; Если мы откроем превью узла h2 (команда View()), то мы увидим что-то такое: Эта схема показывает, что каждый узел h2 содержит узел a который содержит три атрибута: title и href. Вложенность отображается знаком &gt;, а обращаться к атрибутам можно, используя функцию html_attr(): source %&gt;% html_nodes(&quot;h2 &gt; a&quot;) %&gt;% html_attr(&quot;title&quot;) -&gt; titles source %&gt;% html_nodes(&quot;h2 &gt; a&quot;) %&gt;% html_attr(&quot;href&quot;) -&gt; links tibble(titles, links) Как видно из получившейся таблицы, на первой странице сайта всего 10 новостей. А что если мы хотим скачать все новости? Исследовав страницу Центра цифровых гуманитарных исследований, становится понятно, что все новые страницы генерятся по одному и тому же паттерну: https://hum.hse.ru/digital/news/page2.html https://hum.hse.ru/digital/news/page3.html … https://hum.hse.ru/digital/news/page6.html и даже на первую страницу, на которую мы попали по короткому адресу &lt;hum.hse.ru/digital&gt;, можно также попасть по этому адресу https://hum.hse.ru/digital/news/page1.html Сгенерим список страниц: str_c(&quot;https://hum.hse.ru/digital/news/page&quot;, 1:6, &quot;.html&quot;) ## [1] &quot;https://hum.hse.ru/digital/news/page1.html&quot; ## [2] &quot;https://hum.hse.ru/digital/news/page2.html&quot; ## [3] &quot;https://hum.hse.ru/digital/news/page3.html&quot; ## [4] &quot;https://hum.hse.ru/digital/news/page4.html&quot; ## [5] &quot;https://hum.hse.ru/digital/news/page5.html&quot; ## [6] &quot;https://hum.hse.ru/digital/news/page6.html&quot; А теперь сделаем функцию, которая ходит по страницам и все собирает map_dfr(str_c(&quot;https://hum.hse.ru/digital/news/page&quot;, 1:6, &quot;.html&quot;), function(x){ source &lt;- read_html(x) source %&gt;% html_nodes(&quot;h2 &gt; a&quot;) %&gt;% html_attr(&quot;title&quot;) -&gt; titles source %&gt;% html_nodes(&quot;h2 &gt; a&quot;) %&gt;% html_attr(&quot;href&quot;) -&gt; links tibble(titles, links) }) -&gt; df_news df_news Создайте датафрейм, содержащий заголовки и ссылки на новости со страницы Магистерской программы «Цифровые методы в гуманитарных науках». 12.3 Использование атрибута class Допустим, нас интересует дата создания новости на странице Центра цифровых гуманитарных исследований. Исследовав сайт, легко обнаружить, что информация о дате создания новости хранится в теге span. Однако, если мы попробуем использовать лишь эту информацию, то мы получим много лишнего: source %&gt;% html_nodes(&quot;span&quot;) %&gt;% html_text() %&gt;% head(20) ## [1] &quot;\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t&quot; ## [2] &quot;&quot; ## [3] &quot;\\n\\t\\t\\t\\t\\t\\t\\tvision&quot; ## [4] &quot;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tНайти\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tРасширенный поиск по сайту\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t&quot; ## [5] &quot;&quot; ## [6] &quot;Национальный исследовательский университет «Высшая школа экономики»&quot; ## [7] &quot;Учебные подразделения&quot; ## [8] &quot;Факультет гуманитарных наук&quot; ## [9] &quot;\\n\\t\\t\\t\\t\\t\\tЦентр цифровых гуманитарных исследований НИУ ВШЭ\\n\\t\\t\\t\\t\\t&quot; ## [10] &quot;Центр цифровых гуманитарных исследований НИУ ВШЭ&quot; ## [11] &quot;\\n\\t\\t\\t\\t\\t\\tvision&quot; ## [12] &quot;&quot; ## [13] &quot;&quot; ## [14] &quot;Главное&quot; ## [15] &quot;Школы по Digital Humanities&quot; ## [16] &quot;&quot; ## [17] &quot;Приглашенные исследователи&quot; ## [18] &quot;&quot; ## [19] &quot;Видео&quot; ## [20] &quot;&quot; Дело в том, что тег span имеется у многих других объектов на странице. Однако, если присмотреться к значениям, которые мы находим в режиме разработчика, можно заметить следующее: Если посмотреть код, то мы увидем следующее: ... &lt;span class=&quot;post__date&quot;&gt; 17 декабря, 2019 г.&lt;/span&gt; ... Чтобы обратиться к таким элементам нужно использовать точку: source %&gt;% html_nodes(&quot;span.post__date&quot;) %&gt;% html_text() ## [1] &quot;\\n\\t\\t\\t\\t\\t\\t17 декабря, 2019 г.\\n\\t\\t\\t\\t\\t&quot; ## [2] &quot;\\n\\t\\t\\t\\t\\t\\t3 декабря, 2019 г.\\n\\t\\t\\t\\t\\t&quot; ## [3] &quot;\\n\\t\\t\\t\\t\\t\\t6 октября, 2019 г.\\n\\t\\t\\t\\t\\t&quot; ## [4] &quot;\\n\\t\\t\\t\\t\\t\\t7 сентября, 2019 г.\\n\\t\\t\\t\\t\\t&quot; ## [5] &quot;\\n\\t\\t\\t\\t\\t\\t30 августа, 2019 г.\\n\\t\\t\\t\\t\\t&quot; ## [6] &quot;\\n\\t\\t\\t\\t\\t\\t24 августа, 2019 г.\\n\\t\\t\\t\\t\\t&quot; ## [7] &quot;\\n\\t\\t\\t\\t\\t\\t4 июля, 2019 г.\\n\\t\\t\\t\\t\\t&quot; ## [8] &quot;\\n\\t\\t\\t\\t\\t\\t3 мая, 2019 г.\\n\\t\\t\\t\\t\\t&quot; ## [9] &quot;\\n\\t\\t\\t\\t\\t\\t2 мая, 2019 г.\\n\\t\\t\\t\\t\\t&quot; ## [10] &quot;\\n\\t\\t\\t\\t\\t\\t10 апреля, 2019 г.\\n\\t\\t\\t\\t\\t&quot; Почистим: source %&gt;% html_nodes(&quot;span.post__date&quot;) %&gt;% html_text() %&gt;% str_remove_all(&quot;\\\\n|\\\\t&quot;) ## [1] &quot;17 декабря, 2019 г.&quot; &quot;3 декабря, 2019 г.&quot; &quot;6 октября, 2019 г.&quot; ## [4] &quot;7 сентября, 2019 г.&quot; &quot;30 августа, 2019 г.&quot; &quot;24 августа, 2019 г.&quot; ## [7] &quot;4 июля, 2019 г.&quot; &quot;3 мая, 2019 г.&quot; &quot;2 мая, 2019 г.&quot; ## [10] &quot;10 апреля, 2019 г.&quot; Постройте график, показывающий количество новостей Центра цифровых гуманитарных исследований за каждый месяц. 12.3.1 Чтение таблиц Таблицы, которые хранятся на html-странице можно считывать как таблицы (а, не например, построчно). Рассмотрим вкладку “Число студентов и вакантные места” на сайте Магистерской программы «Цифровые методы в гуманитарных науках»: source &lt;- read_html(&quot;https://www.hse.ru/ma/dh/vacant&quot;) source %&gt;% html_node(&quot;table&quot;) %&gt;% html_table() Функция html_node() возвращает первую таблицу на странице. В предыдущих разделах мы использовали функцию html_nodes(), которая вытаскивает все узлы с соответствующими атрибутами: source %&gt;% html_nodes(&quot;table&quot;) %&gt;% html_table() -&gt; l str(l) ## List of 3 ## $ :&#39;data.frame&#39;: 4 obs. of 2 variables: ## ..$ X1: chr [1:4] &quot;Общий контингент студентов&quot; &quot;из них на местах, финансируемых за счет субсидий из федерального бюджета на выполнение государственного задания&quot; &quot;из них на местах по договорам об оказании платных образовательных услуг&quot; &quot;из них на местах, финансируемых в рамках межправительственных соглашений&quot; ## ..$ X2: int [1:4] 21 18 3 0 ## $ :&#39;data.frame&#39;: 2 obs. of 2 variables: ## ..$ X1: chr [1:2] &quot;1 курс&quot; &quot;2 курс&quot; ## ..$ X2: logi [1:2] NA NA ## $ :&#39;data.frame&#39;: 3 obs. of 3 variables: ## ..$ X1: chr [1:3] &quot;&quot; &quot;1 курс&quot; &quot;2 курс&quot; ## ..$ X2: chr [1:3] &quot;места, финансируемые за счет субсидий из федерального бюджета на выполнение государственного задания&quot; &quot;0&quot; &quot;&quot; ## ..$ X3: chr [1:3] &quot;места по договорам об оказании платных образовательных услуг&quot; &quot;0&quot; &quot;&quot; Получился список (объект типа list), в котором содержаться все таблицы со страницы. Так что, для того, чтобы работать с конкретной таблицей нужно использовать индексацию списков: l[[1]] 12.3.2 Некоторые советы Некоторые ресурсы блокируют возможность скачивать из них данные. Обычно это делается на уровне сервера, который видит, что с какого-то IP приходит по 5 запросов в секунду и ограничивает доступ, на случай если вы начинаете DDoS атаку. Если сервер не отдает вам данные или отдает, но раз в какой-то временной промежуток, следует прописать в вашей программе ожидание (команда Sys.sleep()). Некоторые сайты, например, Википедия, специально архивирует данные, чтобы люди не пытались ее обкачать: вот страница, на которой это подробно описано. "]
]
