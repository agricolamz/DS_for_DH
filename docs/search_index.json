[
["functions.html", "8 Собственные функции и использование их в tidyverse 8.1 Напоминание: логические операции 8.2 Создание собственных функций 8.3 Использование условий в tidyverse 8.4 Reinvent the map function", " 8 Собственные функции и использование их в tidyverse library(tidyverse) 8.1 Напоминание: логические операции Логическое “и”: &amp; TRUE FALSE TRUE TRUE FALSE FALSE FALSE FALSE TRUE &amp; TRUE ## [1] TRUE TRUE &amp; FALSE ## [1] FALSE Логическое “или”: | TRUE FALSE TRUE TRUE TRUE FALSE TRUE FALSE TRUE | TRUE ## [1] TRUE TRUE | FALSE ## [1] TRUE Логическое “не”: !TRUE ## [1] FALSE Сравнение: 2 == 2 ## [1] TRUE 2 == 3 ## [1] FALSE 2 != 3 ## [1] TRUE 2 != c(2, 3) ## [1] FALSE TRUE 8.2 Создание собственных функций Собственные функции можно сделать с помощью функции function(). Ее можно записать в переменную и использовать: n_syllables &lt;- function(x){ str_count(x, &quot;[АОУЁЕЭЯИЮаоуёеэяию]&quot;) } n_syllables(&quot;корова&quot;) ## [1] 3 n_syllables(&quot;слон&quot;) ## [1] 1 Вообще, функции немного зависят от загруженных пакетов, так что безопаснее либо эксплицитно включать билиотеку внутри функции, или же говорить, из какой библиотеки функция: n_syllables &lt;- function(x){ stringr::str_count(x, &quot;[АОУЁЕЭЯИЮаоуёеэяию]&quot;) } Функцию можно вызывать внутри себя самой (рекурсия), вот так будет выглядеть функция, которая считает факториал: factorial &lt;- function(x){ if(x-1 &gt; 0){ x*factorial(x-1) } else { 1 } } factorial(3) ## [1] 6 factorial(4) ## [1] 24 factorial(8) ## [1] 40320 factorial(0) ## [1] 1 Напишите свою функцию, которая будет сравнивать, какое слово длиннее: which_is_longer(&quot;роза&quot;, &quot;цветок&quot;) ## [1] &quot;цветок&quot; which_is_longer(&quot;олень&quot;, &quot;животное&quot;) ## [1] &quot;животное&quot; which_is_longer(&quot;воробей&quot;, &quot;птица&quot;) ## [1] &quot;воробей&quot; 8.3 Использование условий в tidyverse 8.3.1 Условия в строчках Мы уже визуализировали данные из статьи на Pudding про английские пабы. Часть названий этих пабов имеет слово Inn, давайте построим график распределения 30 самых популярных пабов с этим словом в названии и без него. Используя известные нам инструменты можно получить что-то в этом роде: uk_pubs &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/UK_pubs.csv&quot;) uk_pubs %&gt;% count(pub_name, sort = TRUE) %&gt;% mutate(inn = str_detect(pub_name, &quot;Inn&quot;)) %&gt;% group_by(inn) %&gt;% slice(1:20) %&gt;% ggplot(aes(fct_reorder(pub_name, n), n))+ geom_col()+ coord_flip()+ facet_wrap(~inn, scale = &quot;free&quot;)+ labs(x = &quot;&quot;, y = &quot;&quot;, caption = &quot;https://pudding.cool/2019/10/pubs/&quot;) Получилось в целом то, что мы хотели, однако названия TRUE и FALSE не самые удачные. Исправить положение можно при помощи функции ifelse(), у которой три аргумента: условие, значение, если условие принимает значение TRUE, значение, если условие принимает значение FALSE. ifelse(2+2 == 4, &quot;правильно&quot;, &quot;неправильно&quot;) ## [1] &quot;правильно&quot; ifelse(2+2 == 5, &quot;правильно&quot;, &quot;неправильно&quot;) ## [1] &quot;неправильно&quot; Вставим эту функцию в уже написанные код: uk_pubs %&gt;% count(pub_name, sort = TRUE) %&gt;% mutate(inn = ifelse(str_detect(pub_name, &quot;Inn&quot;), &quot;with &#39;inn&#39;&quot;, &quot;without &#39;inn&#39;&quot;)) %&gt;% group_by(inn) %&gt;% slice(1:20) %&gt;% ggplot(aes(fct_reorder(pub_name, n), n))+ geom_col()+ coord_flip()+ facet_wrap(~inn, scale = &quot;free&quot;)+ labs(x = &quot;&quot;, y = &quot;&quot;, caption = &quot;https://pudding.cool/2019/10/pubs/&quot;) А что если условий больше? В целом, выражение ifelse() можно вложить в выражение ifelse(), однако для таких случаев придумали функцию case_when(). У нее немного необычный синтаксис: case_when( условие 1 ~ значение x, условие 2 ~ значение y, ... условие n ~ значение z ) Давайте в том же датасете посмотрим на названия со словами Inn, Hotel, Bar, House и Tavern: uk_pubs %&gt;% count(pub_name, sort = TRUE) %&gt;% mutate(place = case_when( str_detect(pub_name, &quot;Inn&quot;) ~ &quot;inn&quot;, str_detect(pub_name, &quot;Hotel&quot;) ~ &quot;hotel&quot;, str_detect(pub_name, &quot;Bar&quot;) ~ &quot;bar&quot;, str_detect(pub_name, &quot;House&quot;) ~ &quot;house&quot;, str_detect(pub_name, &quot;Tavern&quot;) ~ &quot;tavern&quot;)) %&gt;% group_by(place) %&gt;% slice(1:10) %&gt;% ggplot(aes(fct_reorder(pub_name, n), n))+ geom_col()+ coord_flip()+ facet_wrap(~place, scale = &quot;free&quot;)+ labs(x = &quot;&quot;, y = &quot;&quot;, caption = &quot;https://pudding.cool/2019/10/pubs/&quot;) Варинат NA, как видно из графика, соответствует всем оставшимся вариантам, которые не подпали ни под одно из наших условий. Чтобы учесть и этот случай, нужно добавить условие TRUE: uk_pubs %&gt;% count(pub_name, sort = TRUE) %&gt;% mutate(place = case_when( str_detect(pub_name, &quot;Inn&quot;) ~ &quot;inn&quot;, str_detect(pub_name, &quot;Hotel&quot;) ~ &quot;hotel&quot;, str_detect(pub_name, &quot;Bar&quot;) ~ &quot;bar&quot;, str_detect(pub_name, &quot;House&quot;) ~ &quot;house&quot;, str_detect(pub_name, &quot;Tavern&quot;) ~ &quot;tavern&quot;, TRUE ~ &quot;other&quot;)) %&gt;% group_by(place) %&gt;% slice(1:10) %&gt;% ggplot(aes(fct_reorder(pub_name, n), n))+ geom_col()+ coord_flip()+ facet_wrap(~place, scale = &quot;free&quot;)+ labs(x = &quot;&quot;, y = &quot;&quot;, caption = &quot;https://pudding.cool/2019/10/pubs/&quot;) Мы уже визуализировали данные из статьи на Pudding “Finding Forever Homes”, заполните пропус, чтобы получить возростно-половую пирамиду собак в США. Когда построите приведенный график, раскомментируйте закомментированную строчку и посмотрите на результат. dogs &lt;- read_csv(&quot;https://raw.githubusercontent.com/r-classes/2019_2020_ds4dh_hw_2_dplyr_tidyr_ggplot2/master/data/dog_names.csv&quot;) dogs %&gt;% filter(sex != &quot;Unknown&quot;) %&gt;% count(sex, contact_state) %&gt;% group_by(contact_state) %&gt;% mutate( ... ) %&gt;% ggplot(aes(fct_reorder(contact_state, sum), n, fill = sex))+ geom_col()+ # scale_y_continuous(breaks = -2:2*1000, labels = abs(-2:2)*1000)+ coord_flip()+ labs(x = &quot;&quot;, y = &quot;&quot;, caption = &quot;data from https://pudding.cool/2019/10/shelters/&quot;)+ scale_fill_brewer(palette =&quot;Dark2&quot;) 8.3.2 Условия в столбцах Что если хочется применить summarise() или mutate() лишь к определенным колонкам? Для этого можно использовать функции summarise_at() или mutate_at().Например, посчитать среднее во всех колонках датасета iris, которые начинаются со слова “Sepal”. iris %&gt;% head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa iris %&gt;% summarise_at(vars(starts_with(&quot;Sepal&quot;)), mean) ## Sepal.Length Sepal.Width ## 1 5.843333 3.057333 На месте функции starts_with() могут быть и другие: ends_with() – заканчивается iris %&gt;% summarise_at(vars(ends_with(&quot;Width&quot;)), mean) ## Sepal.Width Petal.Width ## 1 3.057333 1.199333 matches() – соответствует регулярному выражению iris %&gt;% summarise_at(vars(matches(&quot;Sepal&quot;)), mean) ## Sepal.Length Sepal.Width ## 1 5.843333 3.057333 one_off() – из предложенного вектора значений diamonds %&gt;% summarise_at(vars(one_of(c(&quot;depth&quot;, &quot;price&quot;, &quot;carat&quot;))), mean) ## # A tibble: 1 x 3 ## depth price carat ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 61.7 3933. 0.798 Так же, используя функцию summarise_if(), можно применять какую-то операцию к каждой колонке, если она соответствует какому-то условию (обычно это используют для проверки типов переменных): diamonds %&gt;% summarise_if(is.numeric, mean) ## # A tibble: 1 x 7 ## carat depth table price x y z ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.798 61.7 57.5 3933. 5.73 5.73 3.54 Вот несколько примеров с mutate_..(): diamonds ## # A tibble: 53,940 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 ## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 ## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 ## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49 ## 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39 ## # … with 53,930 more rows diamonds %&gt;% mutate_at(vars(one_of(c(&quot;depth&quot;, &quot;price&quot;, &quot;carat&quot;))), sqrt) ## # A tibble: 53,940 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.480 Ideal E SI2 7.84 55 18.1 3.95 3.98 2.43 ## 2 0.458 Premium E SI1 7.73 61 18.1 3.89 3.84 2.31 ## 3 0.480 Good E VS1 7.54 65 18.1 4.05 4.07 2.31 ## 4 0.539 Premium I VS2 7.90 58 18.3 4.2 4.23 2.63 ## 5 0.557 Good J SI2 7.96 58 18.3 4.34 4.35 2.75 ## 6 0.490 Very Good J VVS2 7.92 57 18.3 3.94 3.96 2.48 ## 7 0.490 Very Good I VVS1 7.89 57 18.3 3.95 3.98 2.47 ## 8 0.510 Very Good H SI1 7.87 55 18.4 4.07 4.11 2.53 ## 9 0.469 Fair E VS2 8.07 61 18.4 3.87 3.78 2.49 ## 10 0.480 Very Good H VS1 7.71 61 18.4 4 4.05 2.39 ## # … with 53,930 more rows diamonds %&gt;% mutate_if(is.numeric, sqrt) ## # A tibble: 53,940 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.480 Ideal E SI2 7.84 7.42 18.1 1.99 1.99 1.56 ## 2 0.458 Premium E SI1 7.73 7.81 18.1 1.97 1.96 1.52 ## 3 0.480 Good E VS1 7.54 8.06 18.1 2.01 2.02 1.52 ## 4 0.539 Premium I VS2 7.90 7.62 18.3 2.05 2.06 1.62 ## 5 0.557 Good J SI2 7.96 7.62 18.3 2.08 2.09 1.66 ## 6 0.490 Very Good J VVS2 7.92 7.55 18.3 1.98 1.99 1.57 ## 7 0.490 Very Good I VVS1 7.89 7.55 18.3 1.99 1.99 1.57 ## 8 0.510 Very Good H SI1 7.87 7.42 18.4 2.02 2.03 1.59 ## 9 0.469 Fair E VS2 8.07 7.81 18.4 1.97 1.94 1.58 ## 10 0.480 Very Good H VS1 7.71 7.81 18.4 2 2.01 1.55 ## # … with 53,930 more rows Вместо mean и sqrt может быть любая другая функция: iris %&gt;% summarise_at(vars(matches(&quot;Sepal&quot;)), function(x){mean(x)*min(x)}) ## Sepal.Length Sepal.Width ## 1 25.12633 6.114667 Здесь будет задание. 8.4 Reinvent the map function В разделе про работу со списками мы обсуждали функию map(). "]
]
