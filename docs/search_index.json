[
["tidy-dplyr.html", "3 tidyverse: Загрузка и трансформация данных 3.1 Загрузка данных 3.2 tibble 3.3 dplyr 3.4 tidyr package", " 3 tidyverse: Загрузка и трансформация данных tidyverse — это набор пакетов: ggplot2, для визуализации tibble, для работы с тибблами, современный вариант датафрейма tidyr, для формата tidy data readr, для чтения файлов в R purrr, для функционального программирования dplyr, для преобразованиия данных stringr, для работы со строковыми переменными forcats, для работы с переменными-факторами Полезно также знать о следующих: readxl, для чтения .xls и .xlsx jsonlite, для работы с JSON rvest, для веб-скреппинга lubridate, для работы с временем tidytext, для работы с текстами и корпусами broom, для перевода в tidy формат статистические модели library(&quot;tidyverse&quot;) ## ── Attaching packages ───────────────────────────────────────────────────── tidyverse 1.2.1 ── ## ✔ ggplot2 3.2.1 ✔ purrr 0.3.2 ## ✔ tibble 2.1.3 ✔ dplyr 0.8.3 ## ✔ tidyr 1.0.0 ✔ stringr 1.4.0 ## ✔ readr 1.3.1 ✔ forcats 0.4.0 ## ── Conflicts ──────────────────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() 3.1 Загрузка данных 3.1.1 Рабочая директория Все в R происходит где-то. Нужно загружать файлы с данными, нужно их куда-то сохранять. Желательно иметь для каждого проекта некоторую отдельную папку на компьютере, куда складывать все, отнсящееся к этому проекту. Две команды позволят опредить текущую рабочую дерикторию (getwd()) и (setwd(.../path/to/your/directory)). 3.1.2 Форматы данных: .csv Существет много форматов данных, которые придумали люди. Большинство из них можно загрузить в R. Так как центральный объект в R – таблица \\(n \\times k\\), то и работать мы большую часть времени будем с таблицами. Наиболее распространенные способы хранить данные сейчас это .csv (разберем в данном разделе) и .json (разберем в разделе (???){dplyr_purr}). .csv (comma separated values) – является обычным текстовым файлом, в котором перечислены значения с некоторым фиксированным разделителем: запятой, табуляцией, точка с запятой, пробел и др. Такие файлы обычно легко открывает LibreOffice, а в Microsoft Excel нужны некоторые трюки. 3.1.3 Загрузка данных: readr, readxl Стандартной функцией для чтения .csv файлов в R является функция read.csv(), но мы будем использовать функцию read_csv() из пакета readr. read_csv(&quot;...&quot;) Вместо многоточия может стоять: название файла (если он, есть в текущей рабочей дериктории) read_csv(&quot;my_file.csv&quot;) относительный путь к файлу (если он, верен для текущей рабочей дериктории) read_csv(&quot;data/my_file.csv&quot;) полный путь к файлу (если он, верен для текущей рабочей дериктории) read_csv(&quot;/home/user_name/work/data/my_file.csv&quot;) интернет ссылка (тогда, компьютер должен быть подключен к интернету) read_csv(&quot;https://my_host/my_file.csv&quot;) Для чтения других форматов .csv файлов используются другие функции: read_tsv() – для файлов с табуляцией в качестве разделителя read_csv2() – для файлов с точкой с запятой в качестве разделителя read_delim(file = \"...\", delim = \"...\") – для файлов с любым разделителем, задаваемым аргументом delim Стандартной практикой является создавать первой строкой .csv файлов названия столбцов, поэтому по умолчанию функции read_...() будут создавать таблицу, считая первую строку названием столбцов. Чтобы изменить это поведение следует использовать аргумент col_names = FALSE. Другая проблема при чтении файлов – кодировка и локаль. На разных компьютерах разные локали и дефолтные кодировки, так что имеет смысл знать про аргумент locale(\"en_US\", encoding = \"UTF-8\"). Попробуйте корректно считать в R файл по этой ссылке. ## # A tibble: 3 x 3 ## cyrillic ipa_symbols greek ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 а ʁ α ## 2 б ʔ β ## 3 в ʃ γ Благодаря readxl пакету Также данные можно скачать напрямую из файлов .xls (функция read_xls) и .xlsx (функция read_xlsx), однако эти функции не умеют читать из интернета. library(&quot;readxl&quot;) xlsx_example &lt;- read_xlsx(&quot;...&quot;) Существует еще один экстравагантный способ хранить данные: это формат файлов R .RData. Создадим data.frame: df &lt;- data.frame(letters = c(&quot;a&quot;, &quot;b&quot;), numbers = 1:2) df ## letters numbers ## 1 a 1 ## 2 b 2 Теперь можно сохранить файл… save(df, file = &quot;data/my_df.RData&quot;) удалить переменную… rm(df) df ## function (x, df1, df2, ncp, log = FALSE) ## { ## if (missing(ncp)) ## .Call(C_df, x, df1, df2, log) ## else .Call(C_dnf, x, df1, df2, ncp, log) ## } ## &lt;bytecode: 0x5f313f19bfc8&gt; ## &lt;environment: namespace:stats&gt; и загрузить все снова: load(&quot;data/my_df.RData&quot;) 3.1.3.1 Misspelling dataset Этот датасет я переработал из данных, собранных для статьи The Gyllenhaal Experiment, написанной Расселом Гольденбергом и Мэттом Дэниэлсом для издания pudding. Они анализировали ошибки в правописании при поиске имен и фамилий звезд. misspellings &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/misspelling_dataset.csv&quot;) ## Parsed with column specification: ## cols( ## correct = col_character(), ## spelling = col_character(), ## count = col_double() ## ) misspellings ## # A tibble: 15,477 x 3 ## correct spelling count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel deschanel 18338 ## 2 deschanel dechanel 1550 ## 3 deschanel deschannel 934 ## 4 deschanel deschenel 404 ## 5 deschanel deshanel 364 ## 6 deschanel dechannel 359 ## 7 deschanel deschanelle 316 ## 8 deschanel dechanelle 192 ## 9 deschanel deschanell 174 ## 10 deschanel deschenal 165 ## # … with 15,467 more rows В датасете следующие переменные: correct – корректное написание фамилии spelling – написание, которое сделали пользователи count – количество случаев такого написания 3.1.3.2 diamonds diamonds ## # A tibble: 53,940 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 ## 7 0.24 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 ## 8 0.26 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 ## 9 0.22 Fair E VS2 65.1 61 337 3.87 3.78 2.49 ## 10 0.23 Very Good H VS1 59.4 61 338 4 4.05 2.39 ## # … with 53,930 more rows ?diamonds 3.2 tibble Пакет tibble – является альтернативой штатного датафрейма в R. Существует встроенная переменная month.name: month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; ## [6] &quot;June&quot; &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; ## [11] &quot;November&quot; &quot;December&quot; Можно создать датафрейм таким образом: data.frame(id = 1:12, months = month.name, n_letters = nchar(months)) ## Error in nchar(months): cannot coerce type &#39;closure&#39; to vector of type &#39;character&#39; Однако переменная months не создана пользователем, так что данный код выдает ошибку. Корректный способ сделать это базовыми средствами: data.frame(id = 1:12, months = month.name, n_letters = nchar(month.name)) ## id months n_letters ## 1 1 January 7 ## 2 2 February 8 ## 3 3 March 5 ## 4 4 April 5 ## 5 5 May 3 ## 6 6 June 4 ## 7 7 July 4 ## 8 8 August 6 ## 9 9 September 9 ## 10 10 October 7 ## 11 11 November 8 ## 12 12 December 8 Одно из отличий tibble от базового датафрейма – возможность использовать создаваемые “по ходу пьесы переменные” tibble(id = 1:12, months = month.name, n_letters = nchar(months)) ## # A tibble: 12 x 3 ## id months n_letters ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 1 January 7 ## 2 2 February 8 ## 3 3 March 5 ## 4 4 April 5 ## 5 5 May 3 ## 6 6 June 4 ## 7 7 July 4 ## 8 8 August 6 ## 9 9 September 9 ## 10 10 October 7 ## 11 11 November 8 ## 12 12 December 8 Если в окружении пользователя уже есть переменная с датафреймом, его легко можно переделать в tibble при помощи функции as_tibble(): df &lt;- data.frame(id = 1:12, months = month.name) df ## id months ## 1 1 January ## 2 2 February ## 3 3 March ## 4 4 April ## 5 5 May ## 6 6 June ## 7 7 July ## 8 8 August ## 9 9 September ## 10 10 October ## 11 11 November ## 12 12 December as_tibble(df) ## # A tibble: 12 x 2 ## id months ## &lt;int&gt; &lt;fct&gt; ## 1 1 January ## 2 2 February ## 3 3 March ## 4 4 April ## 5 5 May ## 6 6 June ## 7 7 July ## 8 8 August ## 9 9 September ## 10 10 October ## 11 11 November ## 12 12 December Функицонально tibble от data.frame ничем не отличается, однако существует ряд несущественных отличий. Кроме того стоит помнить, что многие функции из tidyverse возвращают именно tibble, а не data.frame. 3.3 dplyr 3.3.1 dplyr::filter() Сколько неправильных произношений, которые написали меньше 10 юзеров? misspellings %&gt;% filter(count &lt; 10) ## # A tibble: 14,279 x 3 ## correct spelling count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel deshanael 9 ## 2 deschanel daychanel 9 ## 3 deschanel deschaneles 9 ## 4 deschanel dashenel 9 ## 5 deschanel deschenael 9 ## 6 deschanel deechanel 9 ## 7 deschanel deichanel 9 ## 8 deschanel dechantel 9 ## 9 deschanel deychanel 9 ## 10 deschanel daschenell 9 ## # … with 14,269 more rows %&gt;% — конвеер (pipe) отправляет результат работы одной функции в другую. sort(sqrt(abs(sin(1:22))), decreasing = TRUE) ## [1] 0.9999951 0.9952926 0.9946649 0.9805088 0.9792468 0.9554817 0.9535709 ## [8] 0.9173173 0.9146888 0.8699440 0.8665952 0.8105471 0.8064043 0.7375779 ## [15] 0.7325114 0.6482029 0.6419646 0.5365662 0.5285977 0.3871398 0.3756594 ## [22] 0.0940814 1:22 %&gt;% sin() %&gt;% abs() %&gt;% sqrt() %&gt;% sort(., decreasing = TRUE) # зачем здесь точка? ## [1] 0.9999951 0.9952926 0.9946649 0.9805088 0.9792468 0.9554817 0.9535709 ## [8] 0.9173173 0.9146888 0.8699440 0.8665952 0.8105471 0.8064043 0.7375779 ## [15] 0.7325114 0.6482029 0.6419646 0.5365662 0.5285977 0.3871398 0.3756594 ## [22] 0.0940814 Конвееры в tidyverse пришли из пакета magrittr. Иногда они работают не корректно с функциями не из tidyverse. 3.3.2 dplyr::slice() misspellings %&gt;% slice(3:7) ## # A tibble: 5 x 3 ## correct spelling count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel deschannel 934 ## 2 deschanel deschenel 404 ## 3 deschanel deshanel 364 ## 4 deschanel dechannel 359 ## 5 deschanel deschanelle 316 3.3.3 dplyr::select() diamonds %&gt;% select(8:10) ## # A tibble: 53,940 x 3 ## x y z ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3.95 3.98 2.43 ## 2 3.89 3.84 2.31 ## 3 4.05 4.07 2.31 ## 4 4.2 4.23 2.63 ## 5 4.34 4.35 2.75 ## 6 3.94 3.96 2.48 ## 7 3.95 3.98 2.47 ## 8 4.07 4.11 2.53 ## 9 3.87 3.78 2.49 ## 10 4 4.05 2.39 ## # … with 53,930 more rows diamonds %&gt;% select(color:price) ## # A tibble: 53,940 x 5 ## color clarity depth table price ## &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 E SI2 61.5 55 326 ## 2 E SI1 59.8 61 326 ## 3 E VS1 56.9 65 327 ## 4 I VS2 62.4 58 334 ## 5 J SI2 63.3 58 335 ## 6 J VVS2 62.8 57 336 ## 7 I VVS1 62.3 57 336 ## 8 H SI1 61.9 55 337 ## 9 E VS2 65.1 61 337 ## 10 H VS1 59.4 61 338 ## # … with 53,930 more rows diamonds %&gt;% select(-carat) ## # A tibble: 53,940 x 9 ## cut color clarity depth table price x y z ## &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 ## 7 Very Good I VVS1 62.3 57 336 3.95 3.98 2.47 ## 8 Very Good H SI1 61.9 55 337 4.07 4.11 2.53 ## 9 Fair E VS2 65.1 61 337 3.87 3.78 2.49 ## 10 Very Good H VS1 59.4 61 338 4 4.05 2.39 ## # … with 53,930 more rows diamonds %&gt;% select(-c(carat, cut, x, y, z)) ## # A tibble: 53,940 x 5 ## color clarity depth table price ## &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 E SI2 61.5 55 326 ## 2 E SI1 59.8 61 326 ## 3 E VS1 56.9 65 327 ## 4 I VS2 62.4 58 334 ## 5 J SI2 63.3 58 335 ## 6 J VVS2 62.8 57 336 ## 7 I VVS1 62.3 57 336 ## 8 H SI1 61.9 55 337 ## 9 E VS2 65.1 61 337 ## 10 H VS1 59.4 61 338 ## # … with 53,930 more rows diamonds %&gt;% select(cut, depth, price) ## # A tibble: 53,940 x 3 ## cut depth price ## &lt;ord&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Ideal 61.5 326 ## 2 Premium 59.8 326 ## 3 Good 56.9 327 ## 4 Premium 62.4 334 ## 5 Good 63.3 335 ## 6 Very Good 62.8 336 ## 7 Very Good 62.3 336 ## 8 Very Good 61.9 337 ## 9 Fair 65.1 337 ## 10 Very Good 59.4 338 ## # … with 53,930 more rows 3.3.4 dplyr::arrange() misspellings %&gt;% arrange(count) ## # A tibble: 15,477 x 3 ## correct spelling count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel deschil 1 ## 2 deschanel deshauneil 1 ## 3 deschanel deschmuel 1 ## 4 deschanel deshannle 1 ## 5 deschanel deslanges 1 ## 6 deschanel deshoenel 1 ## 7 deschanel dechadel 1 ## 8 deschanel dooschaney 1 ## 9 deschanel dishana 1 ## 10 deschanel deshaneil 1 ## # … with 15,467 more rows diamonds %&gt;% arrange(desc(carat), price) ## # A tibble: 53,940 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5.01 Fair J I1 65.5 59 18018 10.7 10.5 6.98 ## 2 4.5 Fair J I1 65.8 58 18531 10.2 10.2 6.72 ## 3 4.13 Fair H I1 64.8 61 17329 10 9.85 6.43 ## 4 4.01 Premium I I1 61 61 15223 10.1 10.1 6.17 ## 5 4.01 Premium J I1 62.5 62 15223 10.0 9.94 6.24 ## 6 4 Very Good I I1 63.3 58 15984 10.0 9.94 6.31 ## 7 3.67 Premium I I1 62.4 56 16193 9.86 9.81 6.13 ## 8 3.65 Fair H I1 67.1 53 11668 9.53 9.48 6.38 ## 9 3.51 Premium J VS2 62.5 59 18701 9.66 9.63 6.03 ## 10 3.5 Ideal H I1 62.8 57 12587 9.65 9.59 6.03 ## # … with 53,930 more rows 3.3.5 dplyr::distinct() misspellings %&gt;% distinct(correct) ## # A tibble: 15 x 1 ## correct ## &lt;chr&gt; ## 1 deschanel ## 2 mclachlan ## 3 galifianakis ## 4 labeouf ## 5 macaulay ## 6 mcconaughey ## 7 minaj ## 8 morissette ## 9 poehler ## 10 shyamalan ## 11 kaepernick ## 12 mcgwire ## 13 palahniuk ## 14 picabo ## 15 johansson misspellings %&gt;% distinct(spelling) ## # A tibble: 15,462 x 1 ## spelling ## &lt;chr&gt; ## 1 deschanel ## 2 dechanel ## 3 deschannel ## 4 deschenel ## 5 deshanel ## 6 dechannel ## 7 deschanelle ## 8 dechanelle ## 9 deschanell ## 10 deschenal ## # … with 15,452 more rows diamonds %&gt;% distinct(color, cut) ## # A tibble: 35 x 2 ## color cut ## &lt;ord&gt; &lt;ord&gt; ## 1 E Ideal ## 2 E Premium ## 3 E Good ## 4 I Premium ## 5 J Good ## 6 J Very Good ## 7 I Very Good ## 8 H Very Good ## 9 E Fair ## 10 J Ideal ## # … with 25 more rows 3.3.6 dplyr::mutate() misspellings %&gt;% mutate(misspelling_length = nchar(spelling)) ## # A tibble: 15,477 x 4 ## correct spelling count misspelling_length ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 deschanel deschanel 18338 9 ## 2 deschanel dechanel 1550 8 ## 3 deschanel deschannel 934 10 ## 4 deschanel deschenel 404 9 ## 5 deschanel deshanel 364 8 ## 6 deschanel dechannel 359 9 ## 7 deschanel deschanelle 316 11 ## 8 deschanel dechanelle 192 10 ## 9 deschanel deschanell 174 10 ## 10 deschanel deschenal 165 9 ## # … with 15,467 more rows 3.3.7 dplyr::group_by(...) %&gt;% summarise(...) misspellings %&gt;% summarise(min(count), mean(count)) ## # A tibble: 1 x 2 ## `min(count)` `mean(count)` ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1 21.8 misspellings %&gt;% group_by(correct) %&gt;% summarise(mean(count)) ## # A tibble: 15 x 2 ## correct `mean(count)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel 25.9 ## 2 galifianakis 8.64 ## 3 johansson 74.8 ## 4 kaepernick 29.1 ## 5 labeouf 61.2 ## 6 macaulay 17.6 ## 7 mcconaughey 7.74 ## 8 mcgwire 55.3 ## 9 mclachlan 14.8 ## 10 minaj 140. ## 11 morissette 55.2 ## 12 palahniuk 10.2 ## 13 picabo 23.2 ## 14 poehler 65.3 ## 15 shyamalan 16.9 misspellings %&gt;% group_by(correct) %&gt;% summarise(my_mean = mean(count)) ## # A tibble: 15 x 2 ## correct my_mean ## &lt;chr&gt; &lt;dbl&gt; ## 1 deschanel 25.9 ## 2 galifianakis 8.64 ## 3 johansson 74.8 ## 4 kaepernick 29.1 ## 5 labeouf 61.2 ## 6 macaulay 17.6 ## 7 mcconaughey 7.74 ## 8 mcgwire 55.3 ## 9 mclachlan 14.8 ## 10 minaj 140. ## 11 morissette 55.2 ## 12 palahniuk 10.2 ## 13 picabo 23.2 ## 14 poehler 65.3 ## 15 shyamalan 16.9 Если нужно посчитать количество вхождений, то можно использовать функцию n() в summarise() или же функцию count(): misspellings %&gt;% group_by(correct) %&gt;% summarise(n = n()) ## # A tibble: 15 x 2 ## correct n ## &lt;chr&gt; &lt;int&gt; ## 1 deschanel 1015 ## 2 galifianakis 2633 ## 3 johansson 392 ## 4 kaepernick 779 ## 5 labeouf 449 ## 6 macaulay 1458 ## 7 mcconaughey 2897 ## 8 mcgwire 262 ## 9 mclachlan 1054 ## 10 minaj 200 ## 11 morissette 478 ## 12 palahniuk 1541 ## 13 picabo 460 ## 14 poehler 386 ## 15 shyamalan 1473 misspellings %&gt;% count(correct) ## # A tibble: 15 x 2 ## correct n ## &lt;chr&gt; &lt;int&gt; ## 1 deschanel 1015 ## 2 galifianakis 2633 ## 3 johansson 392 ## 4 kaepernick 779 ## 5 labeouf 449 ## 6 macaulay 1458 ## 7 mcconaughey 2897 ## 8 mcgwire 262 ## 9 mclachlan 1054 ## 10 minaj 200 ## 11 morissette 478 ## 12 palahniuk 1541 ## 13 picabo 460 ## 14 poehler 386 ## 15 shyamalan 1473 Можно даже отсортировать результат: misspellings %&gt;% count(correct, sort = TRUE) ## # A tibble: 15 x 2 ## correct n ## &lt;chr&gt; &lt;int&gt; ## 1 mcconaughey 2897 ## 2 galifianakis 2633 ## 3 palahniuk 1541 ## 4 shyamalan 1473 ## 5 macaulay 1458 ## 6 mclachlan 1054 ## 7 deschanel 1015 ## 8 kaepernick 779 ## 9 morissette 478 ## 10 picabo 460 ## 11 labeouf 449 ## 12 johansson 392 ## 13 poehler 386 ## 14 mcgwire 262 ## 15 minaj 200 Если вы хотите создать не какое-то саммари, а целый дополнительный столбец с этим саммари вместо функции summarise() нужно использовать функцию mutate(): misspellings %&gt;% group_by(correct) %&gt;% mutate(my_mean = mean(count)) ## # A tibble: 15,477 x 4 ## # Groups: correct [15] ## correct spelling count my_mean ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 deschanel deschanel 18338 25.9 ## 2 deschanel dechanel 1550 25.9 ## 3 deschanel deschannel 934 25.9 ## 4 deschanel deschenel 404 25.9 ## 5 deschanel deshanel 364 25.9 ## 6 deschanel dechannel 359 25.9 ## 7 deschanel deschanelle 316 25.9 ## 8 deschanel dechanelle 192 25.9 ## 9 deschanel deschanell 174 25.9 ## 10 deschanel deschenal 165 25.9 ## # … with 15,467 more rows 3.3.8 dplyr::.._join() languages &lt;- data_frame( languages = c(&quot;Selkup&quot;, &quot;French&quot;, &quot;Chukchi&quot;, &quot;Polish&quot;), countries = c(&quot;Russia&quot;, &quot;France&quot;, &quot;Russia&quot;, &quot;Poland&quot;), iso = c(&quot;sel&quot;, &quot;fra&quot;, &quot;ckt&quot;, &quot;pol&quot;) ) ## Warning: `data_frame()` is deprecated, use `tibble()`. ## This warning is displayed once per session. languages ## # A tibble: 4 x 3 ## languages countries iso ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Selkup Russia sel ## 2 French France fra ## 3 Chukchi Russia ckt ## 4 Polish Poland pol country_population &lt;- data_frame( countries = c(&quot;Russia&quot;, &quot;Poland&quot;, &quot;Finland&quot;), population_mln = c(143, 38, 5)) country_population ## # A tibble: 3 x 2 ## countries population_mln ## &lt;chr&gt; &lt;dbl&gt; ## 1 Russia 143 ## 2 Poland 38 ## 3 Finland 5 inner_join(languages, country_population) ## Joining, by = &quot;countries&quot; ## # A tibble: 3 x 4 ## languages countries iso population_mln ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Selkup Russia sel 143 ## 2 Chukchi Russia ckt 143 ## 3 Polish Poland pol 38 left_join(languages, country_population) ## Joining, by = &quot;countries&quot; ## # A tibble: 4 x 4 ## languages countries iso population_mln ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Selkup Russia sel 143 ## 2 French France fra NA ## 3 Chukchi Russia ckt 143 ## 4 Polish Poland pol 38 right_join(languages, country_population) ## Joining, by = &quot;countries&quot; ## # A tibble: 4 x 4 ## languages countries iso population_mln ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Selkup Russia sel 143 ## 2 Chukchi Russia ckt 143 ## 3 Polish Poland pol 38 ## 4 &lt;NA&gt; Finland &lt;NA&gt; 5 anti_join(languages, country_population) ## Joining, by = &quot;countries&quot; ## # A tibble: 1 x 3 ## languages countries iso ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 French France fra anti_join(country_population, languages) ## Joining, by = &quot;countries&quot; ## # A tibble: 1 x 2 ## countries population_mln ## &lt;chr&gt; &lt;dbl&gt; ## 1 Finland 5 full_join(country_population, languages) ## Joining, by = &quot;countries&quot; ## # A tibble: 5 x 4 ## countries population_mln languages iso ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Russia 143 Selkup sel ## 2 Russia 143 Chukchi ckt ## 3 Poland 38 Polish pol ## 4 Finland 5 &lt;NA&gt; &lt;NA&gt; ## 5 France NA French fra 3.4 tidyr package Short format df.short &lt;- data.frame( consonant = c(&quot;stops&quot;, &quot;fricatives&quot;, &quot;affricates&quot;, &quot;nasals&quot;), initial = c(123, 87, 73, 7), intervocal = c(57, 77, 82, 78), final = c(30, 69, 12, 104)) df.short ## consonant initial intervocal final ## 1 stops 123 57 30 ## 2 fricatives 87 77 69 ## 3 affricates 73 82 12 ## 4 nasals 7 78 104 Long format ## consonant position number ## 1 stops initial 123 ## 2 fricatives initial 87 ## 3 affricates initial 73 ## 4 nasals initial 7 ## 5 stops intervocal 57 ## 6 fricatives intervocal 77 ## 7 affricates intervocal 82 ## 8 nasals intervocal 78 ## 9 stops final 30 ## 10 fricatives final 69 ## 11 affricates final 12 ## 12 nasals final 104 Short format → Long format: tidyr::gather() df.short &lt;- data.frame( consonant = c(&quot;stops&quot;, &quot;fricatives&quot;, &quot;affricates&quot;, &quot;nasals&quot;), initial = c(123, 87, 73, 7), intervocal = c(57, 77, 82, 78), final = c(30, 69, 12, 104)) df.short ## consonant initial intervocal final ## 1 stops 123 57 30 ## 2 fricatives 87 77 69 ## 3 affricates 73 82 12 ## 4 nasals 7 78 104 df.short %&gt;% gather(position, number, initial:final) -&gt; df.long df.long ## consonant position number ## 1 stops initial 123 ## 2 fricatives initial 87 ## 3 affricates initial 73 ## 4 nasals initial 7 ## 5 stops intervocal 57 ## 6 fricatives intervocal 77 ## 7 affricates intervocal 82 ## 8 nasals intervocal 78 ## 9 stops final 30 ## 10 fricatives final 69 ## 11 affricates final 12 ## 12 nasals final 104 Long format → Short format: tidyr::spread() df.long %&gt;% spread(position, number) -&gt; df.short df.short ## consonant final initial intervocal ## 1 affricates 12 73 82 ## 2 fricatives 69 87 77 ## 3 nasals 104 7 78 ## 4 stops 30 123 57 "]
]
