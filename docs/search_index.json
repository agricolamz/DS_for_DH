[
["strings.html", "5 Работа со строками 5.1 Работа со строками в R 5.2 Как получить строку? 5.3 Соединение и разделение строк 5.4 Количество символов 5.5 Сортировка 5.6 Поиск подстроки 5.7 Изменение строк 5.8 Регулярные выражения 5.9 Определение языка 5.10 Расстояния между строками", " 5 Работа со строками 5.1 Работа со строками в R Для работы со строками можно использовать: базовый R пакет stringr (часть tidyverse) пакет stringi – отдельный пакет, так что не забудьте его установить: install.packages(&quot;stringi&quot;) library(tidyverse) library(stringi) Мы будем пользоваться в основном пакетами stingr и stringi, так как они в большинстве случаях удобнее. К счастью функции этих пакетов легко отличить от остальных: функции пакет stringr всегда начинаются с str_, а функции пакета stringi — c stri_. Существует cheat sheet по stringr. 5.2 Как получить строку? следите за кавычками &quot;the quick brown fox jumps over the lazy dog&quot; ## [1] &quot;the quick brown fox jumps over the lazy dog&quot; &#39;the quick brown fox jumps over the lazy dog&#39; ## [1] &quot;the quick brown fox jumps over the lazy dog&quot; &quot;the quick &#39;brown&#39; fox jumps over the lazy dog&quot; ## [1] &quot;the quick &#39;brown&#39; fox jumps over the lazy dog&quot; &#39;the quick &quot;brown&quot; fox jumps over the lazy dog&#39; ## [1] &quot;the quick \\&quot;brown\\&quot; fox jumps over the lazy dog&quot; пустая строка &quot;&quot; ## [1] &quot;&quot; &#39;&#39; ## [1] &quot;&quot; character(3) ## [1] &quot;&quot; &quot;&quot; &quot;&quot; преобразование typeof(4:7) ## [1] &quot;integer&quot; as.character(4:7) ## [1] &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; встроенные векторы letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; ## [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; ## [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; ## [6] &quot;June&quot; &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; ## [11] &quot;November&quot; &quot;December&quot; помните, что функции data.frame(), read.csv(), read.csv2(), read.table() из базового R всегда по-умолчанию преобразуют строки в факторы, и чтобы это предотвратить нужно использовать аргумент stringsAsFactors. Это много обсуждалось в сообществе R, можно, например, почитать про это вот этот блог пост Роджера Пенга. str(data.frame(letters[6:10], LETTERS[4:8])) ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ letters.6.10.: Factor w/ 5 levels &quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,..: 1 2 3 4 5 ## $ LETTERS.4.8. : Factor w/ 5 levels &quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,..: 1 2 3 4 5 str(data.frame(letters[6:10], LETTERS[4:8], stringsAsFactors = FALSE)) ## &#39;data.frame&#39;: 5 obs. of 2 variables: ## $ letters.6.10.: chr &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; ... ## $ LETTERS.4.8. : chr &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; ... Но этом курсе мы учим использовать сразу tibble(), read_csv(), read_csv2(), read_tsv(), read_delim() из пакета readr (входит в tidyverse). Создание рандомных строк set.seed(42) stri_rand_strings(n = 10, length = 5:14) ## [1] &quot;uwHpd&quot; &quot;Wj8ehS&quot; &quot;ivFSwy7&quot; &quot;TYu8zw5V&quot; ## [5] &quot;OuRpjoOg0&quot; &quot;p0CubNR2yQ&quot; &quot;xtdycKLOm2k&quot; &quot;fAGVfylZqBGp&quot; ## [9] &quot;gE28DTCi0NV0a&quot; &quot;9MemYE55If0Cvv&quot; Перемешивает символы внутри строки stri_rand_shuffle(&quot;любя, съешь щипцы, — вздохнёт мэр, — кайф жгуч&quot;) ## [1] &quot;,цо м,пюзгу сл аиъ—в кжряд,ыщьчебэн х—штё фй&quot; stri_rand_shuffle(month.name) ## [1] &quot;aJayunr&quot; &quot;eyrbraFu&quot; &quot;achMr&quot; &quot;Aplri&quot; &quot;ayM&quot; ## [6] &quot;Jnue&quot; &quot;uJly&quot; &quot;usuAgt&quot; &quot;tpebermSe&quot; &quot;tOecrbo&quot; ## [11] &quot;oeNembvr&quot; &quot;Dmceerbe&quot; Генерирует псевдорандомный текст1 stri_rand_lipsum(nparagraphs = 2) ## [1] &quot;Lorem ipsum dolor sit amet, donec sit nunc urna sed ultricies ac pharetra orci luctus iaculis, ac tincidunt cum. Neque eu semper at sociosqu hendrerit. Eu aliquet lacus, eu hendrerit donec aliquam eros. Risus nibh, quam in sit facilisi ipsum. Amet sem sed donec sed molestie scelerisque tincidunt. Nisl donec et facilisis interdum non sed dolor purus. In ipsum dignissim torquent velit nec aliquam pellentesque. Ac, adipiscing, neque et at torquent, vestibulum ullamcorper. Ad dictumst enim velit non nulla felis habitant. Egestas placerat consectetur, dictum nostra sed nec. Erat phasellus dolor libero aliquam viverra. Vestibulum leo et. Suscipit egestas in in montes, sapien gravida? Conubia purus varius ut nec feugiat.&quot; ## [2] &quot;Risus eleifend magnis neque diam, suspendisse ullamcorper nulla adipiscing malesuada massa, nisi sociosqu velit id et. Aliquam facilisis et aenean. Parturient vel ac in convallis, massa diam nibh. Nulla interdum cursus et. Natoque amet, ut praesent. Tortor ultrices a consectetur, augue natoque class faucibus? Ut sed arcu elementum magna. Dignissim ac facilisi quis ut nisl eu, massa.&quot; 5.3 Соединение и разделение строк Соединенить строки можно используя функцию str_c(), в которую, как и в функции с(), можно перечислять элементы через запятую: tibble(upper = rev(LETTERS), smaller = letters) %&gt;% mutate(merge = str_c(upper, smaller)) ## # A tibble: 26 x 3 ## upper smaller merge ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Z a Za ## 2 Y b Yb ## 3 X c Xc ## 4 W d Wd ## 5 V e Ve ## 6 U f Uf ## 7 T g Tg ## 8 S h Sh ## 9 R i Ri ## 10 Q j Qj ## # … with 16 more rows Кроме того, если хочется, можно использовать особенный разделитель, указав его в аргументе sep: tibble(upper = rev(LETTERS), smaller = letters) %&gt;% mutate(merge = str_c(upper, smaller, sep = &quot;_&quot;)) ## # A tibble: 26 x 3 ## upper smaller merge ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Z a Z_a ## 2 Y b Y_b ## 3 X c X_c ## 4 W d W_d ## 5 V e V_e ## 6 U f U_f ## 7 T g T_g ## 8 S h S_h ## 9 R i R_i ## 10 Q j Q_j ## # … with 16 more rows Аналогичным образом, для разделение строки на подстроки можно использовать функцию separate(). Это функция разносит разделенные элементы строки в соответствующие столбцы. У функции три обязательных аргумента: col — колонка, которую следует разделить, into — вектор названий новых столбец, sep — разделитель. tibble(upper = rev(LETTERS), smaller = letters) %&gt;% mutate(merge = str_c(upper, smaller, sep = &quot;_&quot;)) %&gt;% separate(col = merge, into = c(&quot;column_1&quot;, &quot;column_2&quot;), sep = &quot;_&quot;) ## # A tibble: 26 x 4 ## upper smaller column_1 column_2 ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Z a Z a ## 2 Y b Y b ## 3 X c X c ## 4 W d W d ## 5 V e V e ## 6 U f U f ## 7 T g T g ## 8 S h S h ## 9 R i R i ## 10 Q j Q j ## # … with 16 more rows 5.4 Количество символов 5.4.1 Подсчет количества символов tibble(mn = month.name) %&gt;% mutate(n_charactars = str_count(mn)) ## # A tibble: 12 x 2 ## mn n_charactars ## &lt;chr&gt; &lt;int&gt; ## 1 January 7 ## 2 February 8 ## 3 March 5 ## 4 April 5 ## 5 May 3 ## 6 June 4 ## 7 July 4 ## 8 August 6 ## 9 September 9 ## 10 October 7 ## 11 November 8 ## 12 December 8 5.4.2 Подгонка количества символов Можно обрезать строки, используя функцию str_trunc(): tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 6)) ## # A tibble: 12 x 2 ## mn mn_new ## &lt;chr&gt; &lt;chr&gt; ## 1 January Jan... ## 2 February Feb... ## 3 March March ## 4 April April ## 5 May May ## 6 June June ## 7 July July ## 8 August August ## 9 September Sep... ## 10 October Oct... ## 11 November Nov... ## 12 December Dec... Можно решить с какой стороны обрезать, используя аргумент side: tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 6, side = &quot;left&quot;)) ## # A tibble: 12 x 2 ## mn mn_new ## &lt;chr&gt; &lt;chr&gt; ## 1 January ...ary ## 2 February ...ary ## 3 March March ## 4 April April ## 5 May May ## 6 June June ## 7 July July ## 8 August August ## 9 September ...ber ## 10 October ...ber ## 11 November ...ber ## 12 December ...ber tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 6, side = &quot;center&quot;)) ## # A tibble: 12 x 2 ## mn mn_new ## &lt;chr&gt; &lt;chr&gt; ## 1 January Ja...y ## 2 February Fe...y ## 3 March March ## 4 April April ## 5 May May ## 6 June June ## 7 July July ## 8 August August ## 9 September Se...r ## 10 October Oc...r ## 11 November No...r ## 12 December De...r Можно заменить многоточие, используя аргумент ellipsis: tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 3, ellipsis = &quot;&quot;)) ## # A tibble: 12 x 2 ## mn mn_new ## &lt;chr&gt; &lt;chr&gt; ## 1 January Jan ## 2 February Feb ## 3 March Mar ## 4 April Apr ## 5 May May ## 6 June Jun ## 7 July Jul ## 8 August Aug ## 9 September Sep ## 10 October Oct ## 11 November Nov ## 12 December Dec Можно наоборот “раздуть” строку: tibble(mn = month.name) %&gt;% mutate(mn_new = str_pad(mn, 10)) ## # A tibble: 12 x 2 ## mn mn_new ## &lt;chr&gt; &lt;chr&gt; ## 1 January &quot; January&quot; ## 2 February &quot; February&quot; ## 3 March &quot; March&quot; ## 4 April &quot; April&quot; ## 5 May &quot; May&quot; ## 6 June &quot; June&quot; ## 7 July &quot; July&quot; ## 8 August &quot; August&quot; ## 9 September &quot; September&quot; ## 10 October &quot; October&quot; ## 11 November &quot; November&quot; ## 12 December &quot; December&quot; Опять же есть аргумент side: tibble(mn = month.name) %&gt;% mutate(mn_new = str_pad(mn, 10, side = &quot;right&quot;)) ## # A tibble: 12 x 2 ## mn mn_new ## &lt;chr&gt; &lt;chr&gt; ## 1 January &quot;January &quot; ## 2 February &quot;February &quot; ## 3 March &quot;March &quot; ## 4 April &quot;April &quot; ## 5 May &quot;May &quot; ## 6 June &quot;June &quot; ## 7 July &quot;July &quot; ## 8 August &quot;August &quot; ## 9 September &quot;September &quot; ## 10 October &quot;October &quot; ## 11 November &quot;November &quot; ## 12 December &quot;December &quot; Также можно выбрать, чем “раздувать строку”: tibble(mn = month.name) %&gt;% mutate(mn_new = str_pad(mn, 10, pad = &quot;.&quot;)) ## # A tibble: 12 x 2 ## mn mn_new ## &lt;chr&gt; &lt;chr&gt; ## 1 January ...January ## 2 February ..February ## 3 March .....March ## 4 April .....April ## 5 May .......May ## 6 June ......June ## 7 July ......July ## 8 August ....August ## 9 September .September ## 10 October ...October ## 11 November ..November ## 12 December ..December На Pudding вышла статья про английские пабы. Здесь лежит немного обработанный датасет, которые они использовали. Визуализируйте 40 самых частотоных названий пабов в Великобритании, отложив по оси x количество символов, а по оси y – количество баров с таким названием. 📋 список подсказок ➡ 👁 Датасет скачался, что дальше? ➡ Перво-наперво следует создать переменную, в которой бы хранилось количество каждого из баров. 👁 А как посчитать количество баров? ➡ Это можно сделать при помощи функции count(). 👁 Бары пересчитали, что дальше? ➡ Теперь нужно создать новую переменную, где бы хранилась информация о количестве символов. 👁 Все переменные есть, теперь рисуем? ➡ Не совсем. Перед тем как рисовать нужно отфильтровать 50 самых популярных. 👁 Так, все готово, а какие geom_()? ➡ На графике geom_point() и geom_text_repel() из пакета ggrepel. 👁 А-а-а-а! could not find function \"geom_text_repel\" ➡ А вы включили библиотеку ggrepel? Если не включили, то функция, естественно будет недоступна. 👁 А-а-а-а! geom_text_repel requires the following missing aesthetics: label\" ➡ Все, как написала программа: чтобы писать какой-то текст в функции aes() нужно добавить аргумент label = pub_name. Иначе откуда он узнает, что ему писать? 👁 Фуф! Все готово! ➡ А оси подписаны? А заголовок? А подпись про источник данных? 5.5 Сортировка Для сортировки существует базовая функция sort() и функция из stringr str_sort(): unsorted_latin &lt;- c(&quot;I&quot;, &quot;♥&quot;, &quot;N&quot;, &quot;Y&quot;) sort(unsorted_latin) ## [1] &quot;♥&quot; &quot;I&quot; &quot;N&quot; &quot;Y&quot; str_sort(unsorted_latin) ## [1] &quot;♥&quot; &quot;I&quot; &quot;N&quot; &quot;Y&quot; str_sort(unsorted_latin, locale = &quot;lt&quot;) ## [1] &quot;♥&quot; &quot;I&quot; &quot;Y&quot; &quot;N&quot; unsorted_cyrillic &lt;- c(&quot;я&quot;, &quot;i&quot;, &quot;ж&quot;) str_sort(unsorted_cyrillic) ## [1] &quot;i&quot; &quot;ж&quot; &quot;я&quot; str_sort(unsorted_cyrillic, locale = &quot;ru_UA&quot;) ## [1] &quot;ж&quot; &quot;я&quot; &quot;i&quot; Список локалей на копмьютере можно посмотреть командой stringi::stri_locale_list(). Список всех локалей вообще приведен на этой странице. Еще полезные команды: stringi::stri_locale_info и stringi::stri_locale_set. Не углубляясь в разнообразие алгоритмов сортировки, отмечу, что алгоритм по-умолчанию хуже работает с большими данными: set.seed(42) huge &lt;- sample(letters, 1e7, replace = TRUE) head(huge) ## [1] &quot;q&quot; &quot;e&quot; &quot;a&quot; &quot;y&quot; &quot;j&quot; &quot;d&quot; system.time( sort(huge) ) ## user system elapsed ## 6.228 0.004 6.232 system.time( sort(huge, method = &quot;radix&quot;) ) ## user system elapsed ## 0.239 0.004 0.242 system.time( str_sort(huge) ) ## user system elapsed ## 5.948 0.016 5.964 huge_tbl &lt;- tibble(huge) system.time( huge_tbl %&gt;% arrange(huge) ) ## user system elapsed ## 2.981 0.020 3.000 Предварительный вывод: для больших данных – sort(..., method = \"radix\"). 5.6 Поиск подстроки Можно использовать функцию str_detect(): tibble(mn = month.name) %&gt;% mutate(has_r = str_detect(mn, &quot;r&quot;)) ## # A tibble: 12 x 2 ## mn has_r ## &lt;chr&gt; &lt;lgl&gt; ## 1 January TRUE ## 2 February TRUE ## 3 March TRUE ## 4 April TRUE ## 5 May FALSE ## 6 June FALSE ## 7 July FALSE ## 8 August FALSE ## 9 September TRUE ## 10 October TRUE ## 11 November TRUE ## 12 December TRUE Кроме того, существует функция, которая возвращает индексы, а не значения TRUE/FALSE: str_which(month.name, &quot;r&quot;) ## [1] 1 2 3 4 9 10 11 12 Также можно посчитать количество вхождений какой-то подстроки: tibble(mn = month.name) %&gt;% mutate(has_r = str_count(mn, &quot;r&quot;)) ## # A tibble: 12 x 2 ## mn has_r ## &lt;chr&gt; &lt;int&gt; ## 1 January 1 ## 2 February 2 ## 3 March 1 ## 4 April 1 ## 5 May 0 ## 6 June 0 ## 7 July 0 ## 8 August 0 ## 9 September 1 ## 10 October 1 ## 11 November 1 ## 12 December 1 5.7 Изменение строк 5.7.1 Изменение регистра latin &lt;- &quot;tHe QuIcK BrOwN fOx JuMpS OvEr ThE lAzY dOg&quot; cyrillic &lt;- &quot;лЮбЯ, сЪеШь ЩиПцЫ, — вЗдОхНёТ мЭр, — кАйФ жГуЧ&quot; str_to_upper(latin) ## [1] &quot;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&quot; str_to_lower(cyrillic) ## [1] &quot;любя, съешь щипцы, — вздохнёт мэр, — кайф жгуч&quot; str_to_title(latin) ## [1] &quot;The Quick Brown Fox Jumps Over The Lazy Dog&quot; 5.7.2 Выделение подстроки Подстроку в строке можно выделить двумя способами: по индексам функцией str_sub(), и по подстроке функцией str_png(). tibble(mn = month.name) %&gt;% mutate(mutate = str_sub(mn, start = 1, end = 2)) ## # A tibble: 12 x 2 ## mn mutate ## &lt;chr&gt; &lt;chr&gt; ## 1 January Ja ## 2 February Fe ## 3 March Ma ## 4 April Ap ## 5 May Ma ## 6 June Ju ## 7 July Ju ## 8 August Au ## 9 September Se ## 10 October Oc ## 11 November No ## 12 December De tibble(mn = month.name) %&gt;% mutate(mutate = str_extract(mn, &quot;r&quot;)) ## # A tibble: 12 x 2 ## mn mutate ## &lt;chr&gt; &lt;chr&gt; ## 1 January r ## 2 February r ## 3 March r ## 4 April r ## 5 May &lt;NA&gt; ## 6 June &lt;NA&gt; ## 7 July &lt;NA&gt; ## 8 August &lt;NA&gt; ## 9 September r ## 10 October r ## 11 November r ## 12 December r По умолчанию функция str_extract() возвращает первое вхождение подстроки, соответствующей шаблону. Также существует функция str_extract_all(), которая возвращает все вхождения подстрок, соответствующих шаблону, однако возвращает объект типа список. str_extract_all(month.name, &quot;r&quot;) ## [[1]] ## [1] &quot;r&quot; ## ## [[2]] ## [1] &quot;r&quot; &quot;r&quot; ## ## [[3]] ## [1] &quot;r&quot; ## ## [[4]] ## [1] &quot;r&quot; ## ## [[5]] ## character(0) ## ## [[6]] ## character(0) ## ## [[7]] ## character(0) ## ## [[8]] ## character(0) ## ## [[9]] ## [1] &quot;r&quot; ## ## [[10]] ## [1] &quot;r&quot; ## ## [[11]] ## [1] &quot;r&quot; ## ## [[12]] ## [1] &quot;r&quot; 5.7.3 Замена подстроки Существует функция str_replace(), которая позволяет заменить одну подстроку в строке на другую: tibble(mn = month.name) %&gt;% mutate(mutate = str_replace(mn, &quot;r&quot;, &quot;R&quot;)) ## # A tibble: 12 x 2 ## mn mutate ## &lt;chr&gt; &lt;chr&gt; ## 1 January JanuaRy ## 2 February FebRuary ## 3 March MaRch ## 4 April ApRil ## 5 May May ## 6 June June ## 7 July July ## 8 August August ## 9 September SeptembeR ## 10 October OctobeR ## 11 November NovembeR ## 12 December DecembeR Как и другие функции str_replace() делает лишь одну замену, чтобы заменить все вхождения подстроки следует использовать функцию str_replace_all(): tibble(mn = month.name) %&gt;% mutate(mutate = str_replace_all(mn, &quot;r&quot;, &quot;R&quot;)) ## # A tibble: 12 x 2 ## mn mutate ## &lt;chr&gt; &lt;chr&gt; ## 1 January JanuaRy ## 2 February FebRuaRy ## 3 March MaRch ## 4 April ApRil ## 5 May May ## 6 June June ## 7 July July ## 8 August August ## 9 September SeptembeR ## 10 October OctobeR ## 11 November NovembeR ## 12 December DecembeR 5.7.4 Удаление подстроки Для удаления подстроки на основе шаблона, используется функция str_remove() и str_remove_all() tibble(month.name) %&gt;% mutate(mutate = str_remove(month.name, &quot;r&quot;)) ## # A tibble: 12 x 2 ## month.name mutate ## &lt;chr&gt; &lt;chr&gt; ## 1 January Januay ## 2 February Febuary ## 3 March Mach ## 4 April Apil ## 5 May May ## 6 June June ## 7 July July ## 8 August August ## 9 September Septembe ## 10 October Octobe ## 11 November Novembe ## 12 December Decembe tibble(month.name) %&gt;% mutate(mutate = str_remove_all(month.name, &quot;r&quot;)) ## # A tibble: 12 x 2 ## month.name mutate ## &lt;chr&gt; &lt;chr&gt; ## 1 January Januay ## 2 February Febuay ## 3 March Mach ## 4 April Apil ## 5 May May ## 6 June June ## 7 July July ## 8 August August ## 9 September Septembe ## 10 October Octobe ## 11 November Novembe ## 12 December Decembe 5.7.5 Транслитерация строк В пакете stringi сууществует достаточно много методов транслитераций строк, которые можно вывести командой stri_trans_list(). Вот пример использования некоторых из них: stri_trans_general(&quot;stringi&quot;, &quot;latin-cyrillic&quot;) ## [1] &quot;стринги&quot; stri_trans_general(&quot;сырники&quot;, &quot;cyrillic-latin&quot;) ## [1] &quot;syrniki&quot; stri_trans_general(&quot;stringi&quot;, &quot;latin-greek&quot;) ## [1] &quot;στριγγι&quot; stri_trans_general(&quot;stringi&quot;, &quot;latin-armenian&quot;) ## [1] &quot;ստրինգի&quot; Вот два датасета: список городов России частотный словарь русского языка [Шаров, Ляшевская 2011] Определите сколько городов называется обычным словом русского языка (например, город Орёл)? Не забудьте поменять ё на е. 📋 список подсказок ➡ 👁 Датасеты скачались, что дальше? ➡ Надо их преобразовать к нужному виду и объединить. 👁 А как их соединить? Что у них общего? ➡ В одном датасете есть переменная city, в другом – переменная lemma. Все города начинаются с большой буквы, все леммы с маленькой буквы. Я бы уменьшил букву в датасете с городами, сделал бы новый столбец в датасете с городами (например, town), соединил бы датасеты и посчитал бы сколько в результирующем датасете значений town. 👁 А как соеднить? ➡ Я бы использовал dict %&gt;% ... %&gt;% left_join(cities). Если в датасетах разные названия столбцов, то следует указывать какие столбцы, каким соответствуют:dict %&gt;% ... %&gt;% left_join(cities, by = c(\"lemma\" = \"city\")) 👁 Соединилось вроде… А как посчитать? ➡ Я бы, как обычно, использовал функцию count(). 5.8 Регулярные выражения Большинство функций из раздела об операциях над векторами (str_detect(), str_extract(), str_remove() и т. п.) имеют следующую структуру: строка, с которой работает функция образец (pattern) Дальше мы будем использовать функцию str_view_all(), которая позволяет показывать, выделенное образцом в исходной строке. str_view_all(&quot;Я всегда путаю с и c&quot;, &quot;c&quot;) # я ищу латинскую c 5.8.1 Экранирование метасимволов a &lt;- &quot;Всем известно, что 4$\\\\2 + 3$ * 5 = 17$? Да? Ну хорошо (а то я не был уверен). [|}^{|]&quot; str_view_all(a, &quot;$&quot;) str_view_all(a, &quot;\\\\$&quot;) str_view_all(a, &quot;\\\\.&quot;) str_view_all(a, &quot;\\\\*&quot;) str_view_all(a, &quot;\\\\+&quot;) str_view_all(a, &quot;\\\\?&quot;) str_view_all(a, &quot;\\\\(&quot;) str_view_all(a, &quot;\\\\)&quot;) str_view_all(a, &quot;\\\\|&quot;) str_view_all(a, &quot;\\\\^&quot;) str_view_all(a, &quot;\\\\[&quot;) str_view_all(a, &quot;\\\\]&quot;) str_view_all(a, &quot;\\\\{&quot;) str_view_all(a, &quot;\\\\}&quot;) str_view_all(a, &quot;\\\\\\\\&quot;) 5.8.2 Классы знаков \\\\d – цифры. \\\\D – не цифры. str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\d&quot;) str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\D&quot;) \\\\s – пробелы. \\\\S – не пробелы. str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\s&quot;) str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\S&quot;) \\\\w – не пробелы и не знаки препинания. \\\\W – пробелы и знаки препинания. str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\w&quot;) str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\W&quot;) произвольная группа символов и обратная к ней str_view_all(&quot;Умей мечтать, не став рабом мечтанья&quot;, &quot;[оауиыэёеяю]&quot;) str_view_all(&quot;И мыслить, мысли не обожествив&quot;, &quot;[^оауиыэёеяю]&quot;) встроенные группы символов str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;[0-9]&quot;) str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;[а-я]&quot;) str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;[А-Я]&quot;) str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;[А-я]&quot;) str_view_all(&quot;The quick brown Fox jumps over the lazy Dog&quot;, &quot;[a-z]&quot;) str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;[^0-9]&quot;) выбор из нескольких групп str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;лар|рал|арл&quot;) произвольный символ str_view_all(&quot;Везет Сенька Саньку с Сонькой на санках. Санки скок, Сеньку с ног, Соньку в лоб, все — в сугроб&quot;, &quot;[Сс].н&quot;) знак начала и конца строки str_view_all(&quot;от топота копыт пыль по полю летит.&quot;, &quot;^о&quot;) str_view_all(&quot;У ежа — ежата, у ужа — ужата&quot;, &quot;жата$&quot;) есть еще другие группы и другие обозначения уже приведенных групп, см. ?regex 5.8.3 Квантификация ? – ноль или один раз str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;еее?&quot;) * – ноль и более раз str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;ее*&quot;) + – один и более раз str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;е+&quot;) {n} – n раз str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;е{2}&quot;) {n,} – n раз и более str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;е{1,}&quot;) {n,m} – от n до m. Отсутствие пробела важно: {1,2} – правильно, {1,␣2} – неправильно. str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;е{2,3}&quot;) группировка символов str_view_all(&quot;Пушкиновед, Лермонтовед, Лермонтововед&quot;, &quot;(ов)+&quot;) str_view_all(&quot;беловатый, розоватый, розововатый&quot;, &quot;(ов)+&quot;) жадный vs. нежадный алоритмы str_view_all(&quot;Пушкиновед, Лермонтовед, Лермонтововед&quot;, &quot;в.*ед&quot;) str_view_all(&quot;Пушкиновед, Лермонтовед, Лермонтововед&quot;, &quot;в.*?ед&quot;) 5.8.4 Позиционная проверка (look arounds) Позиционная проверка – выглядит достаточно непоследовательно даже в свете остальных регулярных выражений. Давайте найдем все а перед р: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;а(?=р)&quot;) А теперь все а перед р или л: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;а(?=[рл])&quot;) Давайте найдем все а после р str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;(?&lt;=р)а&quot;) А теперь все а после р или л: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;(?&lt;=[рл])а&quot;) Также у этих выражений есть формы с отрицанием. Давайте найдем все р не перед а: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;р(?!а)&quot;) А теперь все р не после а: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;(?&lt;!а)р&quot;) Запомнить с ходу это достаточно сложно, так что подсматривайте сюда: Вот отсюда можно скачать файл с текстом стихотворения Н. Заболоцкого “Меркнут знаки задиака”. Посчитайте долю женских (ударение падает на предпоследний слог рифмующихся слов) и мужских (ударение падает на последний слог рифмующихся слов) рифм в стихотворении. 📋 список подсказок ➡ 👁 Датасеты скачивается с ошибкой, почему? ➡ Дело в том, что исходный файл в формате .txt, а не .csv. Его нужно скачивать, например, командой read_lines() 👁 Ошибка: ...applied to an object of class \"character\" ➡ Скачав файл Вы получили вектор со строками, где каждая элимент вектора – строка стихотворения. Создайте tibble(), тогда можно будет применять стандартные инструменты tidyverse. 👁 Хорошо, tibble() создан, что дальше? ➡ Дальше нужно создать переменную, из которой будет понятно, мужская в каждой строке рифма, или женская. 👁 А как определить, какая рифма? Нужно с словарем сравнивать? ➡ Формально говоря, определять рифму можно по косвенным признакам. Все стихотворение написано четырехстопным хореем, значит в нем либо 7, либо 8 слогов. Значит, посчитав количество слогов, мы поймем, какая перед нами рифма. 👁 А как посчитать гласные? ➡ Нужно написать регулярное выражение… вроде бы это тема нашего занятия… 👁 Гласные посчитаны. А что дальше? ➡ Ну теперь нужно посчитать, сколько каких длин (в количестве слогов) бывает в стихотворении. Это можно сделать при помощи функции count(). 👁 А почему у меня есть строки длины 0 слогов ➡ Ну, видимо, в стихотворении были пустые строки. Они использовались для разделения строф. 👁 А почему у меня есть строки длины 6 слогов ➡ Ну, видимо, Вы написали регулярное выражение, которое не учитывает, что гласные буквы могут быть еще и в начале строки, а значит написаны с большой буквы. В ходе анализа данных чаще всего бороться со строками и регулярными выражениями приходится в процессе обработки неаккуратно собранных анкет. Предлагаю обработать переменные sex и age такой вот неудачно собранной анкеты и построить следующий график: {r, cache=TRUE, include=FALcache=TRUE, (\"https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/mad_questionary.csv\") %&gt;% mutate(sex = str_replace_all(sex, \"^[Жж].*\", \"женский\"), sex = str_replace_all(sex, \"^[Мм].*\", \"мужской\"), age = str_remove_all(age, \" лет\"), age = as.integer(age)) %&gt;% ggplot(aes(age, fill = sex))+ geom_dotplot(method = \"histodot\")+ scale_y_continuous(NULL, breaks = NULL) # чтобы убрать ось y 📋 список подсказок ➡ 👁 А что это за geom_...()? ➡ Это geom_dotplot() с аргументом method = \"histodot\" и с удаленной осью y при помощи команды scale_y_continuous(NULL, breaks = NULL) 👁 Почему на графике рисутеся каждое значение возраста? ➡ Если Вы все правильно преобразовали, должно помочь преобразование строковой переменной age в числовую при помощи функции as.integer(). 5.9 Определение языка Для определения языка существует два пакета cld2 (вероятностный) и cld3 (нейросеть). udhr_24 &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/article_24_from_UDHR.csv&quot;) ## Parsed with column specification: ## cols( ## article_text = col_character() ## ) udhr_24 ## # A tibble: 6 x 1 ## article_text ## &lt;chr&gt; ## 1 Каждый человек имеет право на отдых и досуг, включая право на разумное о… ## 2 Everyone has the right to rest and leisure, including reasonable limitat… ## 3 Toute personne a droit au repos et aux loisirs et notamment à une limita… ## 4 Toda persona tiene derecho al descanso, al disfrute del tiempo libre, a … ## 5 لكلِّ شخص حقٌّ في الراحة وأوقات الفراغ، وخصوصًا في تحديد معقول لساعات ال… ## 6 人人有享有休息和闲暇的权利，包括工作时间有合理限制和定期给薪休假的权利。 cld2::detect_language(udhr_24$article_text) ## [1] &quot;ru&quot; &quot;en&quot; &quot;fr&quot; &quot;es&quot; &quot;ar&quot; &quot;zh&quot; cld2::detect_language(udhr_24$article_text, lang_code = FALSE) ## [1] &quot;RUSSIAN&quot; &quot;ENGLISH&quot; &quot;FRENCH&quot; &quot;SPANISH&quot; &quot;ARABIC&quot; &quot;CHINESE&quot; cld3::detect_language(udhr_24$article_text) ## [1] &quot;ru&quot; &quot;en&quot; &quot;fr&quot; &quot;es&quot; &quot;ar&quot; &quot;zh&quot; cld2::detect_language(&quot;Ты женат? Говорите ли по-английски?&quot;) ## [1] &quot;bg&quot; cld3::detect_language(&quot;Ты женат? Говорите ли по-английски?&quot;) ## [1] NA cld2::detect_language(&quot;Варкалось. Хливкие шорьки пырялись по наве, и хрюкотали зелюки, как мюмзики в мове.&quot;) ## [1] &quot;ru&quot; cld3::detect_language(&quot;Варкалось. Хливкие шорьки пырялись по наве, и хрюкотали зелюки, как мюмзики в мове.&quot;) ## [1] &quot;ru&quot; cld2::detect_language(&quot;Варчилось… Хлив&#39;язкі тхурки викрули, свербчись навкрузі, жасумновілі худоки гривіли зехряки в чузі.&quot;) ## [1] &quot;uk&quot; cld3::detect_language(&quot;Варчилось… Хлив&#39;язкі тхурки викрули, свербчись навкрузі, жасумновілі худоки гривіли зехряки в чузі.&quot;) ## [1] &quot;uk&quot; cld2::detect_language_mixed(&quot;Многие в нашей команде OpenDataScience занимаются state-of-the-art технологиями машинного обучения: DL-фреймворками, байесовскими методами машинного обучения, вероятностным программированием и не только.&quot;) ## $classificaton ## language code latin proportion ## 1 RUSSIAN ru FALSE 0.87 ## 2 ENGLISH en TRUE 0.11 ## 3 UNKNOWN un TRUE 0.00 ## ## $bytes ## [1] 353 ## ## $reliabale ## [1] TRUE cld3::detect_language_mixed(&quot;Многие в нашей команде OpenDataScience занимаются state-of-the-art технологиями машинного обучения: DL-фреймворками, байесовскими методами машинного обучения, вероятностным программированием и не только.&quot;) ## language probability reliable proportion ## 1 ru 0.9983915 TRUE 0.88951844 ## 2 en 0.9992564 TRUE 0.05099150 ## 3 sr 0.4266235 FALSE 0.04815864 5.10 Расстояния между строками Существует много разных метрик для измерения расстояния между строками (см. ?`stringdist-metrics`), в примерах используется расстояние Дамерау — Левенштейна. Данное расстояние получается при подсчете количества операций, которые нужно сделать, чтобы перевести одну строку в другую. вставка ab → aNb удаление aOb → ab замена символа aOb → aNb перестановка символов ab → ba library(stringdist) stringdist(&quot;корова&quot;,&quot;корова&quot;) ## [1] 0 stringdist(&quot;коровы&quot;, c(&quot;курица&quot;, &quot;бык&quot;, &quot;утка&quot;, &quot;корова&quot;, &quot;осел&quot;)) ## [1] 4 6 6 1 5 amatch(c(&quot;быки&quot;, &quot;коровы&quot;), c(&quot;курица&quot;, &quot;бык&quot;, &quot;утка&quot;, &quot;корова&quot;, &quot;осел&quot;), maxDist = 2) ## [1] 2 4 "]
]
